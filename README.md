# Java-Nov-2020
KAYNAK GÖSTERMEK KOŞULUYLA HER TÜRLÜ ALINTI YAPILABİLİR

#java
#programming
#eclipse
#intellij
#spring
#springboot

```java
/*----------------------------------------------------------------------------------------------------------------------
    29.11.2020
    Hello, World programı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
	}
}
/*----------------------------------------------------------------------------------------------------------------------
    Atom (token)
    Bir programlama dilinde kendi başına anlamlı en küçük yapı birimine denir. 
    1. Anahtar sözcükler (keywords/reserved words): Dil için özel anlamı olan ve değişken ismi olarak kullanılması
    yasak olan atomlardır. Örneğin:int, public, class gibi

    2. Değişkenler (identifiers/variables): İsmini programcının belli kurallara göre belirlediği atomlardır. Örneğin 
    Hello, World programındaki csd.

    3. Operatörler (operators): Bir işleme yol açan ve işlem sonucunda bir değer üretilmesini sağlayan atomlardır
    Örneğin: a + b ifadesindeki + operatörü

    4. Sabitler (literals/constants): Program içerisinde doğrudan yazılan sayılara denir. Örneğin: a * 23 ifadesinde
    23 bir sabittir.

    5. String'ler (String literals): İki tırnak içerisindeki yazılara tırnaklarıyla birlikte string atomu denir

    6. Ayıraçlar (delimiters/punctuators): Yukarıdaki atomlar dışında kalan diğer atomladır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Boşluk karakterleri (whitespace characters): Klavyeden basıldığında boşluk hissi veren karakterlere denir. Boşluk
    karakterleri tipik olarak SPACE, TAB, ENTER karakterleridir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Java'da yazım kuralları:
    1. Atomlar arasında istenildiği kadar boşluk bırakılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App 						{
	public static void main(String [] 













args)
	{
		System .        					out





.println("Hello, World");
	







}
}

/*----------------------------------------------------------------------------------------------------------------------
    Java'da yazım kuralları:
    2. Anahtar sözcük ve değişkenlerin dışında kalan atomlar istenildiği kadar bitişik yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;class App{public static void main(String[]args){System.out.println("Hello, World");}}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar sözcükler ve değişken atomlar bitişik yazılamaz. Yani iki anahtar sözcük, iki değişken veya bir anahtar
    sözcük ve bir değişken arasında en az bir boşluk karakteri olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;class App{publicstatic void main(String[]args){System.out.println("Hello, World");}}
/*----------------------------------------------------------------------------------------------------------------------
    Java' da yorum satırları (comment lines)
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
	//Bu kısım derleyici tarafından görülmez
		System.out.println("Hello, World"); //Bu kısım da görülmez
	/*
		Bu bölüm de 
		derleyici
		tarafından görülmez
	*/
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    05.12.2020
    Derleyiciler kod içerisinde bir takım mesajlar verebilirler. Bu tür mesajlara "teşhis mesajları (diagnostic messages)"
    denir. Java'da derleyicinin verebileceği 3(üç) grup mesaj vardır:

    1. Gerçek hatalar (errors): Dilin sentaks ve semantik kurallarına uyulmamasından kaynaklanan hatalardır. Bu durumda
    arakod üretilmez. Programcının bu hatayı düzeltip kodu derlemesi gerekir.

    2. Uyarılar (warnings): Derleyicinin olası bir programlama hatası olarak gördüğü sentaks ve semantik olarak bir
    problemin olmadığı durumlarda verilen mesajlardır. Bu durum arakodun üretimini engellemez. Ancak programcı
    uyarıcı mesajlarını mutlaka dikkate almalıdır. Emin olmadıkça uyarı mesajlarını oluşturan kodları düzeltmelidir.
    Pratikte bir uygulamanın hiç uyarı mesajı olmayacak şekilde derlenmesi ve ürün haline getirilmesi hedeflenmelidir.
    Bazı durumlarda IDE programlar derleyici dışında kendi uyarı mesajlarını verebilirler. Bu durumlarda şüphesiz
    dikkate alınmalıdır. Yine emin olmadıkça bu uyarılarla devam edilmemelidir.

    3. Ölümcül hatalar (fatal errors): Derleme işleminin bitirilmesini dahi engelleyecek ciddi hatalardır. Bu durumlarda
    programcının kodlama anlamında yapabileceği birşey genelde yoktur. Ölümcül hataya yol açan durumu ortadan kaldırırak
    derleme işlemini yapması gerekir. Örneğin, sistemdeki problemler, diskte yer kalmaması, var olmayan bir .java dosyasının
    verilmesi gibi hatalardır

    Anahtar Notlar: Biz örneklerimizde bazı durumlarda bazı uyarıları görmezden gelebileceğiz. Ancak uyarılar zaman 
    içerisinde ortadan kaldırılacaktır

    Java programcısı için yazdığı program açısından iki kavram çok önemlidir: derleme zamanı (compile-time), çalışma zamanı (run-time)
    Derleme zamanı derleme sırasındaki durumları, çalışma zamanı ise uygulamanın çalışması sırasındaki durumları betimler.

    Çalışma zamanı sırasında oluşan genel olarak hatalı durumlara "exception" denir. "Exception işlemleri" konusuna
    gelene kadar bizim için "exception" oluşması programın çökmesi anlamına gelecektir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 Bildirim (declaration): Bir ismin derleyiciye tanıtılmasıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 Java' da genel olarak bir program paketlerden, paketler sınıflardan, sınıflar da metotlardan oluşur. Paket içerisinde
	 alt paketler ve başka elamanlar, sınıflar içerisinde başka elemanlar olabilir. Paket bildiriminin genel biçimi:
	 	package <isim>;
	 Paketler konusu ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf bildiriminin genel biçimi:
	[erişim belirleyici] class <isim> {
		//...
	}
	
	Sınıflar konusu ileride detaylı olarak incelenecektir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World!!");
	}
}


class Sample {
	//...
}

class Person {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da alt programlara "metot" denir. Metodun bildirimi alt programın kodlarının yani ne iş yapacağının
	yazılmasıdır. Metot bildiriminin genel biçimi:
	
	[erişim belirleyici] [static] <geri dönüş değeri bilgisi> <isim>([parametreler])
	{
		//...
	}
	
	erişim belirleyici şunlardan biri olabilir: public, no-modifier (hiç birşey yazmamak), protected, private
	İlgili konuya kadar tüm metotlarımızı public olarak bildireceğiz.
	
	Bir metot static veya no-static olabilir. Bildirim sırasında static yazılmaması non-static anlamına gelir.
	Yine ilgili konuya gelene kadar metotlarımızı static olarak bildireceğiz.
	
	Anahtar Notlar: Erişim belirleyici ve static anahtar sözcüğü yer değişmeli kullanılabilir. Ancak okunabilirlik
	açısından erişim belirleyiciyi önce yazacağız. 
	
	geri dönüş değeri bilgisi bir "tür (type)" bilgisi olabilir. "Geri dönüş değeri olmayan metotlar" için void 
	anahtar sözcüğü yazılır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World!!");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}	
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir alt programın çalıştırılmasına ilişkin sentaksa "metot çağırma (method call)" sentaksı denir. Metot çağırma
	işleminin genel biçimi:
	[paket ismi].[sınıf ismi].<metot ismi>([argüman listesi]); 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World!!");
		csd.Sample.foo();
		csd.Sample.bar();
		csd.Mample.tar();		
		System.out.println("Good bye, World!!");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}	
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metot içerisinde başka bir metot çağrılabilir. Program çalışmaya main metodunun çağrılmasıyla başlar.
	main metodu JVM tarafından çağrılır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World!!");
		csd.Sample.foo();
		csd.Sample.bar();
		csd.Mample.tar();		
		System.out.println("Good bye, World!!");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		csd.Mample.tar();
	}	
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	println metodu yazdığı son karakterden sonra imleci bir alt satırın başına çeker 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba");
		System.out.println("Nasılsın?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	print metodu imleci yazdığı son karakterden sonrada bırakır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.print("Merhaba ");
		System.out.println("Nasılsın?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anlaşıldığı gibi bir metot başka bir metodun içerisinde çağrılır. Çağıran metoda "caller", çağrılan metoda ise
	"callee" denir 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Çağıran metodun (caller) ait olduğu sınıf ile çağrılan metodun (callee) ait olduğu sınıf aynı paket içerisindeyse
	çağırma ifadesinde paket ismi yazılmayabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample.foo();
		Sample.bar();
		Mample.tar();	
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		Mample.tar();
	}	
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Çağıran metot ile çağrılan metot aynı sınıf içerisinde ise çağırma ifadesinde sınıf ismi de yazılmayabilir.
	Şüphesiz paket ismi yazılacaksa sınıf ismi de yazılmalıdır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample.foo();
		Sample.bar();
		Mample.tar();	
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		Mample.tar();
		bar();
	}	
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	06.12.2020
	Tür (type): Bir değişken için bellekte kaç byte yer ayrılacağını ve içerisindeki bilginin hangi formatta tutulacağını
	belirten kavrama denir.
	
	Temel türler (built-in, pre-defined, primitive)
	Tür ismi			Uzunluğu (byte)
	short					2
   *int						4
	long					8
	byte					1
	
	float					4
   *double					8
	
	char					2
	boolean					-
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir değişken ismi bildirilmeden kullanılamaz. Değişken bildiriminin genel biçimi:
	
		<tür> <isim>;
	int a;
	double average;
	boolean exitFlag;	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da 3 (üç) çeşit değişken vardır:
	1. Yerel değişkenler (local variables)
	2. Parametre değişkenleri (parameter variables)
	3. Sınıf veri elemanları (member variables, field)
	
	Değişkenler için temel kavramlar:
	İsim (name): Belli kurallara bağlı olarak yazılan karakterler topluluğudur
	Türü (type): Değişkenin bellekte ne kadar yer kapladığı ve içerisindeki bilginin hangi formatta tutulduğunu belirtir
	Faaliyet Alanı (scope): Bir değişken isminin derleyici tarafından görülebildiği kod aralığıdır
	Ömür (storage duration): Bellekte kalma süresidir
	
	Temel Kavramlar:
	Blok (block): Bir metot içerisinde { küme prantezi ile } parantezi arasında kalan kod bölümüne denir. Metodun 
	gövdesi de aslında bir bloktur
	
	İfade (expression): Sabitlerden, operatörlerden ve değişkenlerden oluşşan herhangi bir anlamlı dizilim 
	
	İlkdeğer verme (initialization): Bir değişkene bildirim noktasında verilen ifadeye denir. Genel biçimi:
	
	<tür> <isim> = <ifade>;
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Bir metot içerisinde istenildiği kadar içiçe veya ayrık bloklar olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		{
			//...
		}
		
		{
			//...
			{
				//...
			}
		}
	}
}


class Sample {
	public static void foo()
	{
		{
			//...
			{
				//...
				{
					//...
				}
			}
		}
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere yerel değişkenler denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a; //yerel değişken
		
		//...
	}
}

class Sample {
	public static void foo()
	{
		int x; 
		
		{
			double y;
			{
				float z;
				
				//...
			}
			
		}
		
		{
			boolean flag;
			
			//...
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aynı türden yerel değişkenler aralarına virgül konarak bildirilebilirler
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		int x, y, z;
		
		//...		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yerel değişkenlere ilkdeğer verilmesi
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo()
	{
		int x = 20, y = 67, z = -9;
		double t = 4.5;
		boolean flag = true;	
	
		//...		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yerel bir değişkenin faaliyet alanı bildirildiği yerden itibaren bildirildiği bloğun sonuna kadardır. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo()
	{
		{
			//...
			int a;
			
			a = 45;			
		}
		
		a = 34; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo()
	{
		int a;
		double a; //error
		
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		int a;
		
		
		{
			double a; //error
			
			
		}
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanları içerisinde aynı isimde yerel değişkenler bildirilebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo()
	{		
		
		{
			double a;
			
			//..
		}
		
		int a;
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanları içerisinde aynı isimde yerel değişkenler bildirilebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo()
	{		
		
		{
			int a;
			
			//...
		}	
		

		{
			int a;
			
			//...
		}
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanları içerisinde aynı isimde yerel değişkenler bildirilebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
				//...
	}
}

class Sample {
	public static void foo()
	{
		int numberOfStudents;
		
		//...
		
	}
	
	public static void bar()
	{		
		int numberOfStudents;
		
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	print ve println metotları değişkenlerin içerisindeki değerleri ekrana basarlar 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();			
	}
}

class Sample {
	public static void foo()
	{
		int a = 10;
		
		System.out.println(a);
		
		a = 20;		
		
		System.out.println(a);
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	İçerisine değer atanmamış hiçbir değişken kullanılamaz yani içerisinde değer varmış gibi işleme sokulamaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();			
	}
}

class Sample {
	public static void foo()
	{
		int a;
		int x = a * 4; //error
		
		System.out.println(a); //error		
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	Yerel değişkenlere değer atanması programcının sorumluluğundadır. Java' da yerel değişkenlere otomatik olarak
	değer atanmaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();			
	}
}

class Sample {
	public static void foo()
	{
		int a = 23;
		int x = a * 4;
		
		System.out.println(a); 		
		System.out.println(x);
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	Yerel değişkenlere değer atanması programcının sorumluluğundadır. Java' da yerel değişkenlere otomatik olarak
	değer atanmaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();			
	}
}

class Sample {
	public static void foo()
	{
		int a;		
		
		a = 34;
		
		int x = a * 4;
		
		System.out.println(a); 		
		System.out.println(x);
	}	
}



/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimleri sayısal bir karakter ile başlatılamaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int 1number; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimleri herhangi bir uygun karakter ile başlatılığı içerisinde isnetildiği kadar sayısal karakter 
	kullanılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a12345 = 10;
		
		System.out.println(a12345);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimlendirmede UNICODE alfabetik karakterler geçerlidir. Örneğin Türkçe karakterler kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int oğrencisayısı = 100;
		
		System.out.println(oğrencisayısı);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimleri büyük küçük harf duyarlıdır (case sensitive)
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int val, Val, VAL, vaL;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimlendirmede boşluk (whitespace) karakterler kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int number of	students; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimlendirmede _ (alttire) karakteri kullanılabilir. Hatta _ karaktesi değişken isminin başında da 
	kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int _123 = 10;
		int _val = 23;
		int number_of_students = 20;
		
		System.out.println(_123);
		System.out.println(_val);
		System.out.println(number_of_students);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlamada artık kullanılması tavsiye edilmeyen durumlar için "deprecated" terimi kullanılır.
	Bu durumun gerekçeleri farklı farklı olabilir. Ancak programcı açısından genel olarak "deprecated" olan bir durumun
	kullanımı tercih edilmemelidir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Java 9 ile birlikte alttire karakteri tek başına değişken olarak kullanılamaz. Alttire karakterinin tek başına 
	ismi olarak kullanılması durumu Java 8 ile birlikte "deprecated" olmuştur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int _ = 10; //error
		
		System.out.println(_); //error		
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Java'da değişken isimlendirmede $ karakteri kullanılabilir. Hatta $ karakteri ile değişken isimi başlatılabilir.
	$ tek başına değişken ismi de olabilir. Ancak programcı açısından değişken isimlendirmede $ karakteri KULLANILMAMASI
	daha uygundur. Çünkü derleyici ve bazı otomatik arakod üreten araçlar isimlendirmede $ karakterini tercih edebilirler.
	(çoğu zaman ederler). İsim çakışması olmaması açısından $ karakteri değişken isimlendirmede programcılar tarafından
	kullanılmaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int amountOf$s = 1000;
		int $1234 = 34;
		double $ = 34.5;
		
		System.out.println(amountOf$s);
		System.out.println($1234);
		System.out.println($);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimleri doğrudan anahtar sözcüklerden olamaz. Ancak bu durumuna istisna olarak Java'ya daha
	sonra eklenen bazı sözcükler değişken isimlendirmede kullanılabilir. Bu sözcük tam anlamıyla anahtar sözcük değildir.
	Bu tip sözcüklere programlamada genel olarak "bağlamsal anahtar sözcükler (contextual keywords)" denir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		var a = 10;
		int var = 10;
		int double; //error
		double class; //error
		
		
		//...	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimlerinin kolay telaffuz edilebilir, anlamlı ve yeterince uzunlukta olması tavsiye edilir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden int türden değer okunması
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);					
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int square = val * val;
		
		System.out.println(square);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden int türden değer okunması
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);					
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());		
		
		int sum = a + b;
		
		System.out.println(sum);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden double türden değer okunması
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);					
		System.out.print("Birinci sayıyı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());		
		
		double sum = a + b;
		
		System.out.println(sum);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden long türden değer okunması
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);					
		System.out.print("Birinci sayıyı giriniz:");
		long a = Long.parseLong(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		long b = Long.parseLong(kb.nextLine());		
		
		long sum = a + b;
		
		System.out.println(sum);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri return deyimi ile oluşturulur. return deyiminin genel biçimi:
	
	return [ifade];
	
	return deyiminin temel görevi metodu sonlandırmaktır. Yani metodun akışı içerisinde return deyimi
	görüldüğünde metot sonlanır. return deyimine ilişkin ifadenin değeri metodu çağıran metoda aktarılır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Sample.foo() * 2;
		
		System.out.println(result);
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java' da derleyici genel olarak bir deyime akışın hiç bir zaman gelemeyeceğini anlarsa o yazılan deyim için error 
	oluşuturur (unreachable code)
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	return deyimi nasıl kullanılırsa kulanılsın metodu sonlandırır. Aşağıdaki kodda return deyiminden sonrasına
	akış hiç bir zaman gelemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Sample.foo() * 2;
		
		System.out.println(result);
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		return result;
		
		System.out.println("Merhaba"); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Akış return deyimine geldiğinde return deyimine ilişkin ifade önce hesaplanır sonra elde edilen değer döndürülür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Sample.foo() * 2;
		
		System.out.println(result);
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());	
		
		return val * val;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda return tek başına kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Sample.foo() * 2;
		
		System.out.println(result);
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());	
		
		return; //error		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda akışın her noktasında return deyimi bulunmalıdır. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Sample.foo() * 2;
		
		System.out.println(result);
	}
}

class Sample {
	public static int foo() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());			
		
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda akışın her noktasında return deyimi bulunmalıdır. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Sample.foo() * 2;
		
		System.out.println(result);
	}
}

class Sample {
	public static int foo() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());	
		
		if (val < 0)
			return val * val;
		
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Derleyici geri dönüş değeri aktarımı için geçici değişken yaratan kodu üretir. Aşağıdaki ** ile işaretlenen kodun 
	temsiliği karşılığı:
		int temp = val * val;
		
		result = temp * 2;
	Yani aslında geri dönüş değeri geçici değişkene yapılan bir atama işlemidir. Geçici değişkenin türü metodun
	geri dönüş değerinin türü ile aynıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Sample.foo() * 2; //**
		
		System.out.println(result);
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());			
		
		return val * val;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	12.12.2020
	Bir metodun geri dönüş değeri başka bir metodun geri dönüş değeri olarak kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result = Mample.bar();
		
		System.out.println(result);
	}
}

class Mample {
	public static int bar()
	{
		System.out.println("bar");		
		
		return Sample.foo();
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());			
		
		return val * val;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değerinin bir ifadede kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		int result = Mample.bar();
		
		System.out.println(result);
	}
}

class Mample {
	public static int bar()
	{
		System.out.println("bar");		
		
		return Sample.foo() * 2;
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());			
		
		return val * val;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlar geri dönüş değeri yokmuş gibi çağrılabilir. Yani bir metodun geri dönüş değerinin 
	bir işleme sokulması zorunlu değildir. Şüphesiz metodun da tasarımı bu kullanımı anlamsız ya da anlamlı kılar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		Sample.foo();
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		System.out.println(result);
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlar geri dönüş değeri yokmuş gibi çağrılabilir. Yani bir metodun geri dönüş değerinin 
	bir işleme sokulması zorunlu değildir. Şüphesiz metodun da tasarımı bu kullanımı anlamsız ya da anlamlı kılar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		Sample.foo();
	}
}

class Sample {
	public static int foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		System.out.println(result);
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olmayan metotlarda (void method) geri dönüş tür bilgisi yerine "void" anahtar sözcüğü yazılır.
	Geri dönüş değeri olmayan metotlarda return zorunlu değildir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		System.out.println(result);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyimi istenirse metodu sonlandırmak için tek başına kullanılabilir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		Sample.foo();
		//...
	}
}

class Sample {
	public static void foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val < 0)
			return;
		
		int result = val * val;
		
		System.out.println(result);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyimi istenirse metodu sonlandırmak için tek başına kullanılabilir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		Sample.foo();
		//...
	}
}

class Sample {
	public static void foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val < 0)
			return val; //error
		
		int result = val * val;
		
		System.out.println(result);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	void metotlar geri dönüş değeri varmış gibi çağrılamaz. Yani void metot çağrıları geri dönüş değeri varmış gibi 
	işleme sokulamaz  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		int result = Sample.foo() * 2; //error
		//...
	}
}

class Sample {
	public static void foo()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());	
		
		int result = val * val;
		
		System.out.println(result);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metot bildiriminde metot isminden sonra parantezler arasında bildirilen değişkenlere parametre değişkenleri
	denir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		
	}
}

class Sample {
	public static void foo(int a, double b)
	{
		//...
	}
	
	public static void bar(float a)
	{
		//...		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişkenlerinin türleri aynı bile olsa tür ismi yazılmalıdır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		
	}
}

class Sample {
	public static void foo(int a, b) //error
	{
		//...
	}	
	
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişkenleri faaliyet alanı bakımından metot gövdesinin (bloğunun) başında bildirilmiş
	yerel değişkenler gibidir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		
	}
}

class Sample {
	public static void foo(int a, int b)
	{
		System.out.println(a);
		System.out.println(b);		
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişkenleri faaliyet alanı bakımından metot gövdesinin (bloğunun) başında bildirilmiş
	yerel değişkenler gibidir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		
	}
}

class Sample {
	public static void foo(int a, int b)
	{		
		double a = 3.4; //error
		
		System.out.println(a);
		System.out.println(b);		
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun paremetrelerine değer çağrılırken aktarılır. Metot çağrısında parametrelere aktarılan ifadelere
	"argüman" denir. Argümanlardan parametrelere yapılan aktarım da bir atama işlemidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int x = Integer.parseInt(kb.nextLine());			
		
		System.out.print("İkinci sayıyı giriniz:");
		int y = Integer.parseInt(kb.nextLine());
		
		Sample.foo(x, y);
	}
}

class Sample {
	public static void foo(int a, int b)
	{		
		System.out.println(a);
		System.out.println(b);		
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun paremetrelerine değer çağrılırken aktarılır. Metot çağrısında parametrelere aktarılan ifadelere
	"argüman" denir. Argümanlardan parametrelere yapılan aktarım da bir atama işlemidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());			
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		Sample.foo(a, b);
	}
}

class Sample {
	public static void foo(int a, int b)
	{		
		System.out.println(a);
		System.out.println(b);		
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metot parametre sayısı kadar argüman ile çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());			
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		Sample.foo(a); //error
	}
}

class Sample {
	public static void foo(int a, int b)
	{		
		System.out.println(a);
		System.out.println(b);		
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	Metot çağrısında bir argümana ilişkin ifade önce hesaplanır. Elde edilen değer ile metot çağrılır. Şüphesiz
	parametre sayısı fazla metot için her argüman ilişkin ifadenin değeri hesaplandıktan sonra metot çağrılır	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());			
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		Sample.foo(a - 5, b * 2);
	}
}

class Sample {
	public static void foo(int a, int b)
	{		
		System.out.println(a);
		System.out.println(b);		
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun hem parametre değişken(ler)i hem de geri dönüş değeri olabilir 	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.square(a);
		
		System.out.println(result);		
	}
}

class NumberUtil {
	public static int square(int val)
	{
		return val * val;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri başka bir metoda argüman olarak geçilebilir 	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		Util.display(NumberUtil.add(a, b));		
	}
}

class Util {
	public static void display(int val)
	{
		System.out.println(val);
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri başka bir metoda argüman olarak geçilebilir 	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		CalculateTotalApp.run();
	}
}

class CalculateTotalApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		Util.display(NumberUtil.add(a, b));
	}
}

class Util {
	public static void display(int val)
	{
		System.out.println(val);
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri başka bir metoda argüman olarak geçilebilir. Aşağıdaki ** ile belirtilen deyime
	ilişkin ifade gibi "compact" olarak yazılan ifadelerde okunabilirliğe dikkat edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		CalculateTotalApp.run();
	}
}

class CalculateTotalApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		Util.display(NumberUtil.add(a - 2, b * 6)); //**
	}
}

class Util {
	public static void display(int val)
	{
		System.out.println(val);
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri başka bir metoda argüman olarak geçilebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		CalculateTotalApp.run();
	}
}

class CalculateTotalApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.add(a - 2, b * 6));
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte iki add çağrısı arasında argümanlarda değişiklik kesin olmamasına karşın iki kere çağrılmıştır.
	Bu durumda kod hem iki defa çağırmanın gereksizliği anlamında hem de okunabilirlik/algılanabilirlik açısından
	kötü yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		CalculateTotalApp.run();
	}
}

class CalculateTotalApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.add(a, b));
		
		//...(bu kısımda a ve b'ye yeni atamalar yapılmıyor)
		
		System.out.println(NumberUtil.add(a, b));
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kod aşağıdaki gibi daha iyi bir şekilde yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		CalculateTotalApp.run();
	}
}

class CalculateTotalApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int sum = NumberUtil.add(a, b);
		
		System.out.println(sum);
		
		//...(bu kısımda a ve b'ye yeni atamalar yapılmıyor)
		
		System.out.println(sum);
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodunun ilk argümanı String atomu olmalıdır. Metot bu argüman dışında istenilen türde
	ve istenilen sayıda başka argüman alabilir. Metodun birinci argümanında % karakteri ile beraber anlamlı bazı karakterle
	kullanıldığında "yer tutucu (place holder)" belirtilmiş olur. % ile birlikte kullanılan bu anlamlı karakterlere
	"format karakterleri (format specifier)" denir. Metot format karakterleri yerine String içerisindeki sırayla diğer 
	geçilen argümanlara ilişkin değerleri koyarak yazıyı ekrana basar. Bazı format karakterleri bir argümana ilişkin değere
	karşılık gelmez. Yazı içerisinde başka bir anlamı olur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Tam sayı türlerinin (short, int, long, byte) decimal formatlanması için d format karakteri kullanılır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Derece bilgisini giriniz:");
		int degree = Integer.parseInt(kb.nextLine());
		
		System.out.printf("Bugün hava %d derece", degree);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodunda n format karakteri imleci bir alt satırın başına geçirmek için kullanılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Derece bilgisini giriniz:");
		int degree = Integer.parseInt(kb.nextLine());
		
		System.out.printf("Bugün hava %d derece%n", degree);
		System.out.println("Teşekkür ederiz");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tam sayı türlerinin (short, int, long, byte) decimal formatlanması için d format karakteri kullanılır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bugünkü derece bilgisini giriniz:");
		int degreeToday = Integer.parseInt(kb.nextLine());
		
		System.out.print("Yarınki derece bilgisini giriniz:");
		int degreeTomorrow = Integer.parseInt(kb.nextLine());
		
		System.out.printf("Bugün hava %d derece, yarın %d derece olacak.%n", degreeToday, degreeTomorrow);
		System.out.println("Teşekkür ederiz");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 System.out.printf metodu ile x, X, h, H format karakterleri kullanılarak tamsayı türleri hexadecimal olarak
	 formatlanabilir. Ayrıca o (küçük o) format karakteri ile tamsayı türleri octal olarak formatlanabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val(decimal)=%d%n", val);
		System.out.printf("val(hex)=%x%nval(hex)=%X%n", val, val);
		System.out.printf("val(hex)=%h%nval(hex)=%H%n", val, val);
		System.out.printf("val(octal)=%o%n", val);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 System.out.printf metodu ile gerçek sayı türleri (double, float) için f format karakteri kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		double val = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val=%f%n", val);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 System.out.printf metodunda f format karakteri ile ondalık kısmın (mantis) kaç basamak ile gösterileceği 
	 belirtilebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("%.2f + %.2f = %.20f%n", a, b, a + b);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 System.out.printf metodu ile tam sayılar için hizalama yapılması
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün bilgisini giriniz:");
		int day = Integer.parseInt(kb.nextLine());
		
		System.out.print("Ay bilgisini giriniz:");
		int month = Integer.parseInt(kb.nextLine());
		
		System.out.print("Yıl bilgisini giriniz:");
		int year = Integer.parseInt(kb.nextLine());
		
		//...
		
		System.out.printf("%02d/%02d/%04d%n", day, month, year);		
		System.out.printf("%2d/%2d/%4d%n", day, month, year);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 System.out.printf metodunda c format karakteri char türü için kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		char ch = 40000;
		
		System.out.printf("ch=%c%n", ch);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 System.out.printf metodunda b format karakteri boolean türü için kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean flag = true;
		
		System.out.printf("flag=%b%n", flag);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden girilen iki tane sayının toplamını formatlı olarak ekrana basan program
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		CalculateTotalApp.run();
	}
}

class CalculateTotalApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d + %d = %d%n", a, b, NumberUtil.add(a, b));		
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Arasınav notunu giriniz:");
		int midtermGrade = Integer.parseInt(kb.nextLine());
		
		System.out.print("Final notunu giriniz:");
		int finalGrade = Integer.parseInt(kb.nextLine());
		
		double result = midtermGrade * 0.4 + finalGrade * 0.6;
		
		System.out.printf("Arasınav:%d, Final:%d=>Sonuç:%f%n", midtermGrade, finalGrade, result);	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu ile % karakteri gösterebilmek için iki tane yanyana % karakteri kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Oranı giriniz:");
		double ratio = Double.parseDouble(kb.nextLine());
		
		System.out.printf("Oran:%% %f%n", ratio);				
		System.out.printf("Oran:%%%f%n", ratio);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	13.12.2020
	Math sınıfının abs metodu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		double val = Double.parseDouble(kb.nextLine());
		
		System.out.printf("|%f|=%f%n", val, Math.abs(val));
	}
}





/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının sqrt metodu. Metot negatif argümanlar için NaN değerine döner
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		double val = Double.parseDouble(kb.nextLine());
		
		System.out.printf("sqrt(%f)=%f%n", val, Math.sqrt(val));
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Tamsayılarla bölme işlemi yapıldığında payda sıfır ise exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
				
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a / b;
		
		System.out.printf("%d / %d = %d%n", a, b, result);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayılar ile bölme işlemi yapıldığında payda sıfır ise payın işaretine göre gerçek sayılar içerisinde
	bulunan +Infinity ve -Infinity değerlerinden bir elde edilir. Infinity değerlerleri genel olarak Matematik'teki
	tanımsızlık kavramına karşılık gelir. Eğer pay ve paydanın ikisi birden sıfırsa NaN denilen bir değer elde 
	edilir. Bu değer de genel olarak belirsizlik kavramına karşılık gelir	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
				
		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		
		double result = a / b;
		
		System.out.printf("%f / %f = %f%n", a, b, result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının pow metodu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Tabanı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Üssü giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("pow(%f, %f)=%f%n", a, b, Math.pow(a, b));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı double türden x1, y1, x2, y2 koordinat bilgilerine göre iki nokta
	arasındaki uzaklık değerini döndüren distance isimli metodu PointUtil isimli sınıf içerisinde yazınız. Klavyeden
	alınan değerler ile çağırarak test ediniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		DistanceTest.run();
	}
}


class DistanceTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1?");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1?");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2?");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2?");
		double y2 = Double.parseDouble(kb.nextLine());
		
		double result;
		
		result = PointUtil.distance(x1, y1, x2, y2);
		
		System.out.printf("Distance:%f%n", result);		
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); 				
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı double türden x1, y1, x2, y2 koordinat bilgilerine göre iki nokta
	arasındaki uzaklık değerini döndüren distance isimli metodu PointUtil isimli sınıf içerisinde yazınız. Klavyeden
	alınan değerler ile çağırarak test ediniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		DistanceTest.run();
	}
}


class DistanceTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1?");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1?");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2?");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2?");
		double y2 = Double.parseDouble(kb.nextLine());
		
		double result;
		
		result = PointUtil.distance(x1, y1, x2, y2);
		
		System.out.printf("Distance:%f%n", result);		
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); 				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı double türden x1, y1, x2, y2 koordinat bilgilerine göre iki nokta
	arasındaki uzaklık değerini döndüren distance isimli metodu PointUtil isimli sınıf içerisinde yazınız. Klavyeden
	alınan değerler ile çağırarak test ediniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		DistanceTest.run();
	}
}


class DistanceTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1?");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1?");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2?");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2?");
		double y2 = Double.parseDouble(kb.nextLine());
		
		double result;
		
		result = PointUtil.distance(x1, y1, x2, y2);
		
		System.out.printf("Distance:%f%n", result);		
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		double dx = x1 - x2;
		double dy = y1 - y2;
		
		return Math.sqrt(dx * dx + dy * dy); 				
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının PI ve E sabit elemanları 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.printf("PI:%.20f%n", Math.PI);
		System.out.printf("E:%.20f%n", Math.E);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının trigometrik işlem yapan metotları radyan ölçü birimi ile çalışır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Açı değerini derece cinsinden giriniz:");
		double angle = Double.parseDouble(kb.nextLine());
		
		System.out.printf("sin(%f)=%f%n", angle, Math.sin(Math.toRadians(angle)));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının min ve max metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("min(%d, %d)=%d%n", a, b, Math.min(a, b));
		System.out.printf("max(%d, %d)=%d%n", a, b, Math.max(a, b));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden 3 tane değerin en büyüğünü döndüren max ve en küçüğünü
	döndüren min metotlarını NumberUtil isimli sınıfta yazınız ve klavyeden girilen değerler ile çağırarak 
	test ediniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		MinMaxTest.run();
	}
}

class MinMaxTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.print("Üçüncü sayıyı giriniz:");
		int c = Integer.parseInt(kb.nextLine());
		
		System.out.printf("min(%d, %d, %d)=%d%n", a, b, c, NumberUtil.min(a, b, c));
		System.out.printf("max(%d, %d, %d)=%d%n", a, b, c, NumberUtil.max(a, b, c));
	}
}

class NumberUtil {
	public static int min(int a, int b, int c)
	{
		return Math.min(Math.min(a, b),  c);
	}
	
	public static int max(int a, int b, int c)
	{
		return Math.max(Math.max(a, b),  c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının logXXX metotları 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f)=%f%n", a, Math.log(a));
		System.out.printf("log10(%f)=%f%n", a, Math.log10(a));
		System.out.printf("log1p(%f)=%f%n", a, Math.log1p(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının yuvarlama yapan temel metotları 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("round(%f)=%d%n", a, Math.round(a));
		System.out.printf("rint(%f)=%f%n", a, Math.rint(a));
		System.out.printf("ceil(%f)=%f%n", a, Math.ceil(a));
		System.out.printf("floor(%f)=%f%n", a, Math.floor(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sabitler (literals):
	Program içerisinde doğrudan yazılan sayılara denir. Sabitlerin de türleri vardır. Derleyici sabitin türüni tespit
	ederek işlemler yapar.
	Sabitlerin türlerininin tespitine ilişkin detaylar:
	- Sayı nokta içerimiyorsa ve sonuna bir ek almamışsa ve int türü sınırları içerisindeyse int türdendir. Aksi 
	durumda error oluşur
	Örnek: 20, 2000, 2000000000
	
	- Sayı nokta içermiyorsa ve sonuna L (küçük veya büyük) ekini almışsa long türdendir. Sayı long türü sınırları
	dışındaysa error oluşur:
	Örnek: 10L, 20L, 4000000000L
	Anahtar Notlar: Küçük harf L kullanımı karakterin 1(bir) sayısına benzemesinden dolayı programlamada tercih edilmez
	
	- Java'da byte ve short türden sabitler yoktur
	
	- Sayı nokta içeriyorsa ve sonuna hiç bir ek almamışsa double türdendir Sınırlar dışındaysa error oluşur.
	Örnek: 3.4, 4.5, 900.789
	
	- Sayı nokta içersin ya da içermesin sonuna D (küçük veya büyük) ekini alıyorsa double türdendir.
	Örnek: 2D, 34.5D, 56d
	
	- Sayı nokta içersin ya da içermesin sonuna F (küçük veya büyük) ekini alıyorsa float türdendir.
	Örnek: 3.4F, 56f
	
	- boolean türden iki tane sabit vardır: true, false
	
	- char türden sabitler: Tek tırnak içerisinde yazılan karaktere tırnaklar ile birlikte char türden sabit ya da
	karakter sabit (character literal) denir. Tek tırnak içerisine özel durumlar dışında birden fazla karakter 
	yazılamaz. Örneğin: 'ş' sabiti ş karakterinin karakter tablosundaki sıra numarasına karşılık gelir. Bazı karakterlerin
	görüntü karşılı yoktur. 
	
	Tek tırnak içerisine özel durumlar dışında birden fazla karakter yazılamaz. Bu karakterlerin kalvyeden giriş yapılması da
	başka anlamda olduğundan bu karakterlere ilişkin sabitler ters bölü karakteri yanına yazılan karakterle tek tırnak
	içerisinde yazılır. Ters bölü ile yazılabilen karakter sabitlerine "escape sequence" karakterler denir.
	
	Java'daki escape sequence karakter şunlardır:
	'\n' -> Line feed
	'\t' -> horizontal tab
	'\r' -> carriage return
	'\b' -> backspace 
	'\f' -> form feed
	'\0' -> null character
	'\"' -> double quote (optional)
	'\'' -> single quote
	'\\' -> back slash
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	char türden sabitler 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char ch = 'ş';
		
		System.out.printf("ch=%c%n", ch);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak içerisine özel durumlar dışında birden fazla karakter yazılamaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char ch = 'abc'; //error
		
		System.out.printf("ch=%c%n", ch);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Line feed karakter sabiti
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char ch = '\n';
		
		System.out.print("Merhaba");
		System.out.print(ch);
		System.out.print("Nasılsın");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	carriage return karakter sabiti
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char ch = '\r';
		
		System.out.print("Merhaba Nasilsin");
		System.out.print(ch);
		System.out.print("iyi misin?");		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	backspace karakter sabiti
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char ch = '\b';
		
		System.out.print("Merhaba Nasilsin");
		System.out.print(ch);		
		System.out.print("iyi misin?");	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Escape sequence karakterler String atomları içerisinde kendi anlamındadır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("Merhaba\nNasılsın\tiyi misin?");		
			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki tırnak karakterinin karakter sabiti olarak iki şekilde yazılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char ch1 = '"';
		char ch2 = '\"';
		
		System.out.println(ch1);
		System.out.println(ch2);			
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakterinin karakter sabiti ters bölü ile yazılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char ch = '\'';		
		
		System.out.println(ch);					
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakteri String atomu içerisinde iki şekilde de kullanılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("'ankara'");
		System.out.println("\'ankara\'");
		System.out.println("\'ankara'");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki tırnak karakteri String atomu içerisinde ters bölü ile kullanılmalıdır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("\"ankara\"");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü karakterinin karakter sabiti iki tane ters bölü ile yazılmalıdır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		char ch = '\\';
		
		System.out.println(ch);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte escape sequence karakaterlerden dolayı istenilen elde edilemez 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("C:\test\names.txt");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi düzeltilebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("C:\\test\\names.txt");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü karakterinden sonra özel karakterler dışında yazılan kaarkterler error oluşturur 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("C:\music\names.txt"); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi düzeltilebilir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("C:\\music\\names.txt"); 
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki yol bilgisinin String atomu olarak yazımı
	\\192.168.1.123\test\names.txt 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("\\\\192.168.1.123\\test\\names.txt"); 
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü ve u ile bir karakterin sıra numarası hexadecimal  olarak tek tırnak içerisinde yazıldığında 
	o karaktere ilişkin sabit yazılmış olur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		char ch = '\u017C';
		
		System.out.println(ch);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü ve u ile yazılan karakter sabitleri String atomu içerisinde de kullanılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("karakter:\u017C");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü u ile karakter sabiti yazımı değişken isimlerinde de kullanılabilir. Şüphesiz pratik değildir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int \u0061bc = 10;
		
		System.out.println(abc);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	19.12.2020
	Bir tamsayı sabiti herhangi bir önek almazsa decimal türdendir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 67;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("a=%X%n", a);
		System.out.printf("a=%o%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir tamsayı sabitinin önüne bitişik olarak sıfır ve x (büyük veya küçük) yazıldığında bu ekten sonra gelen
	basamaklar hexadecimal basamaklar biçiminde ele alınır 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 0x43;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("a=%X%n", a);
		System.out.printf("a=%o%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir tamsayı sabitinin önüne bitişik olarak sıfır ve x (büyük veya küçük) yazıldığında bu ekten sonra gelen
	basamaklar hexadecimal basamaklar biçiminde ele alınır 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 0xAB;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("a=%X%n", a);
		System.out.printf("a=%o%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir tamsayı sabitinin önüne bitişik olarak sıfır yazıldığında bu ekten sonra gelen basamaklar octal basamaklar 
	biçiminde ele alınır 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 0103;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("a=%X%n", a);
		System.out.printf("a=%o%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir tamsayı sabitinin önüne bitişik olarak sıfır yazıldığında bu ekten sonra gelen basamaklar octal basamaklar 
	biçiminde ele alınır 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 01038; //error
		
		System.out.printf("a=%d%n", a);
		System.out.printf("a=%X%n", a);
		System.out.printf("a=%o%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Tamsayı sabitinin başına sıfır ve b(büyük veya küçük) yazıldığında basamaklara ikilik sistemde yazılmış olur.
	 İkilik sistemde yazılan sabitler Java 7 ile birlikte eklenmiştir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 0b10101111; //Since Java 7
		
		System.out.printf("a=%d%n", a);
		System.out.printf("a=%X%n", a);
		System.out.printf("a=%o%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Gerçek sayı sabitlerinin üstel gösterilişi. Üstel gösterilişle yazılan sabitler sonucu ne olursa olsun
	 double türdendir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		double a = 1.2E+23;
		
		System.out.printf("a=%f%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Gerçek sayı sabitlerinin üstel gösterilişi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		double a = 1.2e23;
		
		System.out.printf("a=%f%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Gerçek sayı sabitlerinin üstel gösterilişi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		double a = 1.2e-23;
		
		System.out.printf("a=%.24f%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Gerçek sayı sabitlerinin üstel gösterilişi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		double avogadro = 6.02E23;
		
		System.out.printf("%f%n", avogadro);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Java 7 ile birlikte sabit içerisinde alttire karakteri kullanılabilmektedir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 0x1F_C0;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("a=0x%X%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Alttire karakteri kullanılabildiği yerde istenildiği kadar yazılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 1____________________________0;				
		
		System.out.printf("a=%d%n", a);		
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	 Alttire karakteri kullanılabildiği yerde istenildiği kadar yazılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 0x01_AB__AA_FF;
		
		System.out.printf("a=%d%n", a);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Alttire karakteri karakter sabitleri içerisinde geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		char ch = '\u02_45'; //error
				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Alttire karakteri sabitin başında ya da sonunda geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 67_; //error
		int b = _67; //error
				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Alttire karakteri sayı nokta içeriyorsa noktadan hemen önce ya da hemen sonra geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double a = 3_.14; //error
		double b = 3._14; //error
				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Alttire karakteri sabit sonundaki eklerden önce ya da sonra kullanılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		long a = 4000000000_L; //error
		long b = 4000000000L_; //error
				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Alttire karakteri sabit önündeki eklerden öncei sonra veya arada kullanılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 0x_1FC0; //error
		int b = _0x1FC0; //error
		int c = 0_x_1FC0; //error
		
				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Octal sabitler için önek ile ilk basamak arasında alttire karakteri kullanılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 0_12;
		
		System.out.printf("a=%d%n", a);				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Gerçek sayı sabitlerinin tamsayı kısmının değeri sıfırsa noktadan önce sıfır yazılmayabilir. Aynı durum 
	 noktadan sonraki kısım sıfır ise de geçerlidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double a = .2; //0.2
		double b = 3.; //3.0
		
		System.out.printf("a=%f%n", a);				
		System.out.printf("b=%f%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte derleyinin "constant folding" optimizasyon davranışından dolayı 1000 * 60 * 60 * 24 * 365 çarpımı
	 olarak arakoda yazılır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		//....
		long scale = 1000 * 60 * 60 * 24 * 365; //arakoda long ms = 94608000; biçiminde yazılır
		
		System.out.printf("scale=%d%n", scale);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Operatörler 3(üç) biçimde sınıflandırılabilir
	 1. İşlevlerine göre sınıflandırma
	 	- Aritmetik operetörler
	 	- Karşılaştırma operatörleri
	 	- Mantıksal operatörler
	 	- Bitsel operatörler
	 	- Özel amaçlı operatörler
	 2. Operand sayılarına göre sınıflandrıma
	 	- Tek operandlı (unary)
	 	- İki operandlı (binary)
	 	- Üç operandlı (ternary)
	 3. Operatörün konumuna göre sınıflandırma
	  - Önek operatörler (prefix)
	  - Araek operatörler (infix)
	  - Sonek operatörler (postfix)
	 
	 Operatörün kısıtı (constraint)
	 Operatörün ürettiği değer (product value)
	 Operatörün yan etkisi (side effect) var mı?
	 Operatörün önceliği (precedence):
	 	a = b + c * d ifadesinin hesaplanması:	 	
	 	i1: c * d
	 	i2: b + i1
	 	i3: a = i2
	 	
	 	a = (b + c) * d ifadesinin hesaplanması:
	 	
	 	i1: b + c
	 	i2: i1 * d
	 	i3: a = i2
	 	
	 	a = b + c - d ifadesinin hesaplanması:
	 	i1: b + c
	 	i2: i1 - d
	 	i3: a = i2
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	Aritmetik dört işlem işlem (bölme hariç) ve mod operatörü
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Bölme işleminde operandlar tamsayı türündense sonuş tamsayı türünden çıkar. Elde sonucun noktadan sonraki
	kısmı atılır. Detaylar ileride ele alınacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());		
		
		System.out.printf("%d / %d = %d%n", a, b, a / b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Mod operatörünün birinci operandı negatif ise sonuç hep negatif çıkar. Pozitifi ise sonuç hep pozitif çıkar
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());		
		
		System.out.printf("%d %% %d = %d%n", a, b, a % b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Mod operatörü Java'da gerçek sayılar ile de kullanılabilmektedir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());	
		
		System.out.printf("%f %% %f = %f%n", a, b, a % b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden 3 basamaklı bir sayının basamakları toplamını döndüren 
	getDigitsSum isimli metodu döngü kullanmadan yazınız. Metot sayının 3 basamaklı olup olmadığını kontrol
	etmeyecektir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		GetDigitsSumTest.run();				
	}
}



class GetDigitsSumTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("3 basamaklı bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d sayısının basamakları toplamı:%d%n", a, NumberUtil.getDigitsSum(a));
	}
}

class NumberUtil {
	public static int getDigitsSum(int val)
	{
		int a, b, c;
		
		a = val / 100;
		b = val / 10 % 10;  //b = val % 100 / 10;
		c = val % 10;
		
		return Math.abs(a + b + c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	İşaret - operatörü
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());		
		int b;		
		
		b = -a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	İşaret + operatörü
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());		
		int b;		
		
		b = +a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a;
		
		a = - - - - - - - - - - -3;
		
		System.out.printf("a=%d%n", a);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a, b = 10, c = 20;
		
		a = b - - - - - - - - c;
		
		System.out.printf("a=%d%n", a);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	++ operatörü hem prefix hem de postfix olarak kullanılabilir. Bu operatör nasıl kullanılırsa kullanılsın 
	operandının değerini bir artırır (increment)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		++a; // a = a + 1;
		
		System.out.printf("a=%d%n", a);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	++ operatörü hem prefix hem de postfix olarak kullanılabilir. Bu operatör nasıl kullanılırsa kullanılsın 
	operandının değerini bir artırır (increment)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		a++; // a = a + 1;
		
		System.out.printf("a=%d%n", a);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	++ operatörünün prefix kullanımında ürettiği değer (işleme giren değer) artırılmış değerdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = ++a;
		
		System.out.printf("a=%d%n", a); //a=11
		System.out.printf("b=%d%n", b); //b=11
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	++ operatörünün postfix kullanımında ürettiği değer (işleme giren değer) artırılMAmış değerdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = a++;
		
		System.out.printf("a=%d%n", a); //a=11
		System.out.printf("b=%d%n", b); //b=10
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	-- operatörü hem prefix hem de postfix olarak kullanılabilir. Bu operatör nasıl kullanılırsa kullanılsın 
	operandının değerini bir azaltır (decrement)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		--a; // a = a - 1;
		
		System.out.printf("a=%d%n", a);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	-- operatörü hem prefix hem de postfix olarak kullanılabilir. Bu operatör nasıl kullanılırsa kullanılsın 
	operandının değerini bir azaltır (decrement)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		a--; // a = a - 1;
		
		System.out.printf("a=%d%n", a);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	-- operatörünün prefix kullanımında ürettiği değer (işleme giren değer) azaltılmış değerdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = --a;
		
		System.out.printf("a=%d%n", a); //a=9
		System.out.printf("b=%d%n", b); //b=9
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	-- operatörünün prefix kullanımında ürettiği değer (işleme giren değer) azaltılMAmış değerdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = a--;
		
		System.out.printf("a=%d%n", a); //a=9
		System.out.printf("b=%d%n", b); //b=10
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	++ ve -- operatörlerinin kullanımı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = --a + ++a;
		
		System.out.printf("a=%d%n", a); //a=10
		System.out.printf("b=%d%n", b); //b=19
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	++ ve -- operatörlerinin kullanımı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = --a + a++;
		
		System.out.printf("a=%d%n", a); //a=10
		System.out.printf("b=%d%n", b); //b=18
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	++ ve -- operatörlerinin kullanımı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = --a + a++ + a--;
		
		System.out.printf("a=%d%n", a); //a=9
		System.out.printf("b=%d%n", b); //b=28
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Derleyici yukarıdan aşağıya ve soldan sağa olmak üzere anlamlı en uzun ifadeyi alacak şekilde atomlarına
	ayırma işlemini yapar
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b = 8;
		int c;
		
		c = a+++b; //c = a++ + b;
		
		System.out.printf("a=%d%n", a); //a=11 	
		System.out.printf("b=%d%n", b); //b=8 	
		System.out.printf("c=%d%n", c); //c=18 	
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	20.12.2020
	Karşılaştırma operatörleri karşılaştırmanın sonucuna göre boolean türden değer üretir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());		
		
		System.out.printf("%d > %d -> %b%n", a, b, a > b);
		System.out.printf("%d < %d -> %b%n", a, b, a < b);
		System.out.printf("%d >= %d -> %b%n", a, b, a >= b);
		System.out.printf("%d <= %d -> %b%n", a, b, a <= b);
		System.out.printf("%d == %d -> %b%n", a, b, a == b);
		System.out.printf("%d != %d -> %b%n", a, b, a != b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Metot çağırma operatörü 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int result;
		
		result = Util.add(10, 20) * 3;
		
		System.out.println(result);
	}
}


class Util {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki ifade metodun geri dönüş değeri int türden olduğundan int türdendir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{				
		Util.add(10, 20);	
	}
}


class Util {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Metodun geri dönüş değeri yok ise bu durumda metot çağrısına ilişkin ifade void bir ifade olarak ele alınır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{				
		Sample.foo(10, 20);	
	}
}


class Sample {
	public static void foo(int a, int b)
	{
		System.out.println(a);
		System.out.println(b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal VE (logical AND) ve Mantıksal VEYA (logical OR) işlemlerinin doğruluk tablosu
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F		
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal VE (&&) operatörü		
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result;
		
		result = Sample.foo() && Sample.bar();
		
		System.out.printf("result=%b%n", result);		
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}


/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal OR (||) operatörü		
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result;
		
		result = Sample.bar() || Sample.foo();
		
		System.out.printf("result=%b%n", result);		
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal OR operatörünün kısa devre davranışı (short circuit behavior)		
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("result=%b%n", result);		
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal AND operatörünün kısa devre davranışı (short circuit behavior)		
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result;
		
		result = Sample.bar() && Sample.foo();
		
		System.out.printf("result=%b%n", result);		
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal AND ve OR operatörleri için doğru sonuca yani matematiksel olarak yapılacak olursa elde edilecek sonuca
 	en kısa yoldan ulaşabilmek için (kısa devre davranışını kullanarak) en soldaki ifade önce yapılır. Aşağıdaki örnekte
 	&& opeatörü || operatöründen daha yüksek önceliğe sahip olsa da || işlemi solda olduğu için önce yapılır. Ancak
 	&& operatörünün önceliği ile elde edilecek sonuç değişmez
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result;
		
		result = Sample.foo() || Sample.bar() && Sample.tar();
		
		System.out.printf("result=%b%n", result);		
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal AND ve OR operatörleri için doğru sonuca yani matematiksel olarak yapılacak olursa elde edilecek sonuca
 	en kısa yoldan ulaşabilmek için (kısa devre davranışını kullanarak) en soldaki ifade önce yapılır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result;
		
		result = Sample.bar() && Sample.foo() || Sample.tar();
		
		System.out.printf("result=%b%n", result);		
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Bitsel AND ve bitsel OR operatörlerinin aslında tamsayılar üzerinde bitsel işlemleri için kullanılır. İstisna
 	olarak boolean türü için kullanıldığında kısa devre devre davranışı olmayan AND ve OR operatörleri biçiminde 
 	düşünülmelidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result;
		
		result = Sample.foo() | Sample.bar() & Sample.tar();
		
		System.out.printf("result=%b%n", result);		
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Bitsel AND ve bitsel OR operatörlerinin tamsayılar ile kullanıldığında karşılıklı bit değerlerini işleme sokarak
 	bir değer elde edildir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10; //1010
		int b = 11; //1011
		int c;
		
		c = a & b;
		
		System.out.printf("c=%d%n", c);
		
		c = a | b;
		
		System.out.printf("c=%d%n", c);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki örneği inceleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a;
		
		a = 10;		
		
		a = a++;
		
		System.out.printf("a=%d%n", a);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal DEĞİL (Logical not) işleminin doğruluk tablosu 	
 	op			!op
 	T			F
 	F			T
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
 	Mantıksal DEĞİL operatörü flag değişkenlerde aşağıdaki gibi kullanılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean flag = true;
		
		//...
		
		flag = !flag;
		
		System.out.println(flag);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Atama operatörü sağdan sola (right associative) önceliklidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a, b, c;
		
		a = b = c = 10;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("b=%d%n", b);
		System.out.printf("c=%d%n", c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki örnekte atama operatörünün birinci operandının değişken olmamasından dolayı error oluşur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a, b = 23, c;
		
		(a = b) = c = 10; //error
		
		System.out.printf("a=%d%n", a);
		System.out.printf("b=%d%n", b);
		System.out.printf("c=%d%n", c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	İşlemli atama operatörünün genel biçimi:
 	<ifade1> <op>= <ifade2> ifadesinin yaklaşık eşdeğeri
 	<ifade1> = <ifade1> op <ifade2> 	
 	 	a += b -> a = a + b
 	 	a *= b -> a = a * b
 	 Anahtar Notlar: Aslında işlemli atama operatörlerinin genel biçimi tam olarak yukarıdaki gibi değildir. Asıl 
 	 genel biçimi ileride ele alınacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10, b = 30;
		
		a += b;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("b=%d%n", b);		
	}
}


/*--------------------------------------------------------------------------------------------------------------------
 	İşlemli atama operatörleri ifadeleri daha basit yazmak için tercih edilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10, b = 30, c = 3;
		
		a *= b + c; //a = a * (b + c);
		
		System.out.printf("a=%d%n", a);
		System.out.printf("b=%d%n", b);		
		System.out.printf("c=%d%n", c);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
 	Java'da genel olarak etkisiz ifadeler geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		a + 3; //error: etkisiz ifade
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki örnekte error oluşmaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{
		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Deyimler (statements): Bir programın çalıştırılan parçalarına deyim denit. Bir program deyimlerin çalıştırılmasıyla
 	çalışır
 	Java' da deyimler 5(beş) gruba ayrılır:
 	1. Basit deyimler (simple statements) 
 	2. Bileşik deyimler (compound statements)
 	3. Bildirim deyimleri (declaration statements)
 	4. Kontrol deyimleri (control statements)
 	5. Boş deyim (null statement)
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
 	Basit deyim
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10, b;
		
		b = a + 3; //basit deyim
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Bileşik deyim
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10, b;
		
		{ //bileşik deyim
			++a;
			b = a;
			
			//...
			{
				//...
			}
		}
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	Boş deyim
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a;;;;;;;;;;;
		
		
		
		;;;;;;
		
		;
		
		
		;
		
		
	}
}


/*--------------------------------------------------------------------------------------------------------------------
 	if deyiminin genel biçimi:
 	if (<boolean türden ifade>)
 		<deyim>
 	[else
 		<deyim>
 	]
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	if deyiminde bileşik deyim kullanımı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0) {
			System.out.println("Çift sayı girdiniz");
			System.out.println("Teşekkür ederiz");
		}
		else
			System.out.println("Tek sayı girdiniz");
			
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	if deyiminde bileşik deyim kullanımı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0) {
			System.out.println("Çift sayı girdiniz");
			System.out.println("Teşekkür ederiz");
		}
		else 
			System.out.println("Tek sayı girdiniz");		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	else kısmı olmayan if deyimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0)
			val /= 2;
		
		System.out.printf("val=%d%n", val);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	if deyiminin parantezi sonuna yanlışlıkla noktalı virgül (boş deyim) konması durumu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0);
			val /= 2;
		
		System.out.printf("val=%d%n", val);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte else hiç bir if deyimine ait olmadığından error oluşur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0); 
			val /= 2;
		else //error
			val *= 2;			
		
		System.out.printf("val=%d%n", val);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte else kısmı içteki if deyimine aittir (dangling else)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val > 0)
			if (val % 2 == 0)
				System.out.println("Pozitif ve çift sayı girdiniz");
		else
			System.out.println("Pozitif sayı girmelisiniz");
		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Yukarıdaki "dangling else" durumu bileşik deyim ile düzeltilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val > 0) {
			if (val % 2 == 0)
				System.out.println("Pozitif ve çift sayı girdiniz");
		}
		else
			System.out.println("Pozitif sayı girmelisiniz");
		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içteki if deyiminin de else kısmı olduğundan bileşik deyim yazılmayabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val > 0)
			if (val % 2 == 0)
				System.out.println("Pozitif ve çift sayı girdiniz");
			else
				System.out.println("Pozitif ve tek sayı girdiniz");		
		else
			System.out.println("Pozitif sayı girmelisiniz");		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	if deyiminin parantezinde boolean türden ifadeler için == veya != operatörleri kullanılması iyi bir teknik değildir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		Util.displayEvenStatusByFlag(val % 2 == 0);		
	}
}


class Util {
	public static void displayEvenStatusByFlag(boolean flag)
	{
		if (flag) //if (flag == true)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte == veya != operatörleri yerine mantıksal değil (!) operatörün kullanıldığına dikkat ediniz 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		Util.displayEvenStatusByFlag(val % 2 == 0);		
	}
}


class Util {
	public static void displayEvenStatusByFlag(boolean flag)
	{
		if (!flag) //if (flag == false)
			System.out.println("Tek sayı girdiniz");
		else
			System.out.println("Çift sayı girdiniz");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki isEven metodunda else kullanımıma gerek yoktur. Çünkü return deyimi metodu sonlandırır. Dolsyısıyla
	akış return deyiminden sonrasına zaten erişemez 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		Util.displayEvenStatusByFlag(NumberUtil.isEven(val));		
	}
}


class NumberUtil {
	public static boolean isEven(int val)
	{
		if (val % 2 == 0)
			return true;
		else		
			return false;
	}
}

class Util {
	public static void displayEvenStatusByFlag(boolean flag)
	{
		if (flag)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Yukarıdaki isEven metodunun düzeltilmiş ancak yine de tam profesyonel olmayan versiyonu  
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		Util.displayEvenStatusByFlag(NumberUtil.isEven(val));		
	}
}


class NumberUtil {
	public static boolean isEven(int val)
	{
		if (val % 2 == 0)
			return true;
				
		return false;
	}
}

class Util {
	public static void displayEvenStatusByFlag(boolean flag)
	{
		if (flag)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	isEven metodunun en okunabilir yazılış şekli aşağıdaki gibidir  
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		Util.displayEvenStatusByFlag(NumberUtil.isEven(val));		
	}
}


class NumberUtil {
	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}
}

class Util {
	public static void displayEvenStatusByFlag(boolean flag)
	{
		if (flag)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	  Aşağıdaki örnekte kod tekrarı yapılmadığına yani iş yapan başka bir metodun çağrıldığına dikkat ediniz.
	  Yazılım geliştirmede kod tekrarı yapmamaya "DO NOT REPEAT YOURSELF" cümlesi kullanılır. Zorunlu olmadıkça
	  programı kod tekrarı yapmamalıdır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		Util.displayEvenStatusByFlag(NumberUtil.isEven(val));		
		Util.displayOddStatusByFlag(NumberUtil.isOdd(val));
	}
}

class NumberUtil {
	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}
	
	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}
}

class Util {
	public static void displayEvenStatusByFlag(boolean flag)
	{
		if (flag)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
	
	public static void displayOddStatusByFlag(boolean flag)
	{
		displayEvenStatusByFlag(!flag);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	  26.12.2020
	  Aşağıdaki örnekte * ile belirtilen if deyimi else kısmı ile birlikte tektir. Bu if deyiminin else kısmında başka
	  bir if deyimi vardır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val > 0) //*
			System.out.println("Pozitif");
		else 
			if (val == 0)
				System.out.println("Sıfır");
			else
				System.out.println("Negatif");
				
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	  Yukarıdaki örnek daha okunabilir olarak aşağıdaki şekilde yazılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val > 0)
			System.out.println("Pozitif");
		else if (val == 0)
			System.out.println("Sıfır");
		else
			System.out.println("Negatif");
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	  Aşağıdaki koşullar ayrık koşullardır. Bu durumda doğru çalışsa da aşağıdaki gibi yazılmamalıdır. else-if
	  biçiminde yazmak daha uygundur (Yukarıda yazıldığı gibi)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val > 0)
			System.out.println("Pozitif");
		if (val == 0)
			System.out.println("Sıfır");
		if (val < 0)
			System.out.println("Negatif");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	  Aşağıdaki koşullar ayrık olmadığından örnek bazında else-if yapılması zaten yanlış olur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val > 11)
			System.out.println("val > 11");
		if (val > 13)
			System.out.println("val > 13");
		if (val > 30)
			System.out.println("val > 30");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	  Sınıf Çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerini bulup ekrana
	  yazdıran programı yazınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		EquationSolverApp.run();
	}
}

class EquationSolverApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a?");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b?");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c?");
		double c = Double.parseDouble(kb.nextLine());
		
		EquationSolver.findRoots(a, b, c);
	}
}

class EquationSolver {	
	public static void findRoots(double a, double b, double c)
	{
		double delta = getDelta(a, b, c);
		
		if (delta > 0) {
			double x1, x2;
			double sqrtDelta = Math.sqrt(delta);
			
			x1 = (-b + sqrtDelta) / (2 * a);
			x2 = (-b - sqrtDelta) / (2 * a);
			
			System.out.printf("x1 = %f, x2 = %f%n", x1, x2);
		}	
		else if (delta == 0) {
			double x = -b / (2 * a);
			
			System.out.printf("x1 = x2 = %f%n", x);
		}
		else
			System.out.println("Gerçek kök yok");
	}	
	
	
	public static double getDelta(double a, double b, double c)
	{
		return b * b - 4 * a * c;
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	  Sınıf Çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerini bulup ekrana
	  yazdıran programı yazınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		EquationSolverApp.run();
	}
}

class EquationSolverApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a?");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b?");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c?");
		double c = Double.parseDouble(kb.nextLine());
		
		EquationSolver.findRoots(a, b, c);
	}
}

class EquationSolver {	
	public static void findRoots(double a, double b, double c)
	{
		double delta = getDelta(a, b, c);
		
		if (delta >= 0) {
			double x1, x2;
			double sqrtDelta = Math.sqrt(delta);
			
			x1 = (-b + sqrtDelta) / (2 * a);
			x2 = (-b - sqrtDelta) / (2 * a);
			
			System.out.printf("x1 = %f, x2 = %f%n", x1, x2);
		}
		else
			System.out.println("Gerçek kök yok");
	}	
	
	
	public static double getDelta(double a, double b, double c)
	{
		return b * b - 4 * a * c;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Döngü(loop) deyimleri:
	1. while döngü deyimleri
		- Kontrolün başta yapıldığı while döngü deyimi (while döngüsü)
		- Kontrolün sonda yapıldığı while döngü deyimi (do-while döngüsü)
	2. for döngü deyimi	
	3. for-each döngü deyimi (enhanced for loop, range based loop)
	
	Anahtar Notlar: Aşağıdaki örneklerde "while döngü deyimi" ya da "while döngüsü" dendiğinde "kontrolün başta 
	yapıldığı while döngü deyimi" anlaşılmalıdır
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	Kontrolün başta yapıldığı while döngü deyiminin genel biçimi:
	
	while (<koşul ifadesi>)
		<deyim>
		
	Koşul ifadesi boolean türden olmalıdır. Bu döngü koşul ifadesinin true olduğu sürece yinelenir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}	
		System.out.printf("%nDöngü sonrası:i = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	while döngü deyiminde yanlışlıkla noktalı virgül konması durumu 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n); {
			System.out.printf("%d ", i);
			++i;
		}	
		System.out.printf("%nDöngü sonrası:i = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	while döngü deyimi ile n-kez dönen döngü kalıbı (dizi uyumlu)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.println("\nTekrar yapıyor musunuz?");
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	while döngü deyimi ile n-kez dönen döngü kalıbı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 1;
		
		while (i <= n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.println("\nTekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	while döngü deyimi ile n-kez dönen döngü kalıbı (dizi uyumlu)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = n - 1;
		
		while (i >= 0) {
			System.out.printf("%d ", i);
			--i;
		}
		
		System.out.println("\nTekrar yapıyor musunuz?");
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	while döngü deyimi ile n-kez dönen döngü kalıbı
	
	n = 4 olsun
	Döngünün içindeyken basılacak n değerleri:3, 2, 1, 0
	Sayaç:1 -> 2 -> 3 -> 4
	Döngü sonunda n değeri:-1
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		while (n-- > 0)
			System.out.printf("n = %d%n", n);		
		
		System.out.printf("Döngü sonrası: n = %d%n", n);		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değeri atanıp atanan değerin 
	kontrolüne ilişkin algortimalar yazılabilmektedir. Okunabilirliği etkilemediği sürece aşağıdaki gibi bir 
	kod yazılabilir. Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur.
	while döngüsünün parantezi içerisinde atama işleminin öncelik paranetezine alındığına dikkat ediniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız:");
		
		int sum = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0)
			sum += val;		
		
		System.out.printf("Toplam:%d%n", sum);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayıların pozitif ve negatif olanlarının ayrı ayrı 
	toplamını bulan programı yazınız. Programda hiç negatif veya pozitif girilmemişse uygun mesajlar
	verilecektir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		FindPosNegCountApp.run();				
	}
}

class FindPosNegCountApp {
	public static void displayResult(int posSum, int negSum)
	{
		if (posSum > 0)
			System.out.printf("Girilen pozitif sayıların toplamı:%d%n", posSum);
		else
			System.out.println("Hiç pozitif sayı girilmedi");
		
		if (negSum < 0)
			System.out.printf("Girilen negatif sayıların toplamı:%d%n", negSum);
		else
			System.out.println("Hiç negatif sayı girilmedi");
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız:");
		
		int posSum = 0, negSum = 0;		
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0)
			if (val > 0)
				posSum += val;
			else
				negSum += val;
		
		displayResult(posSum, negSum);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits metodunu
	NumberUtil isimli bir sınıf içerisinde yazınız ve klavyeden girilen değerlerle çağırarak test ediniz	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		CountDigitsTest.run();				
	}
}


class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			int count = NumberUtil.countDigits(val);
			
			System.out.printf("%d sayısının basamak sayısı:%d%n", val, count);
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamak sayısı:%d%n", NumberUtil.countDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static int countDigits(int val)
	{
		if (val == 0)
			return 1;
		
		int count = 0;
		
		while (val != 0) {
			++count;
			val /= 10;			
		}
		
		return count;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak toplamını döndüren sumDigits metodunu
	NumberUtil isimli bir sınıf içerisinde yazınız ve klavyeden girilen değerlerle çağırarak test ediniz. Metot 
	negatif için de basamakları toplamını pozitif olarak döndürecektir	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		SumDigitsTest.run();				
	}
}

class SumDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			int sum = NumberUtil.sumDigits(val);
			
			System.out.printf("%d sayısının basamakları toplamı:%d%n", val, sum);
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamakları toplamı:%d%n", NumberUtil.sumDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static int sumDigits(int val)
	{		
		int sum = 0;
		val = Math.abs(val);
		
		while (val != 0) {
			sum += val % 10;
			val /= 10;			
		}
		
		return sum;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak toplamını döndüren sumDigits metodunu
	NumberUtil isimli bir sınıf içerisinde yazınız ve klavyeden girilen değerlerle çağırarak test ediniz. Metot 
	negatif için de basamakları toplamını pozitif olarak döndürecektir	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		SumDigitsTest.run();				
	}
}

class SumDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			int sum = NumberUtil.sumDigits(val);
			
			System.out.printf("%d sayısının basamakları toplamı:%d%n", val, sum);
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamakları toplamı:%d%n", NumberUtil.sumDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static int sumDigits(int val)
	{		
		int sum = 0;		
		
		while (val != 0) {
			sum += val % 10;
			val /= 10;			
		}
		
		return Math.abs(sum);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının tersini döndüren reversed isimli metodu
	yazınız ve test ediniz.
	
	123 -> 3 -> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		ReversedTest.run();				
	}
}

class ReversedTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			int reverse = NumberUtil.reversed(val);
			
			System.out.printf("%d sayısının tersi:%d%n", val, reverse);
			System.out.print("Bir sayı giriniz:");
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static int reversed(int val)
	{		
		int reverse = 0;		
		
		while (val != 0) {
			reverse = reverse * 10 + val % 10;
			val /= 10;
		}
		
		return reverse;
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının palindrome olup olmadığını test eden isPalindrome
	isimli metodu yazınız ve test ediniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		IsPalindromeTest.run();				
	}
}

class IsPalindromeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			if (NumberUtil.isPalindrome(val))
				System.out.printf("%d palindromik bir sayıdır%n", val);
			else
				System.out.printf("%d palindromik bir sayı değildir%n", val);
			
			System.out.print("Bir sayı giriniz:");
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static boolean isPalindrome(int val)
	{
		return reversed(val) == val;
	}
	
	public static int reversed(int val)
	{		
		int reverse = 0;		
		
		while (val != 0) {
			reverse = reverse * 10 + val % 10;
			val /= 10;
		}
		
		return reverse;
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Kontrolün sonda yapıldığı while döngü deyimi (do-while döngü deyimi):
	do 
		<deyim>
	while (<boolean türden ifade>);
	
	Bu döngü deyiminde akış döngüye geldiğinde kontrol yapılmaz. İlk adımdan sonra kontrol yapılmaya başlanır. Yani
	bu döngü deyiminin en az bir kez çalıştırılacağı garanti altındadır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		do {
			System.out.printf("%d ", i);
			++i;
		} while (i < n);
		
		System.out.printf("%nDöngü sonrası:i = %d%n", i);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits metodunu
	NumberUtil isimli bir sınıf içerisinde yazınız ve klavyeden girilen değerlerle çağırarak test ediniz	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		CountDigitsTest.run();				
	}
}


class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			int count = NumberUtil.countDigits(val);
			
			System.out.printf("%d sayısının basamak sayısı:%d%n", val, count);
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamak sayısı:%d%n", NumberUtil.countDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static int countDigits(int val)
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
		} while (val != 0);		
		
		return count;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	do-while döngüsünün deyimi içerisinde bildirilen değişken yerel değişkenleri faaliyet alanı kuralları gereği koşul
	ifadesi	içerisinde kullanılamaz  	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		do {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d\n", val, val, val * val);
		} while (val != 0); //error
		
		System.out.println();
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi yapılabilir  	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int val;
		do {
			System.out.print("Bir sayı giriniz:");
			val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d\n", val, val, val * val);
		} while (val != 0);
		
		System.out.println();
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	27.12.2020
	Sonsuz Döngü: Koşul ifadesinden dolayı sonlanmayan döngülere denir. Bu durumda hiç sonlanmayan döngüler de 
	sonsuz döngülerdir. Tersine sonsuz döngüler de sonlanabilir.   	 
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	 while döngü deyimi ile sonsuz döngü aşağıdaki gibi oluşturulabilir   	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		while (true) {
			//...
		}
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	 Aşağıdaki örnekte sonsuz döngü oluşturulmuş, döngü içerisinde bir koşul geçekleştiğinde return deyimi 
 	 kullanıldığı için döngü de sonlanmıştır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample.displaySquare();
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Sample {
	public static void displaySquare()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			if (val == 0)
				return;
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		}
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin genel biçimi:
	for ([1.kısım]; [2.kısım]; [3.kısım]) 
		<deyim>
	
	1.kısım: Akış for döngü deyimine ilk kez geldiğinde bir kez yapılacak kısımdır
	
	2.kısım: for döngü deyiminin koşul ifadesidir. Bu ifadenin boolean türden olması gerekir. Bu ifade doğru olduğu
	sürece döngü yinelenir. Akış for döngü deyimine geldiğinde 1.kısım yapıldıktan koşul kontrolü yapılır
	 
	3.kısım: Döngünün bir adımı tamamlandığında bir sonraki adıma geçmek için yapacağı kontrolden hemen önce 
	çalıştırılacak kısım
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int i;
		
		for (i = 0; i < 10; ++i)
			System.out.printf("i = %d%n", i);
		
		System.out.printf("Döngü sonrası -> i = %d%n", i);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int i;
		
		for (i = 0; i < 10; i += 2)
			System.out.printf("i = %d%n", i);
		
		System.out.printf("Döngü sonrası -> i = %d%n", i);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin birinci kısmında değişken bildirimi yapılabilir. Bu değişken(ler)e döngü değişkeni denir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		
		for (int i = 0; i < 10; i += 2)
			System.out.printf("i = %d%n", i);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin birinci kısmında değişken for döngü deyimi boyunca kullanılabilir (görülebilirdir)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		
		for (int i = 0; i < 10; i += 2)
			System.out.printf("i = %d%n", i);
		
		System.out.printf("Döngü sonrası -> i = %d%n", i); //error
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durum "aynı faaliyet içerisinde aynı isimde yerel değişken bildirimi geçersizdir" kuralı gereği
	error oluşturur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int i;		
		
		for (int i = 0; i < 10; i += 2) //error
			System.out.printf("i = %d%n", i);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durum geçerlidir. Döngü değişkenin değeri döngüden sonra kullanılmayacaksa döngü değişkenin bildiriminin
	for döngüsünde yapılması daha iyi bir tekniktir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 0; i < 10; i += 2)
			System.out.printf("i = %d%n", i);
		
		//...
		
		System.out.println("////////////////");
		
		for (int i = 0; i < 10; i += 2)
			System.out.printf("i = %d%n", i);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int i;
		
		for (i = 0; i < 10; i += 2)
			System.out.printf("i = %d%n", i);
		
		System.out.printf("Döngü sonrası:i=%d%n", i);
		
		System.out.println("////////////////");
		
		for (i = 0; i < 10; i += 2)
			System.out.printf("i = %d%n", i);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi sonunda yanlışlıkla noktalı virgül konması durumu: Aşağıdaki örnekte error oluşur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 0; i < 10; ++i);
			System.out.printf("i = %d%n", i); //error		
		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi sonunda yanlışlıkla noktalı virgül konması durumu: Aşağıdaki örnekte error oluşmaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; ++i);
			System.out.println("Merhaba");	
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi n-kez dönen döngü kalıbı (dizi uyumlu)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; ++i)
			System.out.println("Merhaba");	
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi n-kez dönen döngü kalıbı (dizi uyumlu)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = n - 1; i >= 0; --i)
			System.out.println("Merhaba");	
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi n-kez dönen döngü kalıbı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 1; i <= n; ++i)
			System.out.println("Merhaba");	
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin birinci kısmında ve üçüncü kısmında virgül ayracı ile birden fazla ifade yapılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 1, k = 10; i <= 5 && k >= 0; ++i, --k)
			System.out.printf("(%d, %d)%n", i, k);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin birinci kısmında ve üçüncü kısmında virgül ayracı ile birden fazla ifade yapılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int i = 0;
		
		for (System.out.println("Birinci kısım"); i < 5; System.out.println("Üçüncü kısım"), ++i)
			System.out.println("Döngü deyimi");			
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin birinci kısmında birden fazla değişken bildirimi yapıalcaksa bunlar farklı türlerden olamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 1, double k = 10; i <= 5 && k >= 0; ++i, --k) //error
			System.out.printf("(%d, %d)%n", i, k);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin birinci kısmında bildirim yapılmışsa başka bir ifade yazılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (System.out.printf("Birinci kısım"), int i = 1, k = 10; i <= 5 && k >= 0; ++i, --k) //error
			System.out.printf("(%d, %d)%n", i, k);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin gücü: Aşağıdaki örnekte klavyeden sıfırı girilene kadar alınan sayıların toplamı
	bulunmuştur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int sum = 0;
		int val;
		
		for (System.out.println("Sayıları girmeye başlayınız"), System.out.print("Bir sayı giriniz:");
				(val = Integer.parseInt(kb.nextLine())) != 0; sum += val, System.out.println("Bir sayı giriniz"))
			;
		
		System.out.printf("Toplam:%d%n", sum);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin birinci kısmının boş bırakılması durumu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int i = 0;
		
		for (; i < 10; ++i)
			System.out.printf("i = %d%n", i);
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin üçüncü kısmının boş bırakılması durumu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 0; i < 10;) {
			System.out.printf("i = %d%n", i);
			++i;
		}
		//...
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin birinci ve üçüncü kısmının boş bırakılması durumu while döngü deyimine benzetilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int i = 0;
		
		for (; i < 10;) { //while (i < 10) {
			System.out.printf("i = %d%n", i);
			++i;
		}
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin ikinci kısmının boş bırakılması durumu sonsuz döngü oluşturmak demektir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 0; ; ++i) {
			System.out.printf("i = %d%n", i);
			//...
		}
		//...
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi ile sonsuz döngü kalıbı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (;;) {
			//...
		}
		//...
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	for döngü deyimi ile sonsuz döngü oluşturulmak istenirse okunabilirlik açısından üç kısmın da boş bırakılması
	tavsiye edilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int i = 0;
		
		for (;;) {			
			System.out.printf("i = %d%n", i);
			++i;
			//...
		}
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden a ve b değerleri için a'nın b-inci kuvvetini döndüren
	pow isimli metodu yazınız.
	Açıklamalar:
	- Math sınıfının pow metodu kullanılmayacaktır
	- Metot b'nin negatif değerleri için 1 değerini döndürecektir
	- Metot NumberUtil sınıfı içerisinde yazılacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PowTest.run();
	}
}

class PowTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci sayıyı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			if (a == 0)
				return;
			
			System.out.print("İkinci sayıyı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d)=%d%n", a, b, NumberUtil.pow(a, b));
		}
	}
}


class NumberUtil {
	public static int pow(int a, int b)
	{
		if (b <= 0)
			return 1;
		
		int result = 1;
		
		while (b-- > 0)
			result *= a;
		
		return result;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden a ve b değerleri için a'nın b-inci kuvvetini döndüren
	pow isimli metodu yazınız.
	Açıklamalar:
	- Math sınıfının pow metodu kullanılmayacaktır
	- Metot b'nin negatif değerleri için 1 değerini döndürecektir
	- Metot NumberUtil sınıfı içerisinde yazılacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PowTest.run();
	}
}

class PowTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci sayıyı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			if (a == 0)
				return;
			
			System.out.print("İkinci sayıyı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d)=%d%n", a, b, NumberUtil.pow(a, b));
		}
	}
}


class NumberUtil {
	public static int pow(int a, int b)
	{
		int result = 1;
		
		for (int i = 0; i < b; ++i)
			result *= a;
		
		return result;
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Hiç sonlanamayacak sanılan ancak sonlanan bir döngü deyimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int i;
		
		for (i = 0; i < 5; --i)
			; //System.out.printf("i = %d%n", i);
		
		System.out.printf("Döngü sonrası i = %d%n", i);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong
	metodunu NumberUtil sınıfı içerisinde yazınız ve test ediniz. 
	
	Açıklamalar:
	- Kuvvet alma işlemi için Math sınıfının pow metodunu kullanmayınız
	
	- Bir sayının her basamağının basamak sayıncı kuvvetleri alınıp toplandığında sonuç sayının kendisine eşitse, bu 
	sayı bir Armstrong sayısıdır
	Örneğin: 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153
	
	- Sayı negatif ise false döndürebilirsiniz
	
	- Test işlemini 1, 2, 3, 4, 5, 6 ve 7 basamaklı Armstrong sayılarını ekrana yazdırarak yapabilirsiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}


class IsArmstrongTest {
	public static void run()
	{
		for (int n = -100; n <= 9999999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {
	public static boolean isArmstrong(int val)
	{
		if (val < 0)
			return false;
		
		return getDigitstPowSum(val) == val;	
	}
	
	public static int getDigitstPowSum(int val)
	{
		int n = countDigits(val);		
		int sum = 0;
		
		while (val != 0) {
			sum += pow(val % 10, n);
			val /= 10;
		}
		
		return sum;				
	}
	
	public static int countDigits(int val)
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
		} while (val != 0);
		
		return count;
	}
	
	public static int pow(int a, int b)
	{
		int result = 1;
		
		for (int i = 0; i < b; ++i)
			result *= a;
		
		return result;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayının asal olup olmadığını test eden isPrime metodunu yazınız
	ve test ediniz
	(Yavaş versiyon) 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int n = 0; n <= 100; ++n)
			if (NumberUtil.isPrime(n))
				System.out.printf("%d ", n);	
				
		System.out.println();
		System.out.println(NumberUtil.isPrime(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(int val)
	{
		if (val <= 1)
			return false;
		
		int halfVal = val / 2;
		
		for (int i = 2; i <= halfVal; ++i)
			if (val % i == 0)
				return false;
		
		return true;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayının asal olup olmadığını test eden isPrime metodunu yazınız
	ve test ediniz
 	Teorem: Bir sayı karakökünden daha küçük olan asal sayıların hiç birisine bölünemiyorsa asaldır
 	(Çok daha hızlı versiyon)	
 	İleride göreceli biraz daha iyi versiyonu yazılacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int n = 0; n <= 100; ++n)
			if (NumberUtil.isPrime(n))
				System.out.printf("%d ", n);	
				
		System.out.println();
		System.out.println(NumberUtil.isPrime(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(int val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
		
		for (int i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;
		
		return true;
		
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Yukarıda yazılan isPrime metotlarının basit bir karşılaştırması	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{		
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(int val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
		
		int count = 0;
		
		for (int i = 11; i * i <= val; i += 2) {
			++count;
			if (val % i == 0)
				return false;
		}
		
		System.out.printf("IsPrime->count:%d%n", count);
		
		return true;
		
	}
	
	public static boolean isPrimeSlow(int val)
	{
		if (val <= 1)
			return false;
		
		int halfVal = val / 2;
		
		int count = 0;
		
		for (int i = 2; i <= halfVal; ++i) {
			++count;
			if (val % i == 0)
				return false;
		}
		
		System.out.printf("IsPrimeSlow->count:%d%n", count);
		return true;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Yukarıda yazılan isPrime metotlarının basit bir karşılaştırması	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{		
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(int val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
		
		int count = 0;
		
		for (int i = 11; i * i <= val; i += 2) {
			++count;
			if (val % i == 0)
				return false;
		}
		
		System.out.printf("IsPrime->count:%d%n", count);
		
		return true;
		
	}
	
	public static boolean isPrimeSlow(int val)
	{
		if (val <= 1)
			return false;
		
		int halfVal = val / 2;
		
		int count = 0;
		
		for (int i = 2; i <= halfVal; ++i) {
			++count;
			if (val % i == 0)
				return false;
		}
		
		System.out.printf("IsPrimeSlow->count:%d%n", count);
		return true;
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime
	isimli metodu yazınız ve test ediniz:
	Açıklamalar:
	- isPrime metosunu kullanınız
	- isPrime metodunun hızlı olan versiyonunu kullandığınız bilinciyle yazınız
	- Metot n-nin pozitif olmayan değerleri için -1 sayını döndürecektir
	- Metodu klavyeden alınan değerlerle çağırarak test ediniz 	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();
	}
}

class GetPrimeTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				return;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.getPrime(n));
		}
		
	}
}

class NumberUtil {
	public static int getPrime(int n)
	{
		if (n <= 0)
			return -1;
		
		int count = 0;
		int val = 2;
		
		for (int i = 2; count < n; ++i) {
			if (isPrime(i)) {
				++count;
				val = i;
			}
		}
		
		return val;
	}
	
	public static boolean isPrime(int val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		
		for (int i = 11; i * i <= val; i += 2)			
			if (val % i == 0)
				return false;		
		
		return true;
		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime
	isimli metodu yazınız ve test ediniz:
	Açıklamalar:
	- isPrime metodunu kullanınız
	- isPrime metodunun hızlı olan versiyonunu kullandığınız bilinciyle yazınız
	- Metot n-nin pozitif olmayan değerleri için -1 sayını döndürecektir
	- Metodu klavyeden alınan değerlerle çağırarak test ediniz 	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();
	}
}

class GetPrimeTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				return;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.getPrime(n));
		}
		
	}
}

class NumberUtil {
	public static int getPrime(int n)
	{
		if (n <= 0)
			return -1;
		
		int count = 0;
		int val = 2;		
		
		for (;;) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}		
	}
	
	public static boolean isPrime(int val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;	
		
		for (int i = 11; i * i <= val; i += 2)			
			if (val % i == 0)
				return false;		
		
		return true;
		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	02.01.2021
	Sınıf Çalışması: Parametresi ile aldığı n sayısı için n-inci Fibonacci sayısını döndüren getFibonacciNumber isimli
	metodu yazını ve test ediniz.
	Açıklama:
	- Fibonacci sayıları:
		0 1 1 2 3 5 8 13 21 34 ...
	- Metot n'nin 1'den küçük değerleri için -1 değerine dönecektir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetFibonacciTest.run();
	}
}

class GetFibonacciTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				return;
			
			System.out.printf("%d. Fibonnacci sayısı:%d%n", n, NumberUtil.getFibonacciNumber(n));
		}
		
	}
}

class NumberUtil {
	public static int getFibonacciNumber(int n)
	{
		if (n <= 0)
			return -1;
		
		if (n <= 2)
			return n - 1;
		
		int prev1 = 1, prev2 = 0, val = 0;
		
		for (int i = 2; i < n; ++i) {
			val = prev1 + prev2;
			prev2 = prev1;
			prev1 = val;
		}
		
		return val;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	İçiçe döngüler
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int i = 0; i < 5; ++i)
			for (int k = 6; k >= 0; --k)
				System.out.printf("{i: %d, k : %d}%n", i, k);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Programcı bazen tek bir döngü yazsa da döngü içerisinde çağrılan metotlar içerisinde de döngü kullanılmışsa 
	içiçe döngü olacak şekilde kod yazmış olur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int i = 0; i < 5; ++i)
			Sample.foo(i);
	}
}

class Sample {
	public static void foo(int i)
	{
		for (int k = 6; k >= 0; --k)
			System.out.printf("{i: %d, k : %d}%n", i, k);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	3 basamaklı Armstrong sayılarının içiçe döngü kullanarak bulunması
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int a = 1; a <= 9; ++a)
			for (int b = 0; b <= 9; ++b)
				for (int c = 0; c <= 9; ++c)
					if (a * a * a + b * b * b + c * c * c == 100 * a + 10 * b + c)
						System.out.printf("%d%d%d%n", a, b, c);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	break deyiminin genel biçimi:
	break [etiket ismi];
	break deyimi dendiğinde ilk akla gelen etiketsiz kullanımdır. Etiketli kullanıma "labeled break" denir. break
	deyimi ilgili döngüyü sonlandrırmak (kırmak) için kullanılır 
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	 break deyiminin etiketsiz kullanımında akış break deyimine geldiğinden döngü sonlandırılır. Döngüden sonraki
	 koddan devam edilir. break hangi döngü içerisinde etiketsiz kullanılmışsa o döngü sonlandırılır. Aşağıdaki
	 örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmaktadır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız:");
		
		int sum = 0;
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			if (val == 0)
				break;
			
			sum += val;
		}
		
		System.out.printf("Toplam:%d%n", sum);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden sayıdan büyük ilk Fibonacci sayısını döndüren getNextFibonacciNumber
	metodunu yazınız ve test ediniz
	
	0 1 1 2 3 5 8 13 21 34 ...
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetNextFibonacciTest.run();
	}
}

class GetNextFibonacciTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			if (val <= -999)
				break;
			
			System.out.printf("%d sayısından sonraki ilk Fibonnacci sayısı:%d%n", val, NumberUtil.getNextFibonacciNumber(val));
		}			
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;
		
		int prev1 = 1, prev2 = 0, result;
		
		for (;;) {
			result = prev1 + prev2;
			
			if (result > val)
				return result;
			
			prev2 = prev1;
			prev1 = result;
		}
	}	
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içteki döngüde bir koşul gerçekleştiğinde dıştaki döngü sondırılmaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		boolean flag = false;
		
		for (int i = 3; i < 10; ++i) {
			for (int k = 5; k >= 0; --k) {
				System.out.printf("{i : %d, k : %d}%n", i, k);
				if ((i + k) % 11 == 0) {
					flag = true;
					break;
				}
			}
			
			if (flag)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek etiketli break deyimi ile daha okunabilir ve kolay bir biçimde yazılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		EXIT_LOOP:
		for (int i = 3; i < 10; ++i) {
			for (int k = 5; k >= 0; --k) {
				System.out.printf("{i : %d, k : %d}%n", i, k);
				if ((i + k) % 11 == 0)
					break EXIT_LOOP;
			}			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Etiketli break deyiminin kullanımı
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		EXIT_LOOP:
		for (int i = 3; i < 10; ++i) {
			EXIT_INNER_LOOP:
			for (int j = 0; j < 100; ++j) {
				for (int k = 5; k >= 0; --k) {
					System.out.printf("{i : %d, j : %d, k : %d}%n", i, j, k);
					if ((i + j + k) % 8 == 0)
						break EXIT_INNER_LOOP;
					
					if ((i + j + k) % 11 == 0)
						break EXIT_LOOP;
				}				
			}			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	continue deyimi döngünün o anki adımını sonlandırır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 1; i < 100; ++i) {
			if (i % 2 == 0)
				continue;
			
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Basit bir menü uygulamasının iskeleti
	(İleride daha iyisi yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		MenuApp.run();
	}
}

class MenuApp {
	public static void run()
	{
		Menu.run();
	}
}

class Menu {
	public static void displayMenu()
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkForInsert()
	{
		System.out.println("***************");
		System.out.println("Ekle seçildi");
		System.out.println("***************");
	}
	
	public static void doWorkForUpdate()
	{
		System.out.println("***************");
		System.out.println("Güncelle seçildi");
		System.out.println("***************");
	}
	
	public static void doWorkForDelete()
	{
		System.out.println("***************");
		System.out.println("Sil seçildi");
		System.out.println("***************");
	}
	
	public static void doWorkForList()
	{
		System.out.println("***************");
		System.out.println("Listele seçildi");
		System.out.println("***************");
	}
	
	public static void doWorkFor(int option)
	{
		if (option == 1)
			doWorkForInsert();
		else if (option == 2)
			doWorkForUpdate();
		else if (option == 3)
			doWorkForDelete();
		else
			doWorkForList();
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			displayMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if (option < 1|| option > 5) {
				System.out.println("Geçersiz seçenek");
				continue;
			}
			
			if (option == 5)
				break;
			
			doWorkFor(option);			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	switch deyiminin genel biçimi:
	switch (<ifade>) {
		case <sabit ifadesi>:
			<deyim>
			
		case <sabit ifadesi>:
			<deyim>
			...
			
		[
		default:
			<deyim>
		]
	}
	
	switch deyiminin parantez içerisindeki ifade temel türler için tamsayı türlerinden biri veya char türü olabilir.
	Temel türler dışında String veya enum türlerinde de olabilir. Bu türler ileride ele alınacaktır. switch deyiminde
	default kısmı zorunlu değildir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki switch deyiminin if deyimi karşılığı:
	if (plate == 34)
		System.out.println("İstanbul");
	else if (plate == 6)
		System.out.println("Ankara");
	else if (plate == 35)
		System.out.println("İzmir");
	else
		System.out.println("Geçersiz plaka numarası");
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		int plate = Integer.parseInt(kb.nextLine());
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
			break;
		case 6: 
			System.out.println("Ankara");
			break;			
		case 35: 
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz plaka numarası");
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: switch deyimin case bölümlerine ilişkin deyimlerin okunabilirlik açısından kısa tutulması
	gerekir. Sihirli bir sayı olmasa da 4 satırı geçmesi okunabilirliği bozar. Bu durumda metot yazıp ilgili
	bölümlerde çağırarak kodu düzenleyebilir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki switch deyiminin if deyimi karşılığı:
	if (plate == 34)
		System.out.println("İstanbul");
	else if (plate == 6)
		System.out.println("Ankara");
	else if (plate == 35)
		System.out.println("İzmir");	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		int plate = Integer.parseInt(kb.nextLine());
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
			break;
		case 6: 
			System.out.println("Ankara");
			break;			
		case 35: 
			System.out.println("İzmir");
			break;		
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	switch deyiminde default bölümün yerinin önemi yoktur. Tabii ki sona koyulaması daha uygundur	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		int plate = Integer.parseInt(kb.nextLine());
		
		switch (plate) {
		default:
			System.out.println("Geçersiz plaka numarası");
			break;
		case 34:
			System.out.println("İstanbul");
			break;
		case 6: 
			System.out.println("Ankara");
			break;			
		case 35: 
			System.out.println("İzmir");
			break;		
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	switch deyiminde case bölümlerine ilişkin ifadenin sabit ifadesi olması zorunludur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		int plate = Integer.parseInt(kb.nextLine());
		
		int a = 34;
		
		switch (plate) {		
		case a: //error
			System.out.println("İstanbul");
			break;
		case 6: 
			System.out.println("Ankara");
			break;			
		case 35: 
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz plaka numarası");
			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java derleyicisi sabit ifadelerini arakoda hesaplayarak yani doğrudan sonucunu yazarlar. 
	Buna "constant folding"	denir.
---------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------
	switch deyiminde birden fazla aynı değere sahip case bölümü olamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		int plate = Integer.parseInt(kb.nextLine());		
		
		switch (plate) {		
		case 34:
			System.out.println("İstanbul");
			break;
		case 6: //error
			System.out.println("Ankara");
			break;			
		case 6: //error
			System.out.println("Ankara");
			break;
		case 35: 
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz plaka numarası");
			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	switch deyiminde birden fazla aynı değere sahip case bölümü olamaz. Aşağıdaki örnekte "constant folding" 
	yapıldığında aynı değer edildiğine dikkat ediniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		int plate = Integer.parseInt(kb.nextLine());		
		
		switch (plate) {		
		case 34:
			System.out.println("İstanbul");
			break;
		case 6: //error
			System.out.println("Ankara");
			break;			
		case 3 + 3: //error
			System.out.println("Ankara");
			break;
		case 35: 
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz plaka numarası");
			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	switch deyimine ilişkin ifade temel türler için tamsayı türlerinden biri veya char türden olabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		double plate = Double.parseDouble(kb.nextLine());		
		
		switch (plate) { //error		
		case 34:
			System.out.println("İstanbul");
			break;
		case 6: 
			System.out.println("Ankara");
			break;	
		case 35: 
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz plaka numarası");
			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	switch deyiminde aşağı düşme (fall through) özelliği vardır. Bir case bölümü veya default yakalandığında 
	aşağıya doğru engelleyen herhangi bir deyim görülünceye kadar çalışıtırılır. break deyimi switch deyimini,
	sonlandrımakta kullanılır. Başka engelleyici deyimler de olabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		int plate = Integer.parseInt(kb.nextLine());		
		
		switch (plate) {	
		case 34:
			System.out.println("İstanbul");			
		case 6: 
			System.out.println("Ankara");			
		case 35: 
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz plaka numarası");
			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	switch deyiminde aşağı düşme (fall through) özelliği vardır. Bir case bölümü veya default yakalandığında 
	aşağıya doğru engelleyen herhangi bir deyim görülünceye kadar çalışıtırılır. break deyimi switch deyimini,
	sonlandrımakta kullanılır. Başka engelleyici deyimler de olabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Plaka numarasını giriniz:");
		int plate = Integer.parseInt(kb.nextLine());		
		
		switch (plate) {
		default:
			System.out.println("Geçersiz plaka numarası");		
		case 34:
			System.out.println("İstanbul");			
		case 6: 
			System.out.println("Ankara");			
		case 35: 
			System.out.println("İzmir");
			break;			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch deyiminin aşağıya düşme özelliği kullanılarak kod takrarı yapılmamıştır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Telefon kodunu giriniz:");
		int plate = Integer.parseInt(kb.nextLine());		
		
		switch (plate) {
		case 212:
			System.out.println("Avrupa yakası");			
		case 216:
			System.out.println("İstanbul");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz telefon kodu");			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneğin daha kısa yapılış şekli yoktur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Telefon kodunu giriniz:");
		int plate = Integer.parseInt(kb.nextLine());		
		
		switch (plate) {
		case 212:						
		case 216:
			System.out.println("İstanbul");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz telefon kodu");			
		}
		
		System.out.println("Teşekkürler");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Basit bir menü uygulamasının iskeleti
	(İleride daha iyisi yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		MenuApp.run();
	}
}

class MenuApp {
	public static void run()
	{
		Menu.run();
	}
}

class Menu {
	public static void displayMenu()
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkForInsert()
	{
		System.out.println("***************");
		System.out.println("Ekle seçildi");
		System.out.println("***************");
	}
	
	public static void doWorkForUpdate()
	{
		System.out.println("***************");
		System.out.println("Güncelle seçildi");
		System.out.println("***************");
	}
	
	public static void doWorkForDelete()
	{
		System.out.println("***************");
		System.out.println("Sil seçildi");
		System.out.println("***************");
	}
	
	public static void doWorkForList()
	{
		System.out.println("***************");
		System.out.println("Listele seçildi");
		System.out.println("***************");
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		EXIT_MENU:
		for (;;) {
			displayMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			switch (option) {
			case 1:
				doWorkForInsert();
				break;
			case 2:
				doWorkForUpdate();
				break;
			case 3:
				doWorkForDelete();
				break;
			case 4:
				doWorkForList();
				break;
			case 5:
				break EXIT_MENU;
			default:
				System.out.println("Geçersiz seçenek");			
			}			
		}
		
		System.out.println("Teşekkürler");
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden yıl bilgisinin artık yıl olup olmadığını test eden isLeapYear
	isimli metodu DateUtil isimli sınıf içerisinde yazınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		IsLeapYearTest.run();
	}
}

class IsLeapYearTest {
	public static void run()
	{
		for (int y = 1999; y <= 2104; ++y)
			if (DateUtil.isLeapYear(y))
				System.out.printf("%d ", y);
		
		System.out.println();
	}
}

class DateUtil {
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0; 
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının 10'luk sistemde Harshad sayısı olup olmadığını
	test eden isDecimalHarshad isimli metodu NumberUtil sınıfı içerisinde yazınız ve test ediniz.
	Açıklamalar:
	- Basamaklarının toplamına bölünebilen sayılara Harshad (Niven) sayılar denir
	- Metot negatif sayılar için false değerine dönecektir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		IsDecimalHarshadTest.run();
	}
}

class IsDecimalHarshadTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			if (val == 0)
				break;
		
			
			if (NumberUtil.isDecimalHarshad(val))
				System.out.printf("%d sayısı bir Harshad (Niven) sayısıdır%n", val);
			else
				System.out.printf("%d sayısı bir Harshad (Niven) sayısı değildir%n", val);
			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static boolean isDecimalHarshad(int val)
	{
		if (val < 0)
			return false;
		
		return val % getDigitsSum(val) == 0;		
	}
	
	public static int getDigitsSum(int val)
	{
		int sum = 0;
		
		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}		
		
		return Math.abs(sum);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgisine ilişkin tarihin geçerli bir tarih olup
	olmadığını test eden isValidDate isimli metodu yazınız
	(İleride daha iyileri yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		IsValidDateTest.run();
	}
}

class IsValidDateTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Gün?");
			int day = Integer.parseInt(kb.nextLine());
			
			if (day == 0)
				break;
			
			System.out.print("Ay?");
			int month = Integer.parseInt(kb.nextLine());
			
			System.out.print("Yıl?");
			int year = Integer.parseInt(kb.nextLine());
			
			if (DateUtil.isValidDate(day, month, year))
				System.out.printf("%02d/%02d/%04d tarihi geçerlidir%n", day, month, year);
			else
				System.out.println("Geçersiz tarih");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class DateUtil {
	public static boolean isValidDate(int day, int month, int year)
	{
		if (day < 1 || day > 31 || month < 1 || month > 12)
			return false;
		
		int days = 31;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return day <= days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0; 
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	03.01.2021
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgisine ilişkin tarihin yılın kaçıncı günü
	olduğunu döndüren getDayOfYear isimli metodu DateUtil sınıfı içerisinde yazınız. Metot geçersiz bir tarih için
	-1 değerini döndürecektir
	(İleride daha iyileri yazılacaktır)
	
	01.3.2020 -> 1 + 29 + 31 = 61
	01.3.2021 -> 1 + 28 + 31 = 60
	31.12.2020 -> 31 + 30 + 31 + ... + 29 + 31 = 366
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		GetDayOfYearTest.run();
	}
}

class GetDayOfYearTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Gün?");
			int day = Integer.parseInt(kb.nextLine());
			
			if (day == 0)
				break;
			
			System.out.print("Ay?");
			int month = Integer.parseInt(kb.nextLine());
			
			System.out.print("Yıl?");
			int year = Integer.parseInt(kb.nextLine());
			
			int dayOfYear = DateUtil.getDayOfYear(day, month, year);
			
			if (dayOfYear > 0)
				System.out.printf("%02d/%02d/%04d tarihi yılın %d. günüdür%n", day, month, year, dayOfYear);
			else
				System.out.println("Geçersiz tarih");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class DateUtil {	
	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;		
			
		return day + getTotalDaysByMonth(month, year);
	}
	
	
	public static int getTotalDaysByMonth(int month, int year)
	{
		int totalDays = 0;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += 28;
			if (isLeapYear(year))
				++totalDays;
		case 1:
			totalDays += 31;			
		}
		
		return totalDays;
			
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{
		if (day < 1 || day > 31 || month < 1 || month > 12)
			return false;
		
		int days = 31;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return day <= days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0; 
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgisine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek metodunu yazınız
	Açıklamalar:
		- Metot geçersiz bir tarih için -1 değerine döndecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasınddaki gün sayısının 7 ile bölümünden elde edilen kalan ile 
		bulunabilir. Bu değer 0 (sıfır) için "Pazar", 1 için "Pazartesi", ..., 6 için "Cumartesi" gününe ilişkindir.
		- 1.1.1900 öncesindeki tarihler geçersiz kabul edilecektir		
		- Ekran çıktısında haftanın günü bilgisini Türkçe olarak da gösteriniz. Örneğin:
			03/01/2021 Pazar
		- Parametresi ile aldığı gün, ay ve yıl bilgisine ilişkin tarihin hafta sonu olup olmadığını test eden
		isWeekend metodunu yazınız. Metot geçerlilik kontrolü yapmayacaktır
		- Parametresi ile aldığı gün, ay ve yıl bilgisine ilişkin tarihin hafta içi olup olmadığını test eden
		isWeekday metodunu yazınız. Metot geçerlilik kontrolü yapmayacaktır
		- İleride daha iyileri yazılacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		GetDayOfYearTest.run();
	}
}

class GetDayOfYearTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Gün?");
			int day = Integer.parseInt(kb.nextLine());
			
			if (day == 0)
				break;
			
			System.out.print("Ay?");
			int month = Integer.parseInt(kb.nextLine());
			
			System.out.print("Yıl?");
			int year = Integer.parseInt(kb.nextLine());
			
			DateUtil.displayDateTR(day, month, year);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class DateUtil {	
	public static void displayDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);		
		
		switch (dayOfWeek) {
			case 0:
				System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
				break;
			case 1:
				System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
				break;
			case 2:
				System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);
				break;
			case 3:
				System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);
				break;
			case 4:
				System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
				break;
			case 5:
				System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);
				break;
			case 6:
				System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);
				break;
			default:
				System.out.println("Geçersiz tarih");
		}
		
		if (isWeekend(day, month, year)) 
			System.out.println("Bugün kurs var tekrar yaptınız mı?");
		else
			System.out.println("Hafta sonu kurs var. Tekrar yapmayı unutmayınız!!!");
	}
	
	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		return dayOfWeek == 0 || dayOfWeek == 6;
	}
	
	public static boolean isWeekday(int day, int month, int year)
	{		
		return !isWeekend(day, month, year);
	}
	
	public static int getDayOfWeek(int day, int month, int year)
	{		
		int totalDays;
		
		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;		
		
		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}
		
		return totalDays % 7;					
	}
	
	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;		
			
		return day + getTotalDaysByMonth(month, year);
	}
	
	
	public static int getTotalDaysByMonth(int month, int year)
	{
		int totalDays = 0;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += 28;
			if (isLeapYear(year))
				++totalDays;
		case 1:
			totalDays += 31;			
		}
		
		return totalDays;
			
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{
		if (day < 1 || day > 31 || month < 1 || month > 12)
			return false;
		
		int days = 31;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return day <= days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0; 
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir sayısının basamaksal kökünü bulan getDigitalRoot isimli metodu yazınız ve test ediniz
	Açıklamalar:
		- Bir sayının basamaksal kökü tüm basamaklarının toplanması ile elde edilen sayıdır. Basamakları toplama,
		tek basamaklı bir sayı elde edilene kadar sürdürülür. Örneğin
		36987 -> 3 + 6 + 9 + 8 + 7 = 33
		33 -> 3 + 3 = 6 -> basamaksal kök
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		GetDigitalRootTest.run();
	}
}

class GetDigitalRootTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d sayısının basamaksal kökü:%d%n", val, NumberUtil.getDigitalRoot(val));
			
			if (val == 0)
				break;			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static int getDigitalRoot(int val)
	{		
		if (Math.abs(val) < 10)
			return val;
		
		int root = val;
		
		while ((root = getDigitsSum(root)) > 9)
			;
		
		return root;		
	}
	
	public static int getDigitsSum(int val)
	{
		int sum = 0;
		
		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}		
		
		return Math.abs(sum);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir sayısının basamaksal kökünü bulan getDigitalRoot isimli metodu yazınız ve test ediniz
	Açıklamalar:
		- Bir sayının basamaksal kökü tüm basamaklarının toplanması ile elde edilen sayıdır. Basamakları toplama,
		tek basamaklı bir sayı elde edilene kadar sürdürülür. Örneğin
		36987 -> 3 + 6 + 9 + 8 + 7 = 33
		33 -> 3 + 3 = 6 -> basamaksal kök
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		GetDigitalRootTest.run();
	}
}

class GetDigitalRootTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d sayısının basamaksal kökü:%d%n", val, NumberUtil.getDigitalRoot(val));
			
			if (val == 0)
				break;			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class NumberUtil {
	public static int getDigitalRoot(int val)
	{		
		int root = Math.abs(val);
		
		while (root > 9)
			root = getDigitsSum(root);
		
		return root;
	}
	
	public static int getDigitsSum(int val)
	{
		int sum = 0;
		
		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}		
		
		return Math.abs(sum);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Pozitif bir sayının factorian sayısı olup olmadığını test eden isFactorian isimli metodu yazınız
	ve test ediniz.
	Açıklamalar:
	- Basamaklarının faktoriyelleri toplamı kendisine eşit olan sayıya factorian denir.
	- Sayma sayılarında (pozitif sayılarda) 4 tane factorian sayı vardır. Bunlardan ilk ikisi şüphesiz 1 ve 2'dir
	Diğerlerini de bulan test kodunu yazınız
	- İpucu: Kalan iki sayı da 100000 değerinden küçüktür
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		IsFactorianTest.run();
	}
}

class IsFactorianTest {
	public static void run()
	{
		for (int i = 1; i <= 100000; ++i)
			if (NumberUtil.isFactorian(i))
				System.out.println(i);
	}
}

class NumberUtil {
	public static boolean isFactorian(int val)
	{
		if (val <= 0)
			return false;		
		
		return getDigitsFactorialSum(val) == val;
	}
	
	public static int getDigitsFactorialSum(int val)
	{
		int sum = 0;
		
		while (val != 0) {
			sum += factorial(val % 10); 
			val /= 10;
		}		
		
		return sum;
	}
	
	public static int factorial(int n)
	{
		if (n < 0)
			return -1;
		
		int result = 1;
		
		for (int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Pozitif bir sayının factorian sayısı olup olmadığını test eden isFactorian isimli metodu yazınız
	ve test ediniz.
	Açıklamalar:
	- Basamaklarının faktoriyelleri toplamı kendisine eşit olan sayıya factorian denir.
	- Sayma sayılarında (pozitif sayılarda) 4 tane factorian sayı vardır. Bunlardan ilk ikisi şüphesiz 1 ve 2'dir
	Diğerlerini de bulan test kodunu yazınız
	- İpucu: Kalan iki sayı da 100000 değerinden küçüktür
	- İleride daha iyi şekilde yazabileceksiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		IsFactorianTest.run();
	}
}

class IsFactorianTest {
	public static void run()
	{
		for (int i = -10; i <= 100000; ++i)
			if (NumberUtil.isFactorian(i))
				System.out.println(i);
	}
}

class NumberUtil {
	public static boolean isFactorian(int val)
	{
		if (val <= 0)
			return false;		
		
		return getDigitsFactorialSum(val) == val;
	}
	
	public static int getDigitsFactorialSum(int val)
	{
		int sum = 0;
		
		while (val != 0) {
			sum += factorial(val % 10); 
			val /= 10;
		}		
		
		return sum;
	}
	
	public static int factorial(int n)
	{
		if (n < 0)
			return -1;
		
		int result = 1;
		
		for (int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Collatz serisine ilişkin sayılarını ekrana
	basan displayCollatz metodunu yazınız
	Açıklamalar:
		(Collatz conjecture)
		- n bir pozitif tamsayı olmak üzere her yeni n değeri için aşağıdaki kurallar uygulanacaktır:
		 	- n, 1 değerine eşit ise işlemler sonlandırılacaktır
		 	- n çift ise yeni n değeri olarak n / 2, n tek ise yeni n değeri olarak 3 * n + 1 alınacaktır
		 	
		 	Örnek:		 	
		 	72543 217630 108815 326446 163223 489670 244835 734506 367253 1101760 
			550880 275440 137720 68860 34430 17215 51646 25823 77470 38735 116206 
			58103 174310 87155 261466 130733 392200 196100 98050 49025 147076 73538 
			36769 110308 55154 27577 82732 41366 20683 62050 31025 93076 46538 23269 
			69808 34904 17452 8726 4363 13090 6545 19636 9818 4909 14728 7364 3682 
			1841 5524 2762 1381 4144 2072 1036 518 259 778 389 1168 584 292 146 73 
			220 110 55 166 83 250 125 376 188 94 47 142 71 214 107 322 161 484 242 
			121 364 182 91 274 137 412 206 103 310 155 466 233 700 350 175 526 263 
			790 395 1186 593 1780 890 445 1336 668 334 167 502 251 754 377 1132 566 
			283 850 425 1276 638 319 958 479 1438 719 2158 1079 3238 1619 4858 2429 
			7288 3644 1822 911 2734 1367 4102 2051 6154 3077 9232 4616 2308 1154 577 
			1732 866 433 1300 650 325 976 488 244 122 61 184 92 46 23 70 35 106 53 
			160 80 40 20 10 5 16 8 4 2 1
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		DisplayCollatzTest .run();
	}
}

class DisplayCollatzTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n == 0)
				break;
			
			NumberUtil.displayCollatz(n);
		}
	}
}

class NumberUtil {
	public static void displayCollatz(int n)
	{
		if (n <= 0) {
			System.out.println("Geçersiz değer");
			return;
		}
		
		for (;;) {
			System.out.println(n);
			
			if (n == 1)
				break;
			
			if (n % 2 == 0)
				n /= 2;
			else
				n = 3 * n + 1;				
		}
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	09.01.2021
	Sınıf Çalışması: Aşağıdaki açıklamalara göre bir tamsayının super asal (super prime) olup olmadığını test eden
	isSuperPrime isimli metodu yazınız ve test ediniz.
	Not: Super asal sayılara asal indeksli asal sayılar (prime indexed primes) da denir
	Açıklamalar:
	- Tüm asal sayıların 1 değerinden başlayarak indeklendiğini düşünelim:
	1 -> 2
	2 -> 3 *
	3 -> 5 *
	4 -> 7
	5 -> 11 *
	6 -> 13
	7 -> 17 *
	...
	
	Eğer asal sayının indeksi'de yani kaçıncı asal sayı olduğu da asal ise bu sayı super asal sayıdır
---------------------------------------------------------------------------------------------------------------------*/

package csd;

class App {
	public static void main(String [] args)
	{		
		DisplayIsSuperPrimeTest.run();
	}
}

class DisplayIsSuperPrimeTest {
	public static void run()
	{
		System.out.println("Prime Numbers in [0, 100]");
		for (int i = 0; i <= 100; ++i)
			if (NumberUtil.isPrime(i))
				System.out.printf("%d -> %d%n", NumberUtil.getIndexOfPrimeNumber(i), i);
		
		System.out.println("Super Prime Numbers in [0, 100]");
		for (int i = 0; i <= 100; ++i)
			if (NumberUtil.isSuperPrime(i))
				System.out.printf("%d ", i); 
	}
}

class NumberUtil {	
	public static boolean isSuperPrime(int val)
	{
		return isPrime(val) && isPrime(getIndexOfPrimeNumber(val));
	}
	
	public static int getIndexOfPrimeNumber(int n) //Bu metotta asallık kontrolü yapılmadı
	{
		int index = 1;
		int val = 2;
		
		for (;;) {
			if (val == n)
				return index;
			
			if (isPrime(val))
				++index;
			
			++val;
		}		
	}
		
	public static boolean isPrime(int val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
		
		for (int i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;
		
		return true;
		
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: n pozitif bir tamsayı üzere ve a, b, c, d birbirinden farklı pozitif tamsayılar olmak üzere eğer
	n = a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 eşitliğini sağlayacak şekilde a, b, c ve d tamsayıları var ise n bir
	Hardy-Ramanujan sayısıdır.  
	
	1729 = 9 ^ 3 + 10 ^ 3 = 1 ^ 3 + 12 ^3
	Buna göre 100000'den küçük olan tüm Hardy-Ramanujan sayılarını ekrana bastıran metodu programı yazınız  
---------------------------------------------------------------------------------------------------------------------*/

package csd;

class App {
	public static void main(String [] args)
	{		
		HardyRamanujanTest.run();
	}
}

class HardyRamanujanTest {
	public static void run()
	{
		for (int i = 1; i < 100000; ++i)
			if (NumberUtil.isHardyRamanujan(i))
				System.out.println(i);
	}
}

class NumberUtil {	
	public static boolean isHardyRamanujan(int val)
	{
		if (val <= 0)
			return false;
		
		int count = 0;
		
		for (int x = 1; x * x * x < val;) {
			for (int y = x + 1; x * x * x + y * y * y <= val; ++y)  {
				if (x * x * x + y * y * y == val) {
					++count;
					++x;
				}					
			}
			++x;
		}
		
		return count >= 2;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Farklı türlerin birbirine atanması (Tür dönüşümleri-type conversions)
	T1 ve T2 birer tür ismi olmak üzere T1 türünden T2 türüne yapılan doğrudan atama işlemine T1 türünden T2 türüne
	doğrudan dönüştürme (implicit conversion) denir. Bu atama örneğin:
	T1 a;
	T2 b;
	
	b = a;
	şeklinde belirtilebilir. Bu konu içerisinde anlatılan kurallar aksi belirtilmediği sürece tüm atama durumları için
	geçerlidir. 

	Yukarıdaki atamada T1 türüne kaynak tür (source type), T2 türüne hedef tür (target type) denir. Java'da bir türün
	başka bir türe atanıp atanmayacağı derleme zamanında belirlenir. Kaynak türe ilişkin değere çalışma zamanında 
	bakılmaz. Zaten çoğu zaman da bakılamaz.
	
	Java'da genel olarak bilgi kaybına yol açmayacak doğrudan dönüşümler geçerlidir
	
	Anahtar Notlar: Java Language Specification dökümanında uzunluk (size) olarak küçük türden uzunluk olarak
	büyük türe yapılan dönüşüme genişletme dönüşümü (widening conversion), büyük türden küçük türe yapılan dönüşüme 
	ise daraltma dönüşümü (narrowing conversion) terimleri kullanılır.
	
	Doğrudan dönüşüme ilişkin detaylar aşağıda anlatılmaktadır.
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte long türünün içerisindeki değer bakılmaksızın atama geçersiz olduğundan error oluşur.
	Zaten örneğin değer klavyeden alınmış olsaydı hangi değer olacağı da bilinemezdi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		long a = 10;
		int b;
		
		b = a; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atama geçerlidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 10;
		long b;
		
		b = a;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("b=%d%n", b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atamalarda küçük tamsayı türüne ilişkin değer pozitif veya sıfır
	ise sayının yüksek anlamlı yeni bit değerleri 0(sıfır) ile beslenir. Eğer sayı negatif ise sayının işaretinin 
	değişmemesi için yüksek anlamlı bit değerleri 1(bir) ile beslenir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		short a = Short.parseShort(kb.nextLine());		
		int b;
		
		b = a;
		
		System.out.printf("a=%d%n", a);
		System.out.printf("a=%X%n", a);
		System.out.printf("b=%d%n", b);
		System.out.printf("b=%X%n", b);		
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Hiçbir türden char türüne doğrudan atama yapılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 67;
		char c = a; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Hiçbir türden char türüne doğrudan atama yapılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		byte a = 67;
		char c = a; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kurala istisna olarak "char türü sınırları içerisinde kalan int türden bir sabit" char türüne 
	doğrudan atanabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		char c = 67;
		
		System.out.printf("c = %d%n", c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kurala istisna olarak "char türü sınırları içerisinde kalan int türden bir sabit" char türüne 
	doğrudan atanabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int val = 67;
		char c1 = 67;
		char c2 = val; //error
		char c3 = 67000; //error
		char c3 = 67L; //error
		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	char türünden short türüne doğrudan atama geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		char a = 40000;
		short b;
		
		b = a; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	short türünden char türüne doğrudan atama geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		short a = -45;
		char b;
		
		b = a; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	char türünden kendisinden uzunluk olarak büyük türlere doğrudan atama geçerlidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		char a = 40000;
		double b;
		
		b = a; 
		
		System.out.printf("b = %f%n", b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Bilindiği gibi Java'da byte ve short türden sabit yoktur. Ancak "sınırlar içerisinde kalan int türden 
	bir sabit" byte/short türüne atanabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		short a;
		byte b;
		
		a = 45;
		b = 67;
		
		a = 40000; //error
		b = -156; //error
		
		a = 10L; //error
		b = 20L; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Bütün tamsayı türlerinden gerçek sayı türlerine doğrudan atama geçerlidir	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		long a = 3000_000_000L;
		float b;
		
		b = a; 
		
		System.out.printf("b = %f%n", b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Gerçek sayı türlerinden tamsayı türlerine doğrudan atama yapılamaz	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		float a = 3000_000_000L;
		long b;
		
		b = a; //error				
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	float türünden double türüne doğrudan atama geçerlidir	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		float a = 10;
		double b;
		
		b = a;
		
		System.out.printf("b = %f%n", b);						
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	float türünden double türüne doğrudan atama geçerlidir	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		double a = 10;
		float b;
		
		b = a; //error								
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	double türünden bir sabit te float türüne doğrudan atanamaz 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		float a = 3.4F;
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("3.4 = %.20f%n", 3.4);										
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	boolean türünden herhangi türe doğrudan atama geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		int a;
		
		a = flag; //error
		//..
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Herhangi bir türden boolean türüne doğrudan atama geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 0;
		boolean b;
		
		b = a; //error
		//..
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Temel türler için doğrudan dönüşüm tablosu:
	byte 	-> short, int, long, float, double
	short 	-> int, long, float, double
	int		-> long, float, double
	long	-> float, double
	float	-> double
	char	-> int, long, float, double
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	short, byte ve char türlerine "sınırlar içerisinde kalması koşuluyla int türden bir sabitin doğrıdan atanabilmesi"
	kuralının detayları
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	short, byte ve char türlerine "sınırlar içerisinde kalması koşuluyla int türden bir sabitin doğrıdan atanabilmesi"
	kuralı metodun geri dönüş değerinin geçici değişkene atanması işleminde de geçerlidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		
	}
}

class Sample {
	public static short foo()
	{
		//...		
		
		return 10;
	}
	
	public static byte bar()
	{
		//...		
		
		return 10;
	}
	
	public static char tar()
	{
		//...		
		
		return 10;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	short, byte ve char türlerine "sınırlar içerisinde kalması koşuluyla int türden bir sabitin doğrıdan atanabilmesi"
	kuralı metot çağrısında argümanlardan parametrelere yapılan atama işleminde geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(10); //error
		Sample.bar(10); //error
		Sample.tar(10);	//error
	}
}

class Sample {
	public static void foo(short a)
	{
		//...		
	
	}
	
	public static void bar(byte a)
	{
		//...		
	
	}
	
	public static void tar(char a)
	{
		//...		
	
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte derleyicinin constant folding özelliği sabit 133 elde edilir, sınırlar dışında kaldığından
	error oluşur 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a;	
		
		a = 120 + 13; //error
		
		//...		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 İki operandlı bir operatör için derleyici önce operandların türüne bakar. Operandlar farklı türdense ortak
	 türe dönüştürülür sonra işlem o türden yapılır. Hatta bazı durumlarda iki tür aynı olsa bile ikisini de farklı
	 ortak türe dönüştürür. Bu dönüştürmeye "işlem öncesi otomatik tür dönüşümü denir". 
	 
	 Bu kuralın özeti "genel olarak küçük türe ilişkin değer büyük türe dönüştürülür. Sonuç büyük türden çıkar"
---------------------------------------------------------------------------------------------------------------------*/

package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 20;
		
		long c = a + b;
		
		System.out.printf("c = %d%n", c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	İşlem öncesinde öncesinde her iki operand'da byte, short ve char türlerindense her iki operand da int türüne
	dönüştürülür (integral promotion), sonuç int türden çıkar 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a, b;
		short c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	İşlem öncesinde öncesinde her iki operand'da byte, short ve char türlerindense her iki operand da int türüne
	dönüştürülür (integral promotion), sonuç int türden çıkar 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a;
		short b;
		short c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	İşlem öncesinde öncesinde her iki operand'da byte, short ve char türlerindense her iki operand da int türüne
	dönüştürülür (integral promotion), sonuç int türden çıkar 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a;
		char b;
		short c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Bölme işleminde her iki operand da tamsayı türlerine ilişkinse sonuç tamsayı türünden çıkar. Bölme işlemi yapılır.
	Elde edilen sayının noktadan sonraki kısmı atılır 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 3;
		
		double c;
		
		c = a / b;
		
		System.out.printf("c=%.30f%n", c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Gerçek sayı türleri ve tamsayı türleri işleme sokulduğunda dönüştürme gerçek sayı türüne doğrudur. Yani tamsayı
	türüne ilişkin değer gerçek sayıya dönüştürülür. Sonuç o gerçek sayı türünden çıkar
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a;
		float b;
		
		a = 34;
		b = 5.6F;
		
		float c = a + b;
		
		System.out.printf("c=%.30f%n", c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Küçük tamsayı türü ile büyük tamsayı türü işleme sokulduğunda dönüşüm büyük tamsayı türüne doğrudur. Sonuç büyül
	tamsayı türünden çıkar.
	Dikkat: Integral promotion bu kuralın dışındadır	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a;
		long b;
		
		a = 34;
		b = 5;
		
		long c = a + b;
		
		System.out.printf("c=%d%n", c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	boolean türü hiçbir tür ile işleme sokulamaz	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 3;
		int c;
		
		c = a + b; //error
		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	char türü diğer türlerle işleme sokulabilir	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char a = 'C';
		float b = 3;		
		float c;
		
		c = a + b;
		
		System.out.printf("c = %f%n", c);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	İşlem öncesi otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratacak kodu
	üretir: Örnekte derleyici aşağıdakine benzer bir kod üretecektir:
	long temp = b;
	long c = a + temp; 	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 10;
		int b = 20;		
		long c = a + b;
		
		//...		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	İşlem öncesi otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratacak kodu
	üretir: Örnekte derleyici aşağıdakine benzer bir kod üretecektir:
	int temp1 = a;
	int temp2 = b;
	int c = temp1 + temp2; 	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		byte b = 20;		
		int c = a + b;
		
		//...		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 Tür dönüştürme (type cast) operatörünün genel biçimi:
	 (<tür ismi>) <operand>
	 Tür dönüştürme operatörü özel amaçlı, tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Tür dönüştürme
	 operatörü operandına ilişkin ifadenin değerini dönüştürülecek tür olarak üretir
	 
	 Tür dönüştürme operatörü ile yapılan dönüşüme "bilinçli tür dönüşümü (explicit conversion)" denir. Genel olarak
	 implicit olmayan dönüşümler explicit olarak yapılabilir. 
	 
	 Anahtar Notlar: Tür dönüştürme operatörünün kullanılmasının sentaks ve semantik olarak zorunlu olması genel olarak
	 "İşlem yapıldığında bir problem olabilir. Bu sebeple derleyici bunu doğrudan yapmamızı istemiyor. Biz yapmak istersek
	 derleyiciye farkındayım dememiz gerekir" anlamına gelir 	 
---------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------
	 Tür dönüştürme operatörü 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 3;
		double c;
		
		c = (double)a / b;
		
		System.out.printf("c = %f%n", c);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 Tür dönüştürme operatörü 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 3000000000L;
		int b;
		
		b = (int)a;
		
		System.out.printf("b = %d%n", b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 implicit olarak yapılabilen dönüşümler explicit olarak da yapılabilir. Aşağıdaki örnekte bu yapılmıştır ancak
	 anlamı yoktur 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b;
		
		b = (long)a;
		
		System.out.printf("b = %d%n", b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 10.01.2021	  
	 Aşağıdaki maddeler genel olarak implicit yapılamayan dönüşümlere ilişkindir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	 Dönüştürme sırasında kaynak türün içerisindeki değer hedef türün sınırları içerisinde kalıyorsa bilgi kaybı
	 oluşmaz  	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a;
		int b;
		
		a = 135;
		b = (int)a;
		
		System.out.printf("b = %d%n", b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 Büyük tamsayı türünden küçük tamsayı türüne yapılan explicit dönüşümde sayının yüksek anlamlı byte değerleri
	 atılır. Elde edilen değer hedef türe atanır. 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a;
		int b;
		
		a = -100_000_000_000L;
		b = (int)a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("a = %X%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %X%n", b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 Büyük tamsayı türünden küçük tamsayı türüne yapılan explicit dönüşümde sayının yüksek anlamlı byte değerleri
	 atılır. Elde edilen değer hedef türe atanır. 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		long a = Long.parseLong(kb.nextLine());
		int b;
		
		b = (int)a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("a = %X%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %X%n", b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 short türünden char türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı
	 değişir 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		short a = Short.parseShort(kb.nextLine());
		char b;
		
		b = (char)a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("a = %X%n", a);
		System.out.printf("(int)b = %X%n", (int)b);
		System.out.printf("(int)b = %d%n", (int)b);
		System.out.printf("b = %c%n", b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 char türünden short türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı
	 değişir 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		char a = '\uFFAC';
		short b;
		
		b = (short)a;
		
		System.out.printf("(int)a = %d%n", (int)a);		
		System.out.printf("(int)a = %X%n", (int)a);
		System.out.printf("a = %c%n", a);
		System.out.printf("b = %X%n", b);
		System.out.printf("b = %d%n", b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 byte türünden char türüne yapılan explicit dönüşümde dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer
	 int türüne dönüştürülür. İkinci aşamda yüksek anlamlı byte değerleri atılarak char türüne dönüştürülür 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		byte a = 99;
		char b;
		
		b = (char)a;
		
		System.out.printf("(int)a = %X%n", (int)a);		
		System.out.printf("b = %c%n", b);
		System.out.printf("int:b = %X%n", (int)b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 byte türünden char türüne yapılan explicit dönüşümde dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer
	 int türüne dönüştürülür. İkinci aşamda yüksek anlamlı byte değerleri atılarak char türüne dönüştürülür
	 (widening and narrowing) 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		byte a = -99;
		char b;
		
		b = (char)a;
		
		System.out.printf("a = %X%n", a);
		System.out.printf("(int)a = %X%n", (int)a);		
		System.out.printf("b = %c%n", b);
		System.out.printf("int:b = %X%n", (int)b);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	 double türünden float türüne yapılan explicit dönüşümde bilgi kaybı olabilir. Bu durumda IEEE754 standardına göre
	 yuvarlama kuralları kullanılarak float türünde temsil edilebilecek en yakın değer elde edilir 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		double a = 5.897;
		float b = (float)a;
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);				
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	boolean türünden herhangi bir türe explicit dönüşüm de geçersizdir 	 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		boolean a = true;
		int  b = (int)a; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Herhangi bir türden boolean türüne explicit dönüşüm de geçersizdir 	 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 1;
		boolean b = (boolean)a; //error
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Gerçek sayı türünden tamsayı türüne yapılan explicit dönüşüm şu aşamalarla gerçekleşir:
	- Sayının noktadan sonraki kısmı atılır
		- Elde edilen değer hedef türün sınırları içerisinde kalıyorsa doğrudan hedef türe atılır
		- Elde edilen değer hedef türün sınırları içerisinde değilse:
			- Hedef tür byte, short, int ve char türlerinden biriyse elde edilen değer int türüne dönüştürülür
				- Elde edilen değer int türü sınırları içerisinde int türüne dönüşüm kuralları uygulanır. Buradan
				elde edilen değer tamsayılar arasındaki dönüşüm kurallarına göre hedef türe atanır 
				- Elde edilen değer int türü sınırları içerisinde değilse değerin pozitif ya da negatif olmasına
				göre int türünün en büyük ya da en küçük değeri alınır ve hedef türe dönüştürülür
			- Hedef tür long türü ise elde edilen long türüne dönüştürülür
				- Elde edilen değer long türü sınırları içerisindeyse doğrudan atanır
				- Elde edilen değer long türü sınırları içerisinde değilse sayının değerin pozitif ya da negatif olmasına
				göre long türünün en büyük ya da en küçük değeri alınır ve hedef türe atanır
---------------------------------------------------------------------------------------------------------------------*/

package csd;

class App {
	public static void main(String [] args)
	{
		double a;
		int b;
		
		a = 345.907;
		
		b = (int)a;
		
		System.out.printf("b = %d%n", b);		
	}
}
package csd;

class App {
	public static void main(String [] args)
	{
		double a;
		byte b;
		
		a = -1230.907;
		
		b = (byte)a;
		
		System.out.printf("-1230 = 0x%X%n", -1230);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = 0x%X%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a;
		short b;
		
		a = -1230.907;
		
		b = (short)a;
		
		System.out.printf("-1230 = 0x%X%n", -1230);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = 0x%X%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a;
		byte b;
		
		a = 5_000_000_000.907;
		
		b = (byte)a;
		
		System.out.printf("%d%n", (byte)5_000_000_000L);
		System.out.printf("%d%n", (byte)2147483647);
		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a;
		int b;
		
		a = 5_000_000_000.907;
		
		b = (int)a;
		
		System.out.printf("%d%n", (int)5_000_000_000L);		
		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a;
		int b;
		
		a = -5_000_000_000.907;
		
		b = (int)a;
		
		System.out.printf("%d%n", (int)-5_000_000_000L);		
		System.out.printf("b = %d%n", b);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Bazen tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız");
		
		int sum = 0;
		int count = 0;
		
		for (;;) {
			int val = Integer.parseInt(kb.nextLine());
			
			if (val == 0)
				break;
			
			sum += val;
			++count;
		}
		
		double average = (double)sum / count;
		
		System.out.printf("Ortalama:%f%n", average);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Bazen tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.printf("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.printf("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		long c = (long)a + b;
		
		System.out.printf("%d + %d = %d%n", a, b, c);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte double türden sabit kullanıldığından doğru işlem yapılmıştır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int sum = 0;
		
		for (int i = 0; i < 6; ++i) {
			System.out.printf("%d. sayıyı giriniz:", i + 1);
			int val = Integer.parseInt(kb.nextLine());
			
			sum += val;
		}
		
		double average = sum / 6.;
		
		System.out.printf("Ortalama:%f%n", average);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte double türden sabit kullanıldığından doğru işlem yapılmıştır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int sum = 0;
		
		for (int i = 0; i < 6; ++i) {
			System.out.printf("%d. sayıyı giriniz:", i + 1);
			int val = Integer.parseInt(kb.nextLine());
			
			sum += val;
		}
		
		double average = sum / 6D;
		
		System.out.printf("Ortalama:%f%n", average);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
 	İşlemli atama operatörlerinin çalışma biçimi:
 	T1 a;
 	T2 b;
 	
	a op= b -> a = (T1)(a op b)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 20;
		
		a = (int)(a + Math.sqrt(b));
		a += Math.sqrt(b);
		
		//...
	}
}



/*--------------------------------------------------------------------------------------------------------------------
	Bir sayının log10 kullanarak basamak sayısının bulunması
	Not: Arkadaşlar bu yöntemi unutmayınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Bir sayı giriniz:");
		long val = Long.parseLong(kb.nextLine());
		
		int count = 1;
		
		if (val != 0)
			count = (int)Math.log10(Math.abs(val)) + 1;
		
		System.out.printf("%d sayısının basamak sayısı:%d%n", val, count);		
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong
	metodunu NumberUtil sınıfı içerisinde yazınız ve test ediniz. 
	
	Açıklamalar:
	- Kuvvet alma işlemi için Math sınıfının pow metodunu kullanmayınız
	
	- Bir sayının her basamağının basamak sayıncı kuvvetleri alınıp toplandığında sonuç sayının kendisine eşitse, bu 
	sayı bir Armstrong sayısıdır
	Örneğin: 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153
	
	- Sayı negatif ise false döndürebilirsiniz
	
	- Test işlemini 1, 2, 3, 4, 5, 6 ve 7 basamaklı Armstrong sayılarını ekrana yazdırarak yapabilirsiniz
	
	Örnekte Math.pow metodunun += operatörü ile kullanımına ve countDigits metoduna dikkat ediniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}


class IsArmstrongTest {
	public static void run()
	{
		for (int n = -100; n <= 9999999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {
	public static boolean isArmstrong(int val)
	{
		if (val < 0)
			return false;
		
		return getDigitstPowSum(val) == val;	
	}
	
	public static int getDigitstPowSum(int val)
	{
		int n = countDigits(val);		
		int sum = 0;
		
		while (val != 0) {
			sum += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return sum;				
	}
	
	public static int countDigits(int val)
	{
		if (val == 0)
			return 1;
		
		return (int)Math.log10(Math.abs(val)) + 1;
	}	
	
}

/*--------------------------------------------------------------------------------------------------------------------
	16.01.2021
	Homework-002-4. sorunun bir çözümü
	(Çalışma sorusunun verildiği tarihteki işlenmiş konular kullanılarak yazılmıştır)
	(İleride daha iyisi yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		BallFallGameApp.run();			
	}
}

class BallFallGameApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Width?");
		int width = Integer.parseInt(kb.nextLine());
		System.out.print("Height?");
		int height = Integer.parseInt(kb.nextLine());
		
		//Kontrol işlemleri yapılacak
		
		BallFallGame.play(width, height);
	}
}

class BallFallGame {
	public static void fillSpace(int begin, int end)
	{
		for (int i = begin; i < end; ++i)
			System.out.print(' ');
	}
	
	public static void fillBall(int ballIndex, int end)
	{
		fillSpace(0, ballIndex);
		System.out.print('*');
		fillSpace(ballIndex + 1, end);
	}
	
	public static boolean updateRightFlag(int ballIndex, boolean isRight, int width)
	{
		if (ballIndex == 0)
			isRight = true;
		else if (ballIndex == width - 1)
			isRight = false;
		
		return isRight;
	}
	
	public static int updateBallIndex(boolean isRight, int ballIndex)
	{
		if (isRight)
			++ballIndex;
		else
			--ballIndex;
		
		return ballIndex;
	}
	
	public static void play(int width, int height)
	{
		int ballIndex = 0;
		boolean isRight= true;
		
		for (int i = 1; i <= height; ++i) {
			System.out.print('|');
			fillBall(ballIndex, width);
			isRight = updateRightFlag(ballIndex, isRight, width);
			
			if (width != 1)
				ballIndex = updateBallIndex(isRight, ballIndex);
			
			System.out.println('|');
		}				
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Homework-002-5. sorunun bir çözümü	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println(Util.getE());								
	}
}

class Util {
	public static double getE()
	{		
		double e = 0;
		
		for (int i = 0; i < 10; ++i)
			e += 1. / NumberUtil.factorial(i);
		
		return e;
	}
}


class NumberUtil {	
	public static long factorial(int n)
	{		
		long result = 1L;
		
		for (int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün genel biçimi:
	<operand1> ? <operand2> : <operand3>
	
	operand1: boolean türden ifade olmalıdır.
	Aşağıdaki koşul operatörünün if deyimi karşılığı:
	if (a > b)
		max = a;
	else
		max = b;	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int max;
		
		max = a > b ? a : b;
		
		System.out.printf("max(%d, %d) = %d%n", a, b, max);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte b - 100 ifadesi koşul operatörünün 3. operandıdır	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int max;
		
		max = a > b ? a + 200 : b - 100;
		
		System.out.printf("max(%d, %d) = %d%n", a, b, max);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte 100 sayısı koşul operatörünün ürettiği değerden çıkartılmıştır	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int max;
		
		max = (a > b ? a + 200 : b) - 100;
		
		System.out.printf("max(%d, %d) = %d%n", a, b, max);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değer bir işleme sokulabilir	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.print("Üçüncü sayıyı giriniz:");
		int c = Integer.parseInt(kb.nextLine());

		int result;
		
		result = c + (a > b ? a : b) + 200;
		
		System.out.printf("result = %d%n", result);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değerin bir değişkene atanması okunabilirliği artırır	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());	

		int min;
		
		min = a < b ? a : b;
		
		System.out.printf("min(%d, %d) = %d%n", a, b, min);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değerin return deyiminde kullanımı okunabilirliği artırır	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());	

		int min;
		
		min = Util.min(a, b);
		
		System.out.printf("min(%d, %d) = %d%n", a, b, min);		
	}
}


class Util {
	public static int min(int a, int b)
	{
		return a < b ? a : b;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong
	metodunu NumberUtil sınıfı içerisinde yazınız ve test ediniz. 
	
	Açıklamalar:
	- Kuvvet alma işlemi için Math sınıfının pow metodunu kullanmayınız
	
	- Bir sayının her basamağının basamak sayıncı kuvvetleri alınıp toplandığında sonuç sayının kendisine eşitse, bu 
	sayı bir Armstrong sayısıdır
	Örneğin: 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153
	
	- Sayı negatif ise false döndürebilirsiniz
	
	- Test işlemini 1, 2, 3, 4, 5, 6 ve 7 basamaklı Armstrong sayılarını ekrana yazdırarak yapabilirsiniz
	
	Örnekte Koşul operatörü kullanıldığına dikkat ediniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}


class IsArmstrongTest {
	public static void run()
	{
		for (int n = -100; n <= 9999999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {
	public static boolean isArmstrong(int val)
	{				
		return val >= 0 && getDigitsPowSum(val) == val;	
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);		
		int sum = 0;
		
		while (val != 0) {
			sum += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return sum;				
	}
	
	public static int countDigits(int val)
	{		
		return val == 0 ? 1 : (int)Math.log10(Math.abs(val)) + 1;
	}	
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgisine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek metodunu yazınız
	Açıklamalar:
		- Metot geçersiz bir tarih için -1 değerine döndecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasınddaki gün sayısının 7 ile bölümünden elde edilen kalan ile 
		bulunabilir. Bu değer 0 (sıfır) için "Pazar", 1 için "Pazartesi", ..., 6 için "Cumartesi" gününe ilişkindir.
		- 1.1.1900 öncesindeki tarihler geçersiz kabul edilecektir		
		- Ekran çıktısında haftanın günü bilgisini Türkçe olarak da gösteriniz. Örneğin:
			03/01/2021 Pazar
		- Parametresi ile aldığı gün, ay ve yıl bilgisine ilişkin tarihin hafta sonu olup olmadığını test eden
		isWeekend metodunu yazınız. Metot geçerlilik kontrolü yapmayacaktır
		- Parametresi ile aldığı gün, ay ve yıl bilgisine ilişkin tarihin hafta içi olup olmadığını test eden
		isWeekday metodunu yazınız. Metot geçerlilik kontrolü yapmayacaktır
		- İleride daha iyileri yazılacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		GetDayOfYearTest.run();
	}
}

class GetDayOfYearTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Gün?");
			int day = Integer.parseInt(kb.nextLine());
			
			if (day == 0)
				break;
			
			System.out.print("Ay?");
			int month = Integer.parseInt(kb.nextLine());
			
			System.out.print("Yıl?");
			int year = Integer.parseInt(kb.nextLine());
			
			DateUtil.displayDateTR(day, month, year);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class DateUtil {	
	public static void displayDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);		
		
		switch (dayOfWeek) {
			case 0:
				System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
				break;
			case 1:
				System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
				break;
			case 2:
				System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);
				break;
			case 3:
				System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);
				break;
			case 4:
				System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
				break;
			case 5:
				System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);
				break;
			case 6:
				System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);
				break;
			default:
				System.out.println("Geçersiz tarih");
		}
		
		if (isWeekend(day, month, year)) 
			System.out.println("Bugün kurs var tekrar yaptınız mı?");
		else
			System.out.println("Hafta sonu kurs var. Tekrar yapmayı unutmayınız!!!");
	}
	
	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		return dayOfWeek == 0 || dayOfWeek == 6;
	}
	
	public static boolean isWeekday(int day, int month, int year)
	{		
		return !isWeekend(day, month, year);
	}
	
	public static int getDayOfWeek(int day, int month, int year)
	{		
		int totalDays;
		
		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;		
		
		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;		
		
		return totalDays % 7;					
	}
	
	public static int getDayOfYear(int day, int month, int year)
	{			
		return isValidDate(day, month, year) ? day + getTotalDaysByMonth(month, year) : -1;
	}	
	
	public static int getTotalDaysByMonth(int month, int year)
	{
		int totalDays = 0;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += isLeapYear(year) ? 29 : 28;			
		case 1:
			totalDays += 31;			
		}
		
		return totalDays;
			
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{
		if (day < 1 || day > 31 || month < 1 || month > 12)
			return false;
		
		int days = 31;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = isLeapYear(year) ? 29 : 28;			
		}
		
		return day <= days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0; 
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün bir kullanımı. Aşağıdaki örnekte parantez almaya gerek yoktur	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());	
		
		System.out.print("Üçüncü sayıyı giriniz:");
		int c = Integer.parseInt(kb.nextLine());

		int min;
		
		min = a < b ? a < c ? a : c : b < c ? b : c; 
		
		System.out.printf("min(%d, %d, %d) = %d%n", a, b, c, min);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek parantez konarak daha okunabilir hale getirilebilir	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());	
		
		System.out.print("Üçüncü sayıyı giriniz:");
		int c = Integer.parseInt(kb.nextLine());

		int min;
		
		min = (a < b) ? (a < c ? a : c) : (b < c ? b : c); 
		
		System.out.printf("min(%d, %d, %d) = %d%n", a, b, c, min);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün bir kullanımı	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.println(val % 2 == 0 ? "Çift" : "Tek");				
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ikinci ve üçüncü operandları void bir ifade olamaz	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		val % 2 == 0 ? Sample.foo() : Sample.bar(); //error
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek if deyimi ile yapılabilir	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0)
			Sample.foo();
		else
			Sample.bar();		
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Sample ve Mample sınıflarının foo isimli metotları bildirilmiştir. Bir problem oluşmaz. Bu
	"method overloading" değildir	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
		Mample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("Sample.foo");
	}
	
}

class Mample {
	public static void foo()
	{
		System.out.println("Mample.foo");
	}
	
}

/*--------------------------------------------------------------------------------------------------------------------
	Method overloading: Bir sınıfın içerisinde bulunan aynı isimli metotlar "overload" edilmiş olur. Yani bir sınıf
	içerisinde aynı isimde birden fazla sınıf yazılmasıdır
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
	Bir metodun erişim belirleyicisinin overload işlemine etkisi yoktur.Yani erişim belirleyici değiştirmek metodu
	farklı yapmaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int val) //error
	{
		System.out.println("Sample.foo(int)");
	}
	
	private static void foo(int val) //error
	{
		System.out.println("Sample.foo(int)");
	}	
}

/*--------------------------------------------------------------------------------------------------------------------
	Bir metodun static veya non-static olmasının overload işlemine etkisi yoktur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int val) //error
	{
		System.out.println("Sample.foo(int)");
	}
	
	public void foo(int val) //error
	{
		System.out.println("Sample.foo(int)");
	}	
}

/*--------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bilgisinin overload işlemine etkisi yoktur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static int foo(int val) //error
	{
		System.out.println("Sample.foo(int)");
		
		return 10;
	}
	
	public static void foo(int val) //error
	{
		System.out.println("Sample.foo(int)");
	}	
}

/*--------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişken isminin overload işlemine etkisi yoktur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int val) //error
	{
		System.out.println("Sample.foo(int)");	
	}
	
	public static void foo(int a) //error
	{
		System.out.println("Sample.foo(int)");
	}	
}


/*--------------------------------------------------------------------------------------------------------------------
	Bir metodun overload edilebilmesi için metodun parametre tür bilgisinin ve diziliminin (hepsine birden parametrik yapı diyelim)
	diğer aynı isimdeki metotlardan farklı olması gerekir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int a)
	{
		System.out.println("Sample.foo(int)");	
	}
	
	public static void foo(double a)
	{
		System.out.println("Sample.foo(int)");
	}	
	
	public static void foo(int a, double b)
	{
		System.out.println("Sample.foo(int, double)");
	}
	
	public static void foo(double a, int b)
	{
		System.out.println("Sample.foo(double, int)");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Bir metodun ismi ve parametrik yapısına birlikte metodun imzası denir.
	Kural: Bir sınıf içerisinde aynı imzaya sahip başka bir metot bildirimi yapılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int a) //imza: foo, int
	{
		System.out.println("Sample.foo(int)");	
	}
	
	public static void foo(double a) //foo, double
	{
		System.out.println("Sample.foo(int)");
	}	
	
	public static void foo(int a, double b) //foo, int, double
	{
		System.out.println("Sample.foo(int, double)");
	}
	
	public static void foo(double a, int b) //foo, double, int
	{
		System.out.println("Sample.foo(double, int)");
	}
	
	public static void bar(int a) //bar, int
	{
		System.out.println("Sample.bar(int)");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Bir metot çağrısında derleyicinin hangi metodun çağrılacağına karar vermesi sürecine "method overload resolution" 
	ya da yalnızca "overload resolution" denir	
---------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------
	Metot çağrısında argümanlar ile parametrelerinin türlerinin birebir uyumlu olduğu bir metot varsa o çağrılır 
	(best match)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 20;
		
		Sample.foo(a, b); //#5 çağrılır
	}
}

class Sample {
	public static void foo() // #1
	{
		System.out.println("Sample, foo");	
	}
	
	public static void foo(int a) //#2
	{
		System.out.println("Sample, foo, int");
	}	
	
	public static void foo(int a, int b) //#3
	{
		System.out.println("Sample, foo, int, int");
	}
	
	public static void foo(double a, int b) //#4
	{
		System.out.println("Sample, foo, double, int");
	}
	
	public static void foo(int a, long b) //#5
	{
		System.out.println("Sample, foo, int, long");
	}
	
	public static void bar(int a) //#6
	{
		System.out.println("Sample, bar, int");
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Tam uyum yoksa overload resolution aşağıdaki gibi yapılır:
	1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimdeki tüm metotlardır
	2. Uygun metotlar (applicable methods) belirlenir: Aday metotlar içerisindeki parametre sayısı çağrıda belirlenen
	argüman sayısı ile aynı olan VE argümanların türünden ilgili parametrelerin türüne otomatik dönüşümünün geçerli
	olduğu metotlardır
	3. En uygun metotlar (the most applicable method) belirlenir:  Uygun metotlar içerisinde en kaliteli dönüşümü
	sunan metottur. Ya da başka bir deyişle, en uygun metot öyle bir metottur ki argümanlardan parametrelere 
	yapılan dönüşümler yarışa sokulduğunda daha iyi veya daha kötü olmayan bir dönüşüm sunar.
	
	Dönüşümün kalitesi aşağıdaki gibi belirlenir:
	1. T1->T2 ve T1->T3 otomatik dönüşümlerde T2 veya T3 den biri T1 ile aynı ise aynı olan dönüşüm kalitelidir. Örneğin
		int ->int *
		int -> double 
		
	2. T1->T2 ve T1->T3 otomatik dönüşümlerde T2 den T3 'e otomatik dönüşüm var ancak T3'den T2'ye yoksa T1->T2
	dönüşümü daha kalitelidir. Örneğin:
		int -> long *
		int -> float
	ya da örneğin:
		short -> int *
		short -> double
		
	Bu aşamalardan herhangi bir tanesinde metot ya da metotlar bulunamazsa (3. aşama için bir tane metot bulunması gerekir)
	error oluşur	
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------	
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 3, 4, 5	
	3. En uygun metotlar: 3
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;
		
		Sample.foo(a, b); //#3 çağrılır
	}
}

class Sample {
	public static void foo() // #1
	{
		System.out.println("Sample, foo");	
	}
	
	public static void foo(int a) //#2
	{
		System.out.println("Sample, foo, int");
	}	
	
	public static void foo(int a, int b) //#3
	{
		System.out.println("Sample, foo, int, int");
	}
	
	public static void foo(double a, int b) //#4
	{
		System.out.println("Sample, foo, double, int");
	}
	
	public static void foo(int a, long b) //#5
	{
		System.out.println("Sample, foo, int, long");
	}
	
	public static void foo(int a, char b) //#6
	{
		System.out.println("Sample, foo, int, char");
	}
	
	public static void bar(int a) //#7
	{
		System.out.println("Sample, bar, int");
	}
}



/*--------------------------------------------------------------------------------------------------------------------	
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 4	
	3. En uygun metotlar: 4
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 10;
		short b = 20;
		
		Sample.foo(a, b); //#4 çağrılır
	}
}

class Sample {
	public static void foo() // #1
	{
		System.out.println("Sample, foo");	
	}
	
	public static void foo(int a) //#2
	{
		System.out.println("Sample, foo, int");
	}	
	
	public static void foo(int a, int b) //#3
	{
		System.out.println("Sample, foo, int, int");
	}
	
	public static void foo(double a, int b) //#4
	{
		System.out.println("Sample, foo, double, int");
	}
	
	public static void foo(int a, long b) //#5
	{
		System.out.println("Sample, foo, int, long");
	}
	
	public static void foo(int a, char b) //#6
	{
		System.out.println("Sample, foo, int, char");
	}
	
	public static void bar(int a) //#7
	{
		System.out.println("Sample, bar, int");
	}
}


/*--------------------------------------------------------------------------------------------------------------------	
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 4, 5	
	3. En uygun metotlar: 4
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 10;
		short b = 20;
		
		Sample.foo(a, b); //#4 çağrılır
	}
}

class Sample {
	public static void foo() // #1
	{
		System.out.println("Sample, foo");	
	}
	
	public static void foo(int a) //#2
	{
		System.out.println("Sample, foo, int");
	}	
	
	public static void foo(int a, int b) //#3
	{
		System.out.println("Sample, foo, int, int");
	}
	
	public static void foo(double a, int b) //#4
	{
		System.out.println("Sample, foo, double, int");
	}
	
	public static void foo(double a, long b) //#5
	{
		System.out.println("Sample, foo, double, long");
	}
	
	public static void foo(int a, char b) //#6
	{
		System.out.println("Sample, foo, int, char");
	}
	
	public static void bar(int a) //#7
	{
		System.out.println("Sample, bar, int");
	}
}


/*--------------------------------------------------------------------------------------------------------------------	
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 3, 4, 5	
	3. En uygun metotlar: yok
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;
		
		Sample.foo(a, b); //error: ambiguity: iki anlamlılık 
	}
}

class Sample {
	public static void foo() // #1
	{
		System.out.println("Sample, foo");	
	}
	
	public static void foo(int a) //#2
	{
		System.out.println("Sample, foo, int");
	}		
	
	public static void foo(long a, int b) //#3
	{
		System.out.println("Sample, foo, double, int");
	}
	
	public static void foo(int a, long b) //#4
	{
		System.out.println("Sample, foo, int, long");
	}
	
	public static void foo(int a, float b) //#5
	{
		System.out.println("Sample, foo, int, float");
	}
	
	public static void bar(int a) //#6
	{
		System.out.println("Sample, bar, int");
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	Aşağidaki metot çağrısı tam uyumludur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;
		
		Sample.foo((int)a, (float)b); 
	}
}

class Sample {
	public static void foo() // #1
	{
		System.out.println("Sample, foo");	
	}
	
	public static void foo(int a) //#2
	{
		System.out.println("Sample, foo, int");
	}		
	
	public static void foo(long a, int b) //#3
	{
		System.out.println("Sample, foo, double, int");
	}
	
	public static void foo(int a, long b) //#4
	{
		System.out.println("Sample, foo, int, long");
	}
	
	public static void foo(int a, float b) //#5
	{
		System.out.println("Sample, foo, int, float");
	}
	
	public static void bar(int a) //#6
	{
		System.out.println("Sample, bar, int");
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: yok	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		boolean b = true;
		
		Sample.foo(a, b); //error 
	}
}

class Sample {
	public static void foo() // #1
	{
		System.out.println("Sample, foo");	
	}
	
	public static void foo(int a) //#2
	{
		System.out.println("Sample, foo, int");
	}		
	
	public static void foo(long a, int b) //#3
	{
		System.out.println("Sample, foo, double, int");
	}
	
	public static void foo(int a, long b) //#4
	{
		System.out.println("Sample, foo, int, long");
	}
	
	public static void foo(int a, float b) //#5
	{
		System.out.println("Sample, foo, int, float");
	}
	
	public static void bar(int a) //#6
	{
		System.out.println("Sample, bar, int");
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	1. Aday metotlar: yok	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		boolean b = true;
		
		Sample.tar(a, b); //error 
	}
}

class Sample {
	public static void foo() // #1
	{
		System.out.println("Sample, foo");	
	}
	
	public static void foo(int a) //#2
	{
		System.out.println("Sample, foo, int");
	}		
	
	public static void foo(long a, int b) //#3
	{
		System.out.println("Sample, foo, double, int");
	}
	
	public static void foo(int a, long b) //#4
	{
		System.out.println("Sample, foo, int, long");
	}
	
	public static void foo(int a, float b) //#5
	{
		System.out.println("Sample, foo, int, float");
	}
	
	public static void bar(int a) //#6
	{
		System.out.println("Sample, bar, int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	17.01.2021
	Bilindiği gibi bir değişkenin faaliyet alanı derleme zamanına ilişkindir. Bir değişkenin bellekte yaratılması ile
	yok edilmesi arasındaki zamana değişkenin ömrü (storage duration) denir. Bu çalışma zamanına ilişkin bir kavramdır.	
	Mantıksal olarak ayrı olmasalar da, faaliyet alanı ve ömür aynı şey değildir
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------	
	Yerel değişkenler ve parametre değişkenleri stack alanında yaratılır. Yerel değişkenin ömrü akış bakımından 
	bildirildiği yerde yaratılır, bildirildiği bloğun sonunda yok edilir. Parametre değişkenleri akış bakımından 
	metot çağrısında yaratılır, metot çağrısı bittiğinde yok edilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		{
			//...
			int a; //Akış buradayken stack'de yaratıldı
			int b; //Akış buradayken stack'de yaratıldı
			
			//...
		} // a ve b yok edildi
		
		
		Sample.foo(20, 56); //Parametre değişkenleri yaratıldı ve metot çağrısı bittiğinde yok edildi
		
		//...
		
		Sample.foo(20, 56); //Parametre değişkenleri yaratıldı ve metot çağrısı bittiğinde yok edildi
	}
}

class Sample {
	public static void foo(int a, int b)
	{
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	Sınıf içerisindeki bildirimlere sınıfın elemanları (members) denir. Sınıfın elemanı bir alt program ise buna
	metot bir değişken ise veri elemanı (member variable) denir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------	
	Sınıfın içerisinde tüm metotların dışında herhangi bir yerde bildirilen değişkenlere sınıfların veri elemanları
	denir. Sınıf veri elemanları metotlarda olduğu gibi erişim belirleyiciye sahip olabilirler, veri elemanları
	static veya non-static olarak bildirilebilirler. Erişim belirleyici anlamında konusu gelene kadar bir tüm
	veri elemanlarını public olarak bildireceğiz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int a;
	
	public static void foo()
	{
		
	}
	
	private static double b;
	float c;
}

/*--------------------------------------------------------------------------------------------------------------------	
	Bir sınıf içerisinde aynı isimde birden fazla veri elemanı bildirimi geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
				
	}
}

class Sample {
	public int a; //error
	
	public static void foo()
	{
		
	}
	
	private static double a; //error
	float c;
}


/*--------------------------------------------------------------------------------------------------------------------	
	Birden fazla veri elemanı aynı türdense, static veya non-static olma durumları aynı ise ve aynı erişim belirleyicisi
	ile bildirilecekse virgül ayrılarak bildirim yapılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public int a, b, c;
	private static float x, y, z;
	
	public static void foo()
	{
		
	}	
}

/*--------------------------------------------------------------------------------------------------------------------	
	Sınıf bildirimi tür bildirimidir (user defined type)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	//...
}

class SerialPort {
	//...	
}

class Person {
	//...
}

class Student {
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	Sınıf bildirimi tür bildirimi olduğuna göre sınıf türünden değişkenler bildirilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s;
		SerialPort sp;
		Person p;
		Student st;
		
		//...				
	}
}

class Sample {
	//...
}

class SerialPort {
	//...	
}

class Person {
	//...
}

class Student {
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	Java'da türler kategori olarak iki gruba ayrılır: değer türleri (value types), referans türleri (reference types)
	
	T bir tür ismi olmak üzere T türünden bir değişken içerisinde tutulan değer bir adres ise bu durumda T bir 
	referans türüdür. Adres değilse T bir değer türüdür. Java'da yalnızca temel türler değer türleridir. Programcı
	tarafından bildirilen türler (user defined types) (sınıflar, enum, interface vs.) referans türleridir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------	
	Sınıf türünden bir değişkene referans değişken veya referans denir. 
	Anahtar Notlar: Java'da referans sözcüğü adres için de kullanılır. Örneğin bir nesnenin adresi yerine bir nesnenin
	referansı da doğrudur. Ancak buradaki referans terimi bir değişkeni değil adresi temsil eder. Referans değişken ya da
	kısa referans, içerisinde adres (referans) tutabilen bir değişkendir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s; //s referans (değişken)
		SerialPort sp; //sp referans
		Person p; // p referans
		Student st; //st referans
		
		//...				
	}
}

class Sample {
	//...
}

class SerialPort {
	//...	
}

class Person {
	//...
}

class Student {
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	Sınıf türünden bellekte ayrılan alanlara nesne denir. Nesneler heap'de yaratılır. Java'da stack'de nesne
	yaratılamaz. Java'da bir nesnenin kendisi değil adresi bir referansda tutulabilir. Bir nesneyi yaratmak için
	new operatörü kullanılır. new operatörünün kullanımının genel biçimi:
	
		new <referans tür ismi>([argümanlar]);
	
	new operatörünün ürettiği değer heap'te yaratılan nesnenin adresidir (referansıdır). Bu durumda bu operatörün
	ürettiği adres uygun bir referansa atanabilir. Uygun referans new operatörü kullanılırken yazılan referans
	türünden bir değişkendir. Yani new operatörünün ürettiği adres nesne ile aynı türden bir referansa atanabilir.
	Nesneler ilgili sınıf türünün bir örneği kabul edilir ve "instance" terimi kullanılır. Aşağıdaki ** ile belirtilen 
	deyimden sonra "s referansı **'da yaratılan nesneyi gösteriyor" duruma gelir. 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s; //s referans (değişken)	
				
		s = new Sample(); //**
		
		//...				
	}
}

class Sample {
	//...
}


/*--------------------------------------------------------------------------------------------------------------------	
	Sınıfın non-static veri elamanlarına sınıf dışından (başka bir sınıfın içinden) referans ve nokta operatörü ile
	erişilebilir. Sınıfın non-static veri elemanları her nesne için ayrıca nesnenin içerisinde yaratılır. İşte sınıf
	dışından referans ile erişilen eleman o referansın gösterdiği nesnenin elemanıdır. Her new işlemi yeni bir nesne 
	yaratmak demektir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s, k; 	
				
		s = new Sample();
		k = new Sample();
		
		s.x = 10;
		s.y = true;		
		
		k.x = 34;
		k.y = false;
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);	
		
		//...				
	}
}

class Sample {
	public int x;
	public boolean y;
	//...
}


/*--------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte s yerel değişkenine değer atanmadan kullanıldığı için error oluşur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s;
		
		s.x = 10; //error				
	}
}

class Sample {
	public int x;
	public boolean y;
	//...
}


/*--------------------------------------------------------------------------------------------------------------------	
	23.01.2021
	Farklı türden referanslar birbirine tür dönüştürme operatörü ile bile atanamazlar	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s;
		
		s = (Sample)new Mample(); //error
	}
}

class Sample {
	public int x;
	public boolean y;
	//...
}

class Mample {
	public int x;
	public boolean y;
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	Non-static veri elemanlarına nesnenin yaratılması aşamasında default değerler atanır. Default değer mantıksal
	sıfır değeridir. Örneğin int türü için sıfırken, boolean türü için false değeridir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s, k; 	
				
		s = new Sample();
		k = new Sample();
		
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);		
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);
		
		System.out.println("///////////////////");
		
		s.x = 10;
		s.y = true;		
		
		k.x = 34;
		k.y = false;
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);	
		
		//...				
	}
}

class Sample {
	public int x;
	public boolean y;
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	Bir nesnenin bellekte kapladığı alan (uzunluğu) "en az non-static veri elemanlarının toplam uzunluğu kadardır".
	Bu durumda aynı türden nesneler için aynı uzunlukta yer ayrılır. Farklı türden nesnelerin farklı veri elemanları
	olabileceğinden aynı uzunlukta yer ayrılması gerekmez
	
	Türü ne olursa olsun referansların (referans değişkenlerin) uzunlukları aynıdır. Bu da adreslenebilecek sayıları 
	tutabilecek uzunluktadır. Örneğin 64 bit bir işlemcide tüm referanslar 64 bit (8 byte) uzunluktadır.
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------	
	Aynı türden iki referansın birbirine atanması iki referansın da artık aynı nesneyi göstermeleri demektir. Bu 
	durumda hange referans ile nesneye erişildiğinin bir önemi yoktur.
	Aşağıdaki örnekte **'da k referansı göstediği nesneden kopartılmış ve s nin içerisindeki adres atandığından
	artık k ve s aynı nesneyi gösterir duruma gelmiştir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s, k; 	
				
		s = new Sample();		
		k = new Sample();		
		
		s.x = 10;
		s.y = true;		
		
		k.x = 34;
		k.y = false;
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);
		
		System.out.println("////////////////////");
		
		//...
		
		k = s;	//**	
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);
		
		System.out.println("////////////////////");
		
		
		k.x *= 2;
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);
		
		System.out.println("////////////////////");		
					
	}
}

class Sample {
	public int x;	
	public boolean y;
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	Aynı türden iki referansın birbirine atanması iki referansın da artık aynı nesneyi göstermeleri demektir. Bu 
	durumda hange referans ile nesneye erişildiğinin bir önemi yoktur	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s, k; 	
				
		s = new Sample();		
		k = new Sample();		
		
		s.x = 10;
		s.y = true;		
		
		k.x = 34;
		k.y = false;
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);
		
		System.out.println("////////////////////");
		
		//...
		
		k = s;
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);
		
		System.out.println("////////////////////");
		
		
		k.x *= 2;
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);
		
		System.out.println("////////////////////");		
		
		s = new Sample();
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
		System.out.printf("s.y = %b%n", s.y);
		System.out.printf("k.y = %b%n", k.y);
		
		System.out.println("////////////////////");					
	}
}

class Sample {
	public int x;	
	public boolean y;
	//...
}


/*--------------------------------------------------------------------------------------------------------------------	
	Anımsanacağı gibi aşağıdaki örnekte a değiştiğinde b bundan etkilenmez	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 10;
		int b;
		
		b = a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		
		++a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);					
	}
}

class Sample {
	public int x;	
	public boolean y;
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	Referans parametreli metotlar yazılabilir. Metot içerisinde referans parametresine geçilen adrese ilişkin
	nesneye erişilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Date birthDate;
		
		birthDate = new Date();
		
		birthDate.day = 10;
		birthDate.month = 9;
		birthDate.year = 1976;
		
		DateUtil.displayDate(birthDate);					
	}
}


class DateUtil {
	public static void displayDate(Date date)
	{
		System.out.printf("%02d/%02d/%04d%n", date.day, date.month, date.year);
	}
}

class Date {
	public int day, month, year;
	//...
}


/*--------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte main içerisindeki yerel değişken olan a değişkeninin değeri değişmez. Çünkü, argümanlardan
	parametrelere aktarım bir atama işlemidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{			
		int a;
		
		a = 10;
		
		Sample.foo(a);
		
		System.out.printf("a = %d%n", a); 
	}
}

class Sample {
	public static void foo(int a)
	{
		++a;		
		System.out.printf("foo->a = %d%n", a);
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	Referans parametreli metotlar aldıkları referansa ilişkin nesne üzerinde değişiklik yapabilirler. Yani
	referans parametreli metotlar ile nesnelere erişilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Date birthDate;
		
		birthDate = new Date();
		
		birthDate.day = 10;
		birthDate.month = 9;
		birthDate.year = 1976;
		
		DateUtil.displayDate(birthDate);
		
		DateUtil.changeDate(birthDate, 11, 7, 1983);
		
		DateUtil.displayDate(birthDate);
	}
}


class DateUtil {
	public static void changeDate(Date date, int day, int month, int year)
	{
		//...
		
		date.day = day;
		date.month = month;
		date.year = year;
	}
	
	public static void displayDate(Date date)
	{
		System.out.printf("%02d/%02d/%04d%n", date.day, date.month, date.year);
	}
}

class Date {
	public int day, month, year;
	//...
}


/*--------------------------------------------------------------------------------------------------------------------	
	Referansa geri dönen metotlar ile bir nesnenin referansı metodun geri dönüş değerinden elde edilebilir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Date birthDate;
		
		birthDate = DateUtil.createDate(10, 9, 1976);		
		
		DateUtil.displayDate(birthDate);
		
		DateUtil.changeDate(birthDate, 11, 7, 1983);
		
		DateUtil.displayDate(birthDate);
	}
}


class DateUtil {
	public static Date createDate(int day, int month, int year)
	{
		//...
		Date date = new Date();
		
		date.day = day;
		date.month = month;
		date.year = year;
		
		return date;
	}
	
	public static void changeDate(Date date, int day, int month, int year)
	{
		//...
		
		date.day = day;
		date.month = month;
		date.year = year;
	}
	
	public static void displayDate(Date date)
	{
		System.out.printf("%02d/%02d/%04d%n", date.day, date.month, date.year);
	}
}

class Date {
	public int day, month, year;
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın static bir veri elemanı bir tanedir. Bu elemanın kullanılabilmesi için nesne yaratılmış olması gerekmez. 
	 Sınıfın static veri elemanına sınıf dışından sınıf ismi ve nokta operatörü ile erişilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample.x = 10;
		Sample.y = true;
		
		System.out.printf("Sample.x = %d%n", Sample.x);
		System.out.printf("Sample.y = %b%n", Sample.y);
	}
}


class Sample {
	public static int x;
	public static boolean y;
	//...
}

/*----------------------------------------------------------------------------------------------------------------------	
	Sınıfın static veri elemanlarının hepsi sınıfın bir elemanı ilk kez kullanıldığında yaratılır ve programın sonuna
	kadar yok edilmez. Yani sürekli yaşar. Static veri elemanları heap'de yaratılır. Ayrıntılar ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

package csd;

class App {
	public static void main(String [] args)
	{	
		Sample.foo(); // Bu çağrı ile Sample sınıfının tüm static veri elemanları yaratılır
	}
}


class Sample {
	public static int x;
	public static boolean y;
	//...
	
	public static void foo()
	{
		//...
	}
}


/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın static veri elemanlarına da default değerler atanır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		System.out.printf("Sample.x = %d%n", Sample.x);
		System.out.printf("Sample.y = %b%n", Sample.y);
		
		Sample.x = 10;
		Sample.y = true;
		
		System.out.printf("Sample.x = %d%n", Sample.x);
		System.out.printf("Sample.y = %b%n", Sample.y);
	}
}


class Sample {
	public static int x;
	public static boolean y;
	//...
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Aşağıdaki örnekte sayaç sınıfları kullanan programcı tarafından oluşturulmuştur. Programcı sayacı artırmayı veya 
	 azaltmayı unutabilir. Ayrıca başka nesneler söz konusu olduğunda onlar için de ayrı sayaç tutacak ve uygun isimleri de
	 bulmak zorunda kalacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		GameApp.run();		
	}
}

class GameApp {
	public static void run()
	{
		int numberOfSoldiers = 0;
		int numberOfAliens = 0;		
		
		for (int i = 0; i < 20; ++i) {
			Alien alien = new Alien();
			
			//...
			++numberOfAliens;
		}		
		
		for (int i = 0; i < 10; ++i) {
			Soldier soldier = new Soldier();
			
			//...
			++numberOfSoldiers;
		}
		
		System.out.printf("Number of Aliens:%d%n", numberOfAliens);
		System.out.printf("Number of Soldiers:%d%n", numberOfSoldiers);		
		//...
	}
}

class Alien {
	public int color;
	public int numberOfArms;
	public int numberOfGuns;
	//...
}


class Soldier {
	public int title;
	public int gunType;
	//...
}

class Person {
	//....
}

class Building {
	//...
}


class Tank {
	//...
}


/*--------------------------------------------------------------------------------------------------------------------	
	 Yukarıdaki örnekte anlatılan olası problemler aşağıdaki gibi static veri elemanı kullanılarak çözülebilir.
	 Böylece aşağıdaki örnek daha basit kodlanmış olur. Detaylar gözardı edilmiştir. Burada anlatılmak istenen
	 yalnızca static veri elemanının kullanımıdır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		GameApp.run();		
	}
}

class GameApp {
	public static void run()
	{		
		for (int i = 0; i < 20; ++i) {
			Alien alien = new Alien();
			
			//...			
		}		
		
		for (int i = 0; i < 10; ++i) {
			Soldier soldier = new Soldier();
			
			//...			
		}
		
		System.out.printf("Number of Aliens:%d%n", Alien.count);
		System.out.printf("Number of Soldiers:%d%n", Soldier.count);		
		//...
	}
}

class Alien {
	public static int count;
	public int color;
	public int numberOfArms;
	public int numberOfGuns;
	//...
	
	public Alien()
	{
		++count;
	}
	//...
}


class Soldier {
	public static int count;
	public int title;
	public int gunType;
	//...
	
	public Soldier()
	{
		++count;
	}
	//...
}

class Person {
	public static int count;
	//...
}

class Building {
	public static int count;
	//...
}


class Tank {
	//...
}


/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın non-static bir veri elemanına sınıf dışından sınıf ismi ve nokta operatörü ile erişilemez. Çünkü
	 non-static bir veri elemanı bir nesneye aittir ve sınıf ismi ile hangi nesneye ait olduğu anlaşılamaz. Dolayısıyla
	 error oluşur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample.x = 10; //error	
	}
}

class Sample {
	public int x;
}


/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın static bir veri elemanına sınıf dışından referans ve nokta operatörü ile de erişilebilir. Sınıf ismi ile
	 erişmekten bir farkı yoktur. Sınıfın static veri elemanlarına bu şekilde erişim okunabilirlik açısından
	 tercih edilmemelidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s = new Sample();
		
		s.x = 10;
		
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample {
	public static int x;
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın non-static metotları sınıf dışından referans ve nokta operatörü ile çağrılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s = new Sample();
		
		s.foo();		
	}
}

class Sample {
	public void foo()
	{
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın non-static metotları sınıf dışından sınıf ismi ve nokta operatörü ile çağrılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample.foo(); //error		
	}
}

class Sample {
	public void foo()
	{
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın static metotları sınıf dışından sınıf ismi ve nokta operatörü ile çağrılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample.foo();		
	}
}

class Sample {
	public static void foo()
	{
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın static bir metodu sınıf dışından referans ve nokta operatörü ile de çağrılabilir. Sınıf ismi ile
	 çağırmaktan bir farkı yoktur. Sınıfın static metotlarının bu şekilde çağrılması okunabilirlik açısından
	 tercih edilmemelidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s = new Sample();
		
		s.foo();		
	}
}

class Sample {
	public static void foo()
	{
		//...
	}
}


/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın non-static bir metodu içerisinde aynı sınıfın non-static bir veri elemanına doğrudan erişilebilir. 
	 Doğrudan erişilen veri elemanı metot çağrısında kullanılan referansın gösterdiği nesnenin veri elemanıdır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(20);
		k.foo(10);
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
	}
}

class Sample {
	public int x;
	
	public void foo(int a)
	{
		x = a;
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Sınıfın non-static bir metodu içerisinde aynı sınıfın non-static bir metodu doğrudan çağrılabilir. 
	 Doğrudan çağrılan metot, çağıran metodu çağıran referans ile çağrılmış olur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(20);
		k.foo(10);
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
	}
}

class Sample {
	public int x;
	
	public void foo(int a)
	{
		bar(a);
	}
	
	public void bar(int a)
	{
		x = a;
	}
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Yukarıdaki iki maddenin özeti olarak, sınıfın non-static bir metodu içerisinde sınıfın non-static elemanlarına
	 doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------		
	 24.01.2021
	 Sınıfın non-static bir metodu içerisinde aynı sınıfın static veri elemanlarına doğrudan erişilebilir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(20);
		System.out.printf("Sample.x = %d%n", Sample.x);
		
		k.foo(10);		
		System.out.printf("Sample.x = %d%n", Sample.x);		
	}
}

class Sample {
	public static int x;
	
	public void foo(int a)
	{
		x = a;
	}	
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Sınıfın non-static bir metodu içerisinde aynı sınıfın static metotları doğrudan çağrılabilir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(20);
		System.out.printf("Sample.x = %d%n", Sample.x);
		
		k.foo(10);		
		System.out.printf("Sample.x = %d%n", Sample.x);		
	}
}

class Sample {
	public static int x;
	
	public void foo(int a)
	{
		x = a;
		bar(a);
	}	
	
	public static void bar(int a)
	{
		System.out.println("bar");
	}
}


/*--------------------------------------------------------------------------------------------------------------------	
	 Yukarıdaki iki maddenin özeti olarak, sınıfın non-static bir metodu içerisinde sınıfın static elemanlarına
	 doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------	
	 Yukarıdaki dört maddenin özeti olarak, sınıfın non-static bir metodu içerisinde sınıfın tüm elamanlarına 
	 (static veya non-static) doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------		
	 Sınıfın static bir metodu içerisinde aynı sınıfın non-static bir veri elemanına doğrudan erişilemez
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	
	public static void foo(int a)
	{
		x = a; //error
	}	
	
}
/*--------------------------------------------------------------------------------------------------------------------		
	 Sınıfın static bir metodu içerisinde aynı sınıfın non-static bir metodu doğrudan çağrılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	
	public static void foo(int a)
	{
		bar(a); //error
	}	
	
	public void bar(int a)
	{
		x = a;
	}	
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Yukarıdaki iki maddenin özeti olarak, sınıfın static bir metodu içerisinde sınıfın non-static elemanlarına
	 doğrudan erişilemez
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------		
	 Sınıfın static bir metodu içerisinde aynı sınıfın static bir veri elemanına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(10);
		
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample {
	public static int x;
	
	public static void foo(int a)
	{
		x = a;
	}	
	
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Sınıfın static bir metodu içerisinde aynı sınıfın static bir metodu doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(10);
		
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample {
	public static int x;
	
	public static void foo(int a)
	{
		bar(a);
	}	
	
	public static void bar(int a)
	{
		x = a;
	}	
}

/*--------------------------------------------------------------------------------------------------------------------	
	 Yukarıdaki iki maddenin özeti olarak, sınıfın static bir metodu içerisinde sınıfın static elemanlarına
	 doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------	
	 Yukarıdaki dört maddenin özeti olarak, sınıfın static bir metodu içerisinde sınıfın yalnızca static elemanlarına
	 doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------	
	 Yukarıdaki sekiz maddenin özeti olarak, sınıfın non-static bir metodu içerisinde sınıfın tüm elemanlarına
	 doğrudan erişilebilirken, sınıfın static bir metodu içerisinde sınıfın yalnızca static elemanlarına
	 doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------		
	 Aşağıdaki örnekte bar metodunun doğrudan çağrılmadığına dikkat ediniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	
	public static void foo(int a)
	{
		Sample s = new Sample();
		
		s.bar(10);
	}	
	
	public void bar(int a)
	{
		x = a;
	}	
}


/*--------------------------------------------------------------------------------------------------------------------		
	 Soru: Bir sınıfın metodunun non-static mi yoksa static mi yapacağıma nasıl karar vereceğim?
	 
	 Cevap:Bunun şöyle genel bir kuralı söylenebilir: "Bir metot non-static elemanlara doğrudan erişmeyecekse, static yapılmalıdır"
	 Bu durumda "non-static bir metot için kesinlikle non-static bir elemana doğrudan erişiyordur" anlamı çıkar.
	 Bu da okunabilirliği artırır. Aynı zamanda gerekmemesine non-static yapmak referans ile çağırmayı da gerektiridiğinden
	 anlamsız olur. Anlatılanlardan anlaşılacağı gibi "bir metodu static yapmak, non-static metotların okunabilirliğini artırır"
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------		
	 Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();
		
		p1.x = 100;
		p1.y = -200;
		
		p2.x = -100;
		p2.y = 200;
		
		p1.display();
		p2.display();
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	 Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p = new Point();
		
		p.x = 45;
		p.y = -67;
		
		p.display();		
		
		p.offset(-20, 24);
		
		p.display();
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	 Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p = new Point();
		
		p.x = 45;
		p.y = -67;
		
		p.display();		
		
		p.offset(24);
		
		p.display();
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p = new Point();
		
		p.x = 45;
		p.y = -67;
		
		p.display();		
		
		p.offset(24);
		
		p.display();
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();
		
		p1.x = 10;
		p1.y = 20;
		
		
		p2.x = 7;
		p2.y = 16;
		
		p1.display();		
		p2.display();
		
		double dist;
		
		dist = p1.distance(p2);
		
		System.out.printf("distance : %f%n", dist);
		
		int x = 7;
		int y = 16;
		
		dist = p1.distance(x, y);
		
		System.out.printf("distance : %f%n", dist);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p = new Point();		
		
		p.x = 3;
		p.y = 4;		
		
		p.display();
		
		double dist;
		
		dist = p.distance();		
		
		System.out.printf("distance : %f%n", dist);
	}
}

class Point {
	public int x;
	public int y;
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b)
	{
		return Math.sqrt((x - a) * (x - a) + (y - b) * (y - b));				
	}
	
	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void display()
	{
		System.out.printf("{x : %d, y : %d}%n", x, y);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Random sınıfının parametresiz nextInt metodu int türü sınırları içerisinde rasgele üretilmiş bir sayı döndürür
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random random = new java.util.Random();
		
		for (int i = 0; i < 10; ++i)
			System.out.println(random.nextInt());
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Random sınıfının aşağıdaki nextInt metodu [0, bound) arasında rasgele üretilmiş int türden bir sayı döndürür
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random random = new java.util.Random();
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", random.nextInt(100)); //[0, 100)
		
		System.out.println();
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Random sınıfının aşağıdaki nextInt metodu ile [min, max) aralığında rasgele sayı üretimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random random = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Minimum değeri giriniz:");
		int min = Integer.parseInt(kb.nextLine());
		
		System.out.print("Maximum değeri giriniz:");
		int max = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", random.nextInt(max - min) + min); //[0, max)
		
		System.out.println();
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	[min, max) aralığında rasgele int türden sayı üretimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random random = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Minimum değeri giriniz:");
		int min = Integer.parseInt(kb.nextLine());
		
		System.out.print("Maximum değeri giriniz:");
		int max = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", RandomUtil.nextInt(random, min, max)); //[0, max)
		
		System.out.println();
	}
}

class RandomUtil {
	public static int nextInt(java.util.Random random, int min, int max)
	{
		return random.nextInt(max - min) + min;
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Random sınıfının nextDouble metodu [0, 1) aralığında üretilmiş double türden rasgele sayı döndürür
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random random = new java.util.Random();
		
		for (int i = 0; i < 10; ++i)
			System.out.println(random.nextDouble());	
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Random sınıfının nextDouble metodu ile [min, max) aralığında değer üretimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random random = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Minimum değeri giriniz:");
		double min = Double.parseDouble(kb.nextLine());
		
		System.out.print("Maximum değeri giriniz:");
		double max = Double.parseDouble(kb.nextLine());
		
		
		for (int i = 0; i < 10; ++i)
			System.out.println(random.nextDouble() * (max - min) + min);	
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Random sınıfının nextBoolean metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random random = new java.util.Random();	
		
		for (int i = 0; i < 10; ++i)
			System.out.println(random.nextBoolean());	
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Random sınıfının nextLong metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random random = new java.util.Random();	
		
		for (int i = 0; i < 10; ++i)
			System.out.println(random.nextLong());	
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Paranın yazı gelme olasılığının yaklaşık olarak 0.5 olduğunu bulan basit bir simülasyon programı 
	yazınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CoinSimulationApp.run();	
	}
}

class CoinSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Kaç kez atmak istiyorsunuz?");
		int n = Integer.parseInt(kb.nextLine());
		
		CoinSimulation coinSimulation = new CoinSimulation();
		
		coinSimulation.run(n);
		
		System.out.printf("p = %.10f%n", coinSimulation.p);		
	}
}

class CoinSimulation {
	public double p;
	
	//...
	
	public void run(int n)
	{
		java.util.Random random = new java.util.Random();
		
		int sumOfTails = 0;
		
		for (int i = 0; i < n; ++i)
			sumOfTails += random.nextInt(2);
		
		p = (double) sumOfTails / n;
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Paranın yazı gelme olasılığının yaklaşık olarak 0.5 olduğunu bulan basit bir simülasyon programı 
	yazınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CoinSimulationApp.run();	
	}
}

class CoinSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Kaç kez atmak istiyorsunuz?");
		int n = Integer.parseInt(kb.nextLine());
		
		CoinSimulation coinSimulation = new CoinSimulation();
		
		coinSimulation.run(n);
		
		System.out.printf("p = %.10f%n", coinSimulation.p);		
	}
}

class CoinSimulation {
	public double p;
	
	//...
	
	public void run(int n)
	{
		java.util.Random random = new java.util.Random();
		
		int sumOfTails = 0;
		
		for (int i = 0; i < n; ++i)
			if (random.nextBoolean())
				++sumOfTails;
		
		p = (double) sumOfTails / n;
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: İki zar atıldığında zarların çift gelmesi (ikisi de aynı) olasılığını yaklaşık olarak hesaplayan
	basit bir simülasyon programını yazınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DiceSimulationApp.run();	
	}
}

class DiceSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Kaç kez atmak istiyorsunuz?");
		int n = Integer.parseInt(kb.nextLine());
		
		DiceSimulation diceSimulation = new DiceSimulation();
		
		diceSimulation.run(n);
		
		System.out.printf("p = %.10f%n", diceSimulation.p);		
	}
}

class DiceSimulation {
	public double p;
	
	//...
	
	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(6) + 1 == r.nextInt(6) + 1; 
	}
	
	public void run(int n)
	{
		java.util.Random random = new java.util.Random();
		
		int count = 0;
		
		for (int i = 0; i < n; ++i)
			if (areSame(random))
				++count;
		
		p = (double) count/ n;
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: İki zar atıldığında zarların çift gelmesi (ikisi de aynı) olasılığını yaklaşık olarak hesaplayan
	basit bir simülasyon programını yazınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DiceSimulationApp.run();	
	}
}

class DiceSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Kaç kez atmak istiyorsunuz?");
		int n = Integer.parseInt(kb.nextLine());
		
		DiceSimulation diceSimulation = new DiceSimulation();
		
		diceSimulation.run(n);
		
		System.out.printf("p = %.10f%n", diceSimulation.p);		
	}
}

class DiceSimulation {
	public double p;
	
	//...
	
	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(6) == r.nextInt(6); 
	}
	
	public void run(int n)
	{
		java.util.Random random = new java.util.Random();
		
		int count = 0;
		
		for (int i = 0; i < n; ++i)
			if (areSame(random))
				++count;
		
		p = (double) count/ n;
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	30.01.2021
	Tohum değeri setSeed metodu ile değiştirilebilir. Aşağıdaki örnekte her çalıştırmada aynı dizilim elde edilir	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		r.setSeed(200);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();		
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
			
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Aşağıdaki örnekte rasgele üretilen ilk 10 sayının dizilimi her çalıştırmada farklı olur. İkinci üretilen 10 sayı
	klavyeden girilen tohum değerine göre üretilir. Bu durumda örneğin kullanıcı tohum değerinin 100 olarak girdiği
	her çalıştırmada ikinci 10 sayının dizilimi aynıdır 	 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Tohum değerini giriniz:");
		long seed = Long.parseLong(kb.nextLine());
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();		
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
			
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Math sınıfının random metodu [0, 1) aralığında double türden rasgele üretilmiş bir sayı döndürür. Bu metot 
	içsel olarak hep aynı Random nesnesini kullanır. Bu metot ilk kez çağrıldığında kullandığı Random nesnesi birkez
	yaratılır ve her çağrıda bu nesne kullanılmış olur. Aşağıdaki kodun eşdeğeri:
	
	 	 java.util.Random r = new java.util.Random();
	 	 
	 	 for (int i = 0; i < 10; ++i)
			System.out.printf("%f%n", r.nextDouble());
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%f%n", Math.random());		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Math sınıfının random metodu [0, 1) aralığında double türden rasgele üretilmiş bir sayı döndürür. Bu metot 
	içsel olarak hep aynı Random nesnesini kullanır. Bu metot ilk kez çağrıldığında kullandığı Random nesnesi birkez
	yaratılır ve her çağrıda bu nesne kullanılmış olur. Aşağıdaki kodun eşdeğeri:
	
	 	 java.util.Random r = new java.util.Random();
	 	 
	 	 for (int i = 0; i < 10; ++i)
			System.out.printf("%f%n", r.nextDouble());
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%f%n", Math.random());		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Math sınıfının random metodu ile [min, max) aralığında double türden rasgele sayı üretimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("min değerini giriniz:");
		double min = Double.parseDouble(kb.nextLine());
		
		System.out.print("max değerini giriniz:");
		double max = Double.parseDouble(kb.nextLine());
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%f%n", Math.random() * (max - min) + min);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Math sınıfının random metodu ile [min, max) aralığında int türden rasgele sayı üretimi
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("min değerini giriniz:");
		int min = Integer.parseInt(kb.nextLine());
		
		System.out.print("max değerini giriniz:");
		int max = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%d ", (int)(Math.random() * (max - min) + min));
		
		System.out.println();
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Aşağıdaki kodda [min, max) aralığında rasgele int türden sayılar üretilmiştir. Şüphesiz parametreli nextInt
	kullanılmak daha iyidir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		System.out.print("min değerini giriniz:");
		int min = Integer.parseInt(kb.nextLine());
		
		System.out.print("max değerini giriniz:");
		int max = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%d ", Math.abs(r.nextInt()) % (max - min) + min);
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da nesne yaratılması adımları:
	1. Bellekte yer ayrılır
	2. non-static veri elemanlarına (final olmayan) default değerler atanır
	3. constructor (ctor) çağrılır
	
	Bu üç aşamanın sonunda new operatörünün ürettiği değer yani nesnenin adresi elde edilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	ctor aşağıdaki özelliklere sahip bir metottur:
	- Sınıfı yazan programcı sınıfa hiçbir ctor yazmazsa sınıfın parametresi ctor'u (default ctor) derleyici 
	tarafından içi boş ve public olarak yazılır
	
	- Sınıfı yazan programcı sınıfa en az bir tane ctor yazarsa default ctor derleyici tarafından yazılmaz. Artık
	default ctor yazıp yazmayacağına programcı karar verecektir
	
	- Sınıfın ctor'u sınıf ismi ile aynı isimde olan ve geri dönüş değeri kavramı olmayan bir metottur. Geri dönüş 
	değeri bilgiis yazılmaz. void da yazılmaz. void yazıldığında error oluşmaz. Ancak bu ctor anlamına gelmez.
	Yapılmamlıdır
	
	- ctor overload edilebilir (constructor overloading)
	
	- ctor non-static bir metottur
	
	- ctor new operatörü ile nesne yaratılması sırasında çağrılır. Hangi ctor'un çağrılacağı derleme zamanında 
	"method overload resolution" kuralları kullanılarak belirlenir
	
	- ctor'dan önce non-static ve final olmayan veri elemanlarına default değerler atanmış olur
	
	- Programcı ctor çağıramaz. Programcı new operatörü ile ilgili ctor'un ÇAĞRILACAĞI kodun derleyici tarafından
	üretilmesini sağlar 
	
	- ctor içerisinde return tek başına cto'u sonlandırmak için kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------		
	Nesne yaratılması sırasında çağrılacak ctor 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s1 = new Sample();
		Sample s2 = new Sample(10);
		Sample s3 = new Sample(3.4);
		Sample s4 = new Sample(20, 45L);
		Sample s5 = new Sample('a', 45L);		
				
		//...		
	}
}

class Sample {
	public Sample()
	{
		System.out.println("Sample()");		
	}
	
	public Sample(int a)
	{
		System.out.println("Sample(int)");		
	}
	
	public Sample(double a)
	{
		System.out.println("Sample(double)");		
	}
	
	public Sample(int a, long b)
	{
		System.out.println("Sample(int, long)");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	ctor non-static bir mettottur. Aşağıdaki örnekte doğrudan erişilen x bu ctor ile yaratılan nesnenin x'i olur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s = new Sample(10);
		
		System.out.printf("s.x = %d%n", s.x);				
				
		//...		
	}
}

class Sample {
	public int x;
	
	public Sample(int a)
	{
		x = a;				
	}
	
}

/*--------------------------------------------------------------------------------------------------------------------		
	ctor çağrılmadan önce non-static veri elemanlarına default değerler atanmış olur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s1 = new Sample(10);
		Sample s2 = new Sample();
		Sample s3 = new Sample(34);
		
		//...						
	}
}

class Sample {
	public int x;
	public boolean y;
	
	public Sample()
	{
		System.out.println("Sample()");
		System.out.printf("x = %d%n", x);
		System.out.printf("b = %b%n", y);
	}	
	
	public Sample(double a)
	{
		System.out.println("Sample(double)");
		System.out.printf("x = %d%n", x);
		System.out.printf("b = %b%n", y);
	}
	
	public Sample(int a)
	{
		System.out.println("Sample(int)");
		System.out.printf("x = %d%n", x);
		System.out.printf("b = %b%n", y);
	}
	
}

/*--------------------------------------------------------------------------------------------------------------------		
	Aşağıdaki örnekte Sample sınıfını yazan programcı default ctor'u yazmadığı için ** ile bilirtilen ifadede
	error oluşur. Default ctor'un yazılması artık sınıfı yazan programcının kararıdır. Bu karar sınıfın ne olduğuna
	göre değişebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s;
		
		s = new Sample(); //error:**
		
	}
}

class Sample {		
	public Sample(int a)
	{
		System.out.println("Sample(int)");		
	}
	
	//
	
}

/*--------------------------------------------------------------------------------------------------------------------		
	ctor içerisinde veri elemanlarına değer atanması tipik yapılan durumlardandır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s;
		
		s = new Sample(-10, true);
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("s.y = %b%n", s.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	public Sample(int a, boolean b)
	{
		x = Math.abs(a);
		y = b;
	}
	
	//	
}

/*--------------------------------------------------------------------------------------------------------------------		
	ctor içerisinde return istenirse tek başına kullanılabilir. Bu durumda ctor sonlandırılmış olur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Sample s1, s2;
		
		s1 = new Sample(10);
		s2 = new Sample(-20);
		
		System.out.printf("s1.x = %d%n", s1.x);
		System.out.printf("s2.x = %d%n", s2.x);		
	}
}


class Sample {
	public int x;
	
	public Sample(int a)
	{
		if (a >= 0)
			return;
		
		x = -a;
		//...
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Random sınıfının tohum değeri parametreli ctor'u
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Random r = new java.util.Random(100);
		
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%d ", r.nextInt(100));
		
		System.out.println();
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Anahtar Notlar: Sınıfın yazan programcı bir ctor yazarsa default ctor yazıp yazmayacağına yönelik kararı sınıfa
	göre verir. Bu durumda şöyle bir basit soru sorulabilir: "Bu sınıf türünden bir nesnenin default durumu var m?"
	Örneğin Random sınıfının default ctor'u bu nesnenin default durumudur. Yani tohum değerini her çağrırmada farklı
	verecek şekilde nesnenin yaratılmasını sağlamaktadır. Ancak bazı özel durumlarda sınıfı kullanan başka sınıflar
	default ctor zorunluluğu isteyebilir. Bu durumda programcı sınıf için default ctor'u yazar
---------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------		
	Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p;
		
		p = new Point(100, 100);		
		
		p.display();
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p;
		
		p = new Point();		
		
		p.display();
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p;
		
		p = new Point(100);		
		
		p.display();
	}
}

class Point {
	public int x;
	public int y;
	
	public Point()
	{	
	}
	
	public Point(int a)
	{
		x = a;		
	}		
	
	public Point(int a, int b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b)
	{
		return Math.sqrt((x - a) * (x - a) + (y - b) * (y - b));				
	}
	
	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void display()
	{
		System.out.printf("{x : %d, y : %d}%n", x, y);
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Complex sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z;
		
		z = new Complex(3, 4);
		
		z.display();		
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Complex sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z;
		
		z = new Complex();
		
		z.display();		
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Complex sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z;
		
		z = new Complex(3, 4);
		
		z.display();		
		
		System.out.printf("Norm:%f%n", z.getNorm());
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Complex sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1, z2;
		Complex z;
		
		z1 = new Complex(3, 4);
		z2 = new Complex(-7.8, 9);
		
		z1.display();		
		z2.display();
		
		z = z1.add(z2); // z1 + z2 temsili
		
		z.display();
		
		z = z1.add(3.4); //z1 + 3.4 temsili
		
		z.display();
		
		z = Complex.add(3.4, z1); //3.4 + z1 temsili
		
		z.display();
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Complex sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1, z2;
		Complex z;
		
		z1 = new Complex(3, 4);
		z2 = new Complex(-7.8, 9);
		
		z1.display();		
		z2.display();
		
		z = z1.subtract(z2); // z1 - z2 temsili
		
		z.display();
		
		z = z1.subtract(3.4); //z1 - 3.4 temsili
		
		z.display();
		
		z = Complex.subtract(3.4, z1); //3.4 - z1 temsili
		
		z.display();
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Complex sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Complex z, conjugate;
		
		z = new Complex(3, 4);
		conjugate = z.getConjugate();
		
		z.display();
		conjugate.display();		
	}
}

class Complex {
	public static Complex add(double a1, double b1, double a2, double b2) //ileride gizlenecek
	{		
		return new Complex(a1 + a2, b1 + b2);
	}
	
	public static Complex subtract(double a1, double b1, double a2, double b2) //ileride gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public double re;
	public double im;
	
	public Complex()
	{		
	}	
	
	public Complex(double a)
	{
		re = a;
	}
	
	public Complex(double a, double b)
	{
		re = a;
		im = b;
	}
	
	public double getNorm()
	{
		return Math.sqrt(re * re + im * im);
	}
	
	public Complex getConjugate()
	{
		return new Complex(re, -im);		
	}
	
	//add methods
	public Complex add(Complex other)
	{
		return add(re, im, other.re, other.im);						
	}
	
	public Complex add(double val)
	{
		return add(re, im, val, 0);
	}
	
	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.re, z.im);
	}
	
	//subtract methods
	public Complex subtract(Complex other)
	{
		return subtract(re, im, other.re, other.im);						
	}
	
	public Complex subtract(double val)
	{
		return subtract(re, im, val, 0);
	}
	
	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.re, z.im);
	}
	
	public void display()
	{
		System.out.printf("|%.2f + %.2f * i| = %f%n", re, im, getNorm());
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	31.01.2021
	Derleyici bir String atomu gördüğünde şöyle bir kod üretir: "Çalışma zamanı sırasında String türden bir nesne yarat,
	karakterleri bu nesneye aktar ve o nesnenin referansını ver" 
	
	print ve println metotlarınıın String parametreleri overload'ları argüman olarak aldıkları String referansına 
	ilişkin yazıyı ekrana basarlar
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s;
		
		s = "ankara";
		
		System.out.println(s);
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	printf metodunda s format karakteri ile String referansına ilişkin yazı formatlanıp ekrana basılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s;
		
		s = "ankara";
		
		System.out.printf("Şehir:%s%n", s);
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Scanner sınıfının nextLine metodu klavyeden bir yazı alınabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();	
		
		System.out.printf("Yazı:%s%n", s);
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	immutable sınıf: Bir nesnenin bilgileri bir kez veriliyor ve bir daha değiştirilemiyorsa o nesneye ilişkin 
	sınıfa "immutable sınıf" denir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------		
	Aşağıdaki örnekte Sample sınıfı türünden bir nesnenin veri elemanı değiştirilebilir. Yani nesnenin içeriği 
	değiştirilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s;
		
		s = new Sample(10);
		
		System.out.printf("s.x = %d%n", s.x);
		
		++s.x;
		
		System.out.printf("s.x = %d%n", s.x);
		
		s.setX(4);
		
		System.out.printf("s.x = %d%n", s.x);		
	}
}


class Sample {
	public int x;
	
	public Sample(int a)
	{
		x = a;
	}
	
	public void setX(int a)
	{
		x = a * 2;
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfı immutable bir sınıftır. Yani String nesnesine ilişkin yazı üzerinde değişiklik yapılamaz. Yazı 
	üzerinde değişiklik yapan metotlar, örneğin yazının tamamını büyük harfe çeviren metot tamamı büyütülmüş 
	harflerden oluşan yeni bir String nesnesinin referansını döndürür
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının toUpperCase metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		String upper = s.toUpperCase();
		
		System.out.println(s);
		System.out.println(upper);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının toLowerCase metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		String lower = s.toLowerCase();
		
		System.out.println(s);
		System.out.println(lower);
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Aşağıdaki örnekte mantıksal olarak değiştirilmiş bir yazı ile akışın devam edeceği bir kod yazılmıştır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		s = s.toLowerCase();
		
		System.out.println(s);		
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının length isimli metodu ile yazının karakter sayısı elde edilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		System.out.printf("Length:%d%n", s.length());		
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının charAt isimli metodu ile herhangi bir indeksteki karakter elde edilebilir. Indeks numarası
	sıfır değerinden başlar
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		int length = s.length();
		
		for (int i = 0; i < length; ++i)
			System.out.printf("%c ", s.charAt(i));
		
		System.out.println();
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının charAt metoduna pozitif ya da negatif bakımdan sınırlar dışında bir indeks numarası verilmesi
	durumunda exception oluşur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		char ch = s.charAt(5);
		
		System.out.printf("ch = %c%n", ch);
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	İki tane iki tırnağın yanyana yazılmasıyla yaratılan String'e boş string (empty string) denir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		String s = "";
		
		System.out.printf("Length:%d%n", s.length());
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Aynı türden iki referansın == veya != operatörleri ile karşılaştırılması adres karşılaştırmasıdır. Yani ==
	operatörü ile iki referansın karşılaştırılması durumunda iki referans da aynı nesneyi gösteriyorsa true üretilir.
	Benzer şekilde != operatörü ile karşılaştırma durumunda iki referans farklı nesneleri gösteriyorsa true değer
	üretilir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s1 = new Sample(10);
		Sample s2 = s1; //new Sample(10);
		
		if (s1 == s2)
			System.out.println("Aynı nesneyi gösteriyorlar");
		else
			System.out.println("Farklı nesneleri gösteriyorlar");
		
	}
}

class Sample {
	public int x;
	
	public Sample(int a)
	{
		x = a;
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Yazıların eşitlik karşılaştırması == ve != operatörleri ile yapılamaz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		if (s1 == s2) //Adres karşılaştırması yapar
			System.out.println("Aynı yazı");
		else
			System.out.println("Farklı yazılar");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Yazıların eşitlik karşılaştırması equals metodu ile yapılabilir. equals metodu büyük-küçük harf duyarlı
	 karşılaştırma yapar
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();	
		
		if (s1.equals(s2))
			System.out.println("Aynı yazı");
		else
			System.out.println("Farklı yazılar");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının equalsIgnoreCase metodu ile büyük-küçük harf duyarsız karşılaştırma yapılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();	
		
		if (s1.equalsIgnoreCase(s2))
			System.out.println("Aynı yazı");
		else
			System.out.println("Farklı yazılar");		
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının yazı içerisinde karakter arayan indexOf metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "Bugün hava çok güzel. Fakat bu çok güzel havada dışarı çıkamıyoruz";
		char ch = 'ç';
		
		int index = s.indexOf(ch);
		
		System.out.printf("Index:%d%n", index);
		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının yazı içerisinde karakter arayan indexOf metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "Bugün hava çok güzel. Fakat bu çok güzel havada dışarı çıkamıyoruz";
		char ch = 'ç';
		
		int index = s.indexOf(ch, 12);
		
		System.out.printf("Index:%d%n", index);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının yazı içerisinde yazı arayan indexOf metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "Bugün hava çok güzel. Fakat bu çok güzel havada dışarı çıkamıyoruz";
		String str = "güzel";
		
		int index = s.indexOf(str);
		
		System.out.printf("Index:%d%n", index);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının yazı içerisinde yazı arayan indexOf metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "Bugün hava çok güzel. Fakat bu çok güzel havada dışarı çıkamıyoruz";
		String str = "güzel";
		
		int index = s.indexOf(str, 16);
		
		System.out.printf("Index:%d%n", index);		
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının lastIndexOf metotları
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "Bugün hava çok güzel. Fakat bu çok güzel havada dışarı çıkamıyoruz";
		String str = "güzel";
		
		int index = s.lastIndexOf(str);
		
		System.out.printf("Index:%d%n", index);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisiden kaç tane olduğunu döndüren
	countStringIgnoreCase isimli metodu StringUtil sınıfı içerisinde yazınız ve test ediniz. 
	Örnek:
	aaa yazısı içerisinde  aa dan 2 tane var 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		CountStringTest.run();	
	}
}

class CountStringTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("quit".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			
			System.out.printf("Birinci yazı içerisinde ikinci yazıdan %d tane var%n", count);
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
	
}

class StringUtil {
	public static int countString(String s1, String s2)
	{
		int count = 0;
		int index = 0;
		
		while ((index = s1.indexOf(s2, index)) != -1) {
			++count;
			++index;
		}		
		
		return count;	
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisiden kaç tane olduğunu döndüren
	countStringIgnoreCase isimli metodu StringUtil sınıfı içerisinde yazınız ve test ediniz. 
	Örnek:
	aaa yazısı içerisinde  aa dan 2 tane var 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		CountStringTest.run();	
	}
}

class CountStringTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("quit".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			
			System.out.printf("Birinci yazı içerisinde ikinci yazıdan %d tane var%n", count);
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
	
}

class StringUtil {
	public static int countString(String s1, String s2)
	{
		int count = 0;
		int index = -1;
		
		while ((index = s1.indexOf(s2, index + 1)) != -1)
			++count;	
		
		return count;	
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisiden kaç tane olduğunu döndüren
	countStringIgnoreCase isimli metodu StringUtil sınıfı içerisinde yazınız ve test ediniz. 
	Örnek:
	aaa yazısı içerisinde  aa dan 2 tane var 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		CountStringTest.run();	
	}
}

class CountStringTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("quit".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			
			System.out.printf("Birinci yazı içerisinde ikinci yazıdan %d tane var%n", count);
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
	
}

class StringUtil {
	public static int countString(String s1, String s2)
	{
		int count = 0;		
		
		for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
			;
		
		return count;	
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisiden kaç tane olduğunu döndüren
	countStringIgnoreCase isimli metodu StringUtil sınıfı içerisinde yazınız ve test ediniz. 
	Örnek:
	aaa yazısı içerisinde  aa dan 2 tane var 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		CountStringTest.run();	
	}
}

class CountStringTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("quit".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			
			System.out.printf("Birinci yazı içerisinde ikinci yazıdan %d tane var%n", count);
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
	
}

class StringUtil {
	public static int countString(String s1, String s2)
	{
		int count = 0;		
		
		for (int index = 0; (index = s1.indexOf(s2, index)) != -1; ++count, ++index)
			;
		
		return count;	
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisiden kaç tane olduğunu döndüren
	countStringIgnoreCase isimli metodu StringUtil sınıfı içerisinde yazınız ve test ediniz. 
	Örnek:
	aaa yazısı içerisinde  aa dan 2 tane var 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		CountStringTest.run();	
	}
}

class CountStringTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("quit".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countStringIgnoreCase(s1, s2);
			
			System.out.printf("Birinci yazı içerisinde ikinci yazıdan %d tane var%n", count);
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
	
}

class StringUtil {
	public static int countString(String s1, String s2)
	{
		int count = 0;		
		
		for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
			;
		
		return count;	
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());	
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	 Bir String'in boş String olup olmadığının karşılaştırılması (kötü yöntem)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		EmptyStringTest.run();	
	}
}

class EmptyStringTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(s.length() == 0 ? "Boş string" : "Boş string değildir");			
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
	
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Bir String'in boş String olup olmadığının karşılaştırılması (kötü yöntem)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		EmptyStringTest.run();	
	}
}

class EmptyStringTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(s.equals("") ? "Boş string" : "Boş string değildir");			
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
	
}


/*--------------------------------------------------------------------------------------------------------------------		
	 Bir String'in boş String olup olmadığının karşılaştırılması (en iyi yöntem)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		EmptyStringTest.run();	
	}
}

class EmptyStringTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(s.isEmpty() ? "Boş string" : "Boş string değildir");			
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}	
}


/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının trim metodu baştaki ve sondaki boşluk (whitespace) karakterlerinin atılmış olduğu yeni bir String
	 referansına döner
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		TrimTest.run();	
	}
}

class TrimTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;			
			
			System.out.printf("[%s]%n", s.trim());			
			System.out.printf("[%s]%n", s);
		}	
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
	
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Sınıf Çalışması: Klavyeden bir kullanıcı adı ve şifre isteyen basit bir ATM uygulamasının bir parçası olan
	 aşağıda açıklanan programı yazınız:
	 Açıklamalar:
	 - Kullanıcı ve şifre 3(üç) kez denenebilecektir
	 - Denemeler sırasında doğru giriş yapılırsa "Giriş başarılı", 3 kez denemede de yanlış olursa 
	 "Giriş başarısız. Artık deneme hakkınız bitti" mesajı verilecektir
	 - Kullanıcı adı ve şifrenin doğruluğu program içerisinde belirlenen bir kullanıcı adı ve şifre ile yapılacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		ATMApp.run(3);	
	}
}

class ATMApp {
	public static void doWorkForSuccess()
	{
		System.out.println("Giriş başarılı");
		//...
	}
	
	public static void doWorkForFail()
	{
		System.out.println("Giriş başarısız. Artık deneme hakkınız bitti");
		//...
	}
	
	public static void run(int tryNum)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		ATMCard card = new ATMCard();
		
		int i;		
		
		for (i = 0; i < tryNum; ++i) {
			System.out.print("Kullanıcı adını giriniz:");
			String username = kb.nextLine();
			
			System.out.print("Şifreyi giriniz:");
			String password = kb.nextLine();
			
			if (card.isValid(username, password))
				break;
			
			if (i != tryNum - 1)
				System.out.printf("Giriş başarısız %d hakkınız kaldı%n", tryNum - i - 1);
		}
		
		if (i != 3)
			doWorkForSuccess();
		else
			doWorkForFail();		
	}
}


class ATMCard {
	public String username;
	public String password;
	//...
	
	public ATMCard()
	{	
		username = "test";
		password = "1234";
	}
	
	public boolean isValid(String uname, String passwd)
	{
		return username.equals(uname) && password.equals(passwd);
	}
	//...
}

/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının concat metodu ile yazı birleştirmesi (concatanation) yapılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s1 = "istanbul";
		String s2 = "ankara";		
		String s;
		
		s = s1.concat(s2);
		
		System.out.println(s);				
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	 Aşağıdaki örneği inceleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s1 = "istanbul";
		String s2 = "ankara";		
		String s;
		
		s = s1.concat("-").concat(s2);
		
		System.out.println(s);				
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Aşağıdaki örneği inceleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s1 = "istanbul";
		String s2 = "ankara";		
		String s;
		
		s = s1.concat("-").concat(s2).toUpperCase();
		
		System.out.println(s);				
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Aşağıdaki örneği inceleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s1 = "istanbul";
		String s2 = "ankara";		
		String s;
		
		s = s1.concat("-".concat(s2)).toUpperCase();
		
		System.out.println(s);				
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Aşağıdaki örneği inceleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s1 = "istanbul";
		String s2 = "ankara";		
		String s;
		
		s = s1 + "-" + s2;
		
		System.out.println(s);				
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	 + operatörünün operandlarından biri String türündense diğer operandının String karşılığı elde edilerek
	 birleştirme işlemi yapılır. Bu işlem için derleyici bir kod üretir. İleride ele alınacaktır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Derece değerini giriniz:");
		double degree = Double.parseDouble(kb.nextLine());

		String prefix = "Bugun hava ";
		String postfix = " derece";
		String message = prefix + degree + postfix;
		
		System.out.println(message);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Aşağıdaki örnekte println metodu birleştirilmiş yazıyı ekrana basar
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Derece değerini giriniz:");
		double degree = Double.parseDouble(kb.nextLine());	
		
		
		System.out.println("Bugün hava " + degree + " derece");
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Sınıf Çalışması: Parametresi ile aldığı bir yazının tersini döndüren reverse isimli metodu StringUtil sınıfı
	 içerisinde yazınız ve metodu test ediniz
	 (İleride daha iyisi yazılacaktır) 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		ReverseTest.run();
	}
}

class ReverseTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			System.out.printf("Yazının tersi:%s%n", StringUtil.reverse(s));
			
			if ("quit".equals(s))
				break;			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil {
	public static String reverse(String s)
	{
		String str = "";
		
		for (int i = s.length() - 1; i >= 0; --i)
			str += s.charAt(i);
		
		return str;
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	 String sınıfının substring metodu 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "ankara";
		
		System.out.println(s.substring(2)); //kara
		System.out.println(s.substring(2, 5)); //[2, 5) -> kar
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	  String sınıfının substring metoduna beginIndex olarak yazının uzunluğu verilirse boş string elde edilir.
	  Yazının uzunluğundan daha büyük bir değer verilmesi durumunda exception oluşur
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "ankara";
		
		System.out.println(s.substring(s.length()).isEmpty() ? "Boş string" : "Boş string değil");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	  String sınıfının substring metoduna beginIndex ve endIndex değerleri aynı verilirse boş string elde edilir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "ankara";
		
		System.out.println(s.substring(2, 2).isEmpty() ? "Boş string" : "Boş string değil");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	  String sınıfının substring metoduna beginIndex ve endIndex değerleri aynı verilirse boş string elde edilir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s = "ankara";
		
		System.out.println(s.substring(2, 1).isEmpty() ? "Boş string" : "Boş string değil");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	  String sınıfının startsWith metodu 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Web adresini giriniz:");
		String address = kb.nextLine();
		
		if (!address.startsWith("http://"))
			address = "http://" + address;
		
		System.out.println(address);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	  String sınıfının endsWith metodu 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Email adresini giriniz:");
		String email = kb.nextLine();
		
		if (!email.endsWith(".com"))
			email += ".com";
		
		System.out.println(email);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	06.02.2021
	Sınıf Çalışması: Klavyeden quit girilene kadar alınan yazıların arasında - karakteri olacak şekilde birleştirilmiş
	bir String oluşturan programı yazınız.
	Örneğin:
	ankara istanbul ve izmir girilirse
	ankara-istanbul-izmir  
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		ConcatWithHyphenApp.run();		
	}
}

class ConcatWithHyphenApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Yazıları girmeye başlayınız:");
		
		String str = "";
		String s;
		
		while (!(s = kb.nextLine()).equals("quit")) {
			if (s.trim().isEmpty())
				continue;
			
			str += s + "-";					
		}
		
		str = str.isEmpty() ? str : str.substring(0, str.length() - 1);
		
		System.out.println(str);			
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Klavyeden quit girilene kadar alınan yazıların arasında - karakteri olacak şekilde birleştirilmiş
	bir String oluşturan programı yazınız.
	Örneğin:
	ankara istanbul ve izmir girilirse
	ankara-istanbul-izmir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		ConcatWithHyphenApp.run();		
	}
}

class ConcatWithHyphenApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Yazıları girmeye başlayınız:");
		
		String str = "";
		
		
		for (;;) {
			String s = kb.nextLine();
			
			if (s.trim().isEmpty())
				continue;
			
			if (s.equals("quit"))
				break;
			
			str += s + '-';			
		}		
		
		str = str.isEmpty() ? str : str.substring(0, str.length() - 1);
		
		System.out.println(str);			
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Klavyeden quit girilene kadar alınan yazıların arasında - karakteri olacak şekilde birleştirilmiş
	bir String oluşturan programı yazınız.
	Örneğin:
	ankara istanbul ve izmir girilirse
	ankara-istanbul-izmir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		ConcatWithHyphenApp.run();		
	}
}

class ConcatWithHyphenApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		System.out.println("Yazıları girmeye başlayınız:");
		
		String str = "";		
		
		for (;;) {
			String s = kb.nextLine();
			
			if (s.trim().isEmpty())
				continue;
			
			if (s.equals("quit"))
				break;
			
			if (!str.isEmpty())
				str += '-';
			
			str += s;			
		}		
		
		System.out.println(str);			
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Character sınıfının isXXX metotları
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		int countWhitespaces = 0, countLetters = 0, countDigits = 0;
		int length = s.length();
		
		for (int i = 0; i < length; ++i) {
			char ch = s.charAt(i);
			
			if (Character.isWhitespace(ch))
				++countWhitespaces;
			else if (Character.isLetter(ch))
				++countLetters;
			else if (Character.isDigit(ch))
				++countDigits;
		}
		
		System.out.printf("Boşluk sayısı:%d%n", countWhitespaces);
		System.out.printf("Harf sayısı:%d%n", countLetters);
		System.out.printf("Rakam sayısı:%d%n", countDigits);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Character sınıfının toXXX metotları
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();		
		int length = s.length();
		
		for (int i = 0; i < length; ++i) {
			char ch = s.charAt(i);
			
			if (!Character.isLetter(ch))
				continue;
			
			if (Character.isUpperCase(ch))
				ch = Character.toLowerCase(ch);
			else
				ch = Character.toUpperCase(ch);
			
			System.out.print(ch);
		}				
		
		System.out.println();
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı bir yazının ilk harfi büyük geri kalan tüm harfleri küçük olacak harf karakteri
	dışındaki karakterlerin aynen bırakıldığı yazıyı döndüren capitalize isimli metodu yazınız ve test ediniz.
	Örnek: buGün haVa ÇOK güzeL. -> Bugün hava çok güzel.
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		CapitalizeTest.run();
	}
}

class CapitalizeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			System.out.printf("[%s]%n", StringUtil.capitalize(s));
			
			if ("quit".equals(s))
				break;			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}


class StringUtil {
	public static String capitalize(String s)
	{		
		return s.isEmpty() ? s : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı bir yazınızn sadece başındaki boşluk karakterlerini atan trimLeading ile
	sadece sonundaki boşluk karakterlerini atan trimTrailing isimli metotları yazınız.
	Dikkat: Aşağıdaki örnekte döngü deyimlerinin koşul ifadelerinde && operatörünün kısa devre davranışından 
	yararlanılmıştır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		TrimLeadingTrailingTest.run();
	}
}

class TrimLeadingTrailingTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.printf("[%s]%n", s);						
			System.out.printf("[%s]%n", StringUtil.trimLeading(s));
			System.out.printf("[%s]%n", StringUtil.trimTrailing(s));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}


class StringUtil {
	public static String trimLeading(String s)
	{	
		int i;
		int length = s.length();
		
		for (i = 0; i < length && Character.isWhitespace(s.charAt(i)); ++i)
			;
		
		return s.substring(i);
	}
	
	public static String trimTrailing(String s)
	{
		int i;
		
		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;
		
		return s.substring(0, i + 1);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfına Java 11 ile birlikte strip, stripTrailing ve stripLeading metotları eklenmiştir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		StripLeadingTrailingTest.run();
	}
}

class StripLeadingTrailingTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.printf("[%s]%n", s);						
			System.out.printf("[%s]%n", s.strip()); //Since Java 11
			System.out.printf("[%s]%n", s.stripLeading()); //Since Java 11
			System.out.printf("[%s]%n", s.stripTrailing()); //Since Java 11
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfına Java 11 ile birlikte isBlank metodu eklenmiştir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		IsBlankTest.run();
	}
}

class IsBlankTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			System.out.println(s.isBlank() ? "Yazı boş geçilemez" : "Yazı:" + s); //Since Java 11			
			
			if ("quit".equals(s))
				break;		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfına Java 11 ile birlikte repeat metodu eklenmiştir 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		RepeatTest.run();
	}
}

class RepeatTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();					
			
			if ("quit".equals(s))
				break;		
			
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			System.out.println(s.repeat(count));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının repeat metodu 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		char ch = 'c';
		
		System.out.println((ch + "").repeat(10)); //Since Java 11
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Aşağıda açıklanan metotları yazınız ve test ediniz:
		public static String padLeading(String s, int length, char ch);
		public static String padLeading(String s, int length);
		public static String padTrailing(String s, int length, char ch);
		public static String padTrailing(String s, int length);
	Açıklamalar:
	- padLeading metodunun 3 parametreli overload'u ikinci parametresi aldıuğı length uzunluğu birinci parametresi
	ile aldığı yazıdan büyükse yazıyı soldan üçüncü parametresi ile aldığı karakter ile doldurulmuş yeni bir String
	referansına döner.
	Örneğin:
	padLeading("ankara", 11, 'x'); çağrısı
	
	xxxxxankara
	
	yazısını döndürecektir.
	
	- length yazıdan küçük veya eşitse aynı referans döndürülecektir
	
	- padLeading metodunun 2 parametreli overload'u yazıyı soldan space karakteri ile dolduracaktır
	
	- padTrailing metotları sağdan dolduracak şekilde padLeading ile benzer çalışacaktır
	
	(Java 11+ için yazılmış versiyon)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PadLeftRightTest.run();
	}
}


class PadLeftRightTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();					
			
			if ("quit".equals(s))
				break;		
			
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			System.out.printf("[%s]%n", s);
			System.out.printf("[%s]%n", StringUtil.padLeading(s, count, 'x'));
			System.out.printf("[%s]%n", StringUtil.padLeading(s, count));
			System.out.printf("[%s]%n", StringUtil.padTrailing(s, count, 'x'));
			System.out.printf("[%s]%n", StringUtil.padTrailing(s, count));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class StringUtil {
	public static String padLeading(String s, int length, char ch)
	{
		return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;		
	}
	
	public static String padLeading(String s, int length)
	{
		return padLeading(s, length, ' ');
	}
	
	public static String padTrailing(String s, int length, char ch)
	{
		return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
	}
	
	public static String padTrailing(String s, int length)
	{
		return padTrailing(s, length, ' ');
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Aşağıda açıklanan metotları yazınız ve test ediniz:
		public static String padLeading(String s, int length, char ch);
		public static String padLeading(String s, int length);
		public static String padTrailing(String s, int length, char ch);
		public static String padTrailing(String s, int length);
	Açıklamalar:
	- padLeading metodunun 3 parametreli overload'u ikinci parametresi aldıuğı length uzunluğu birinci parametresi
	ile aldığı yazıdan büyükse yazıyı soldan üçüncü parametresi ile aldığı karakter ile doldurulmuş yeni bir String
	referansına döner.
	Örneğin:
	padLeading("ankara", 11, 'x'); çağrısı
	
	xxxxxankara
	
	yazısını döndürecektir.
	
	- length yazıdan küçük veya eşitse aynı referans döndürülecektir
	
	- padLeading metodunun 2 parametreli overload'u yazıyı soldan space karakteri ile dolduracaktır
	
	- padTrailing metotları sağdan dolduracak şekilde padLeading ile benzer çalışacaktır
	
	(Java 11 öncesi için yazılmış versiyon)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PadLeftRightTest.run();
	}
}


class PadLeftRightTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();					
			
			if ("quit".equals(s))
				break;		
			
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			System.out.printf("[%s]%n", s);
			System.out.printf("[%s]%n", StringUtil.padLeading(s, count, 'x'));
			System.out.printf("[%s]%n", StringUtil.padLeading(s, count));
			System.out.printf("[%s]%n", StringUtil.padTrailing(s, count, 'x'));
			System.out.printf("[%s]%n", StringUtil.padTrailing(s, count));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class StringUtil {
	public static String padLeading(String s, int length, char ch)
	{
		return length <= s.length() ? s : repeat(length - s.length(), ch) + s;		
	}
	
	public static String padLeading(String s, int length)
	{
		return padLeading(s, length, ' ');
	}
	
	public static String padTrailing(String s, int length, char ch)
	{
		return length <= s.length() ? s : s + repeat(length - s.length(), ch);
	}
	
	public static String padTrailing(String s, int length)
	{
		return padTrailing(s, length, ' ');
	}
	
	public static String repeat(int count, char ch)
	{
		String s = "";
		
		while (count-- > 0)
			s += ch;
		
		return s;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Homework-002-4. sorunun bir çözümü	
	(İleride daha iyisi yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		BallFallGameApp.run();			
	}
}

class BallFallGameApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		BallFallGame ballFallGame = new BallFallGame();
		
		for (;;) {		
			System.out.print("Width?");
			int width = Integer.parseInt(kb.nextLine());
			
			if (width <= 0)
				break;
			
			System.out.print("Height?");
			int height = Integer.parseInt(kb.nextLine());			
			
			ballFallGame.play(width, height);
			
			System.out.println(ballFallGame.shape);
			System.out.println("//////////////////////");
		}	
	}
}

class BallFallGame {
	public String shape;	
	
	public static boolean updateRightFlag(int ballIndex, boolean isRight, int width)
	{
		if (ballIndex == 0)
			isRight = true;
		else if (ballIndex == width - 1)
			isRight = false;
		
		return isRight;
	}
	
	public static int updateBallIndex(boolean isRight, int ballIndex)
	{
		if (isRight)
			++ballIndex;
		else
			--ballIndex;
		
		return ballIndex;
	}
	
	
	public void fillSpace(int begin, int end)
	{
		for (int i = begin; i < end; ++i)
			shape += ' ';
	}
	
	public void fillBall(int ballIndex, int end)
	{
		fillSpace(0, ballIndex);
		shape += '*';
		fillSpace(ballIndex + 1, end);
	}
	
	public BallFallGame()
	{
		shape = "";
	}
	
	
	public void play(int width, int height)
	{
		int ballIndex = 0;
		boolean isRight= true;
		
		shape = "";
		for (int i = 1; i <= height; ++i) {
			shape  += '|';
			fillBall(ballIndex, width);
			isRight = updateRightFlag(ballIndex, isRight, width);
			
			if (width != 1)
				ballIndex = updateBallIndex(isRight, ballIndex);
			
			shape += "|\n";
		}				
		
		shape = shape.substring(0, shape.length() - 1);
	}
}


/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının tüm boşluk karakterlerinin atılmış olduğu bir String referansı
	döndüren removeWhiteSpaces isimli metodu StringUtil sınıfı içerisinde yazınız ve test ediniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		RemoveWhiteSpacesTest.run();			
	}
}

class RemoveWhiteSpacesTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);	
		
		for (;;) {		
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.printf("[%s]%n", s);
			System.out.printf("[%s]%n", StringUtil.removeWhiteSpaces(s));
		}	
	}
}

class StringUtil {
	public static String removeWhiteSpaces(String s)
	{
		int length = s.length();
		String str = "";
		
		for (int i = 0; i < length; ++i) {
			char ch = s.charAt(i);
			
			if (!Character.isWhitespace(ch))
				str += ch;
		}
		
		return str;			
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	 Derleyici özdeş String atomları (string literals) için aynı adresi verecek kodu üretir. Aşağıdaki örnekte 
	 adres karşılaştırması yapılmıştır. Adresler aynı olduğu için "Aynı yazı" yazısı ekrana basılır. Anımsanacağı
	 gibi örneğin yazılar klavyeden alınırsa farklı nesnelerin elde edildiğinden yazılar aynı bile "Farklı yazılar"
	 yazısı ekrana basılır 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		String s1 = "ankara";
		String s2 = "ankara";
		
		if (s1 == s2) //Dikkat adres karşılaştırması
			System.out.println("Aynı yazı");
		else
			System.out.println("Farklı yazılar");		
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	07.02.2021
	String sınıfının compareTo metodu:
	s1.compareTo(s2); çağrısı için
	1. Geri dönüş değeri negatif ise s1, s2'den önce gelir
	2. Geri dönüş değeri pozitifise s2, s1'den önce gelir
	3. Geri dönüş değeri sıfır ise s1 ile s2 aynı yazılara ilişkindir	  
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		int result = s1.compareTo(s2);
		
		System.out.println(result);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının compareToIgnoreCase metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		int result = s1.compareToIgnoreCase(s2);
		
		System.out.println(result);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının contains metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		if (s1.contains(s2))
			System.out.println("Yazı var");
		else
			System.out.println("Yazı bulunamadı");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının contains metodu ile büyük-küçük harf duyarsız teste bir örnek
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		if (s1.toLowerCase().contains(s2.toLowerCase()))
			System.out.println("Yazı var");
		else
			System.out.println("Yazı bulunamadı");		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı bir yazının Türkçe pangram olup olmadığını test eden isPangramTR ve 
	İngilizce pangram olup olmadığını test eden isPangramEN isimli metotları yazınız ve test ediniz.
	Pangram: İçerisinde özel isim bulunmayan anlamlı ve ilgili dilin alfabesinin tüm karakterlerini içeren cümlelere denir 
	
	Türkçe: Pijamalı hasta yağız şoföre çabucak güvendi
 	İnglizce: The quick brown fox jumps over the lazy dog
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PangramTest.run();
	}
}

class PangramTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramTR(s) ? "Pangram" : "Pangram değil");
			System.out.println(StringUtil.isPangramEN(s) ? "Pangram" : "Not a pangram");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
		
	}
}

class StringUtil {
	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");						
	}
	
	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");		
	}
	
	public static boolean isPangram(String text, String alphabet)
	{
		int length = alphabet.length();
		
		for (int i = 0; i < length; ++i)
			if (text.indexOf(alphabet.charAt(i)) == -1)
				return false;
		
		return true;
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Yukarıdaki örnek için İngiliz alfabesindeki karakterler karakter tablosunda sıralı olduğundan isPangramEN
	metodu aşağıdaki gibi yazılabilir. Ancak yukarıdaki yaklaşım daha geneldir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PangramTest.run();
	}
}

class PangramTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;		
			
			System.out.println(StringUtil.isPangramEN(s) ? "Pangram" : "Not a pangram");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
		
	}
}

class StringUtil {	
	public static boolean isPangramEN(String text)
	{
		text = text.toLowerCase();
		
		for (char c = 'a'; c <= 'z'; ++c)
			if (text.indexOf(c) == -1)
				return false;
		
		return true;
	}	
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı bir yazının Türkçe pangram olup olmadığını test eden isPangramTR ve 
	İngilizce pangram olup olmadığını test eden isPangramEN isimli metotları yazınız ve test ediniz.
	Pangram: İçerisinde özel isim bulunmayan anlamlı ve ilgili dilin alfabesinin tüm karakterlerini içeren cümlelere denir 
	
	Türkçe: Pijamalı hasta yağız şoföre çabucak güvendi
 	İnglizce: The quick brown fox jumps over the lazy dog
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PangramTest.run();
	}
}

class PangramTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramTR(s) ? "Pangram" : "Pangram değil");
			System.out.println(StringUtil.isPangramEN(s) ? "Pangram" : "Not a pangram");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
		
	}
}

class StringUtil {
	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");						
	}
	
	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");		
	}
	
	public static boolean isPangram(String text, String alphabet)
	{
		int length = alphabet.length();
		
		for (int i = 0; i < length; ++i)
			if (!text.contains(alphabet.charAt(i) + ""))				
				return false;
		
		return true;
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı bir yazının palindrom olup olmadığını test eden isPalindrome isimli
	metodu yazınız ve test ediniz.
	
	Palindrom: Yalnızca alfabetik karakterler tersten okuduğunda aynı olan yazılara denir. Yani alfabetik dışı
	karakterler yok sayılır
	Örnek: 
	Ey edip Adana'da pide ye ->eyedipadanadapideye
	Ali Papila -> alipapila
	Anastas mum satsana -> anastasmumsatsana	
	
	Not: Problemi yazının tüm alfabetik dışı karakterlerini atan getLetters isimli
	bir metot yazarak çözünüz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PalindromTest.run();
	}
}

class PalindromTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(StringUtil.isPalindrome(s) ? "Palindrom" : "Palindrom değil");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
		
	}
}

class StringUtil {
	public static boolean isPalindrome(String s)
	{
		String str = getLetters(s);
		int length = str.length();
		int halfLength = length / 2;
		
		for (int i = 0; i < halfLength; ++i) {
			char cLeft = Character.toLowerCase(str.charAt(i));
			char cRight = Character.toLowerCase(str.charAt(length - 1 - i));
			
			if (cLeft != cRight)
				return false;
		}
		
		return true;
	}
	
	public static String getLetters(String s)
	{
		String str = "";
		int length = s.length();
		
		
		for (int i = 0; i < length; ++i) {
			char c = s.charAt(i);
			
			if (Character.isLetter(c))
				str += c;
		}
		
		return str;
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı bir yazının palindrom olup olmadığını test eden isPalindrome isimli
	metodu yazınız ve test ediniz.
	
	Palindrom: Yalnızca alfabetik karakterler tersten okuduğunda aynı olan yazılara denir. Yani alfabetik dışı
	karakterler yok sayılır
	Örnek: 
	Ey edip Adana'da pide ye ->eyedipadanadapideye
	Ali Papila -> alipapila
	Anastas mum satsana -> anastasmumsatsana	
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		PalindromTest.run();
	}
}

class PalindromTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(StringUtil.isPalindrome(s) ? "Palindrom" : "Palindrom değil");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
		
	}
}

class StringUtil {
	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;		
		
		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));
			
			if (!Character.isLetter(cLeft)) {
				++left;
				continue;
			}
			
			char cRight = Character.toLowerCase(s.charAt(right));
			
			if (!Character.isLetter(cRight)) {
				--right;
				continue;
			}
			
			
			if (cLeft != cRight)
				return false;
			
			++left;
			--right;
		}
		
		return true;
		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı bir yazının içerisindeki en uzun palindromu döndüren getLongestPalindrome
	metodunu yazınız ve test ediniz	
	
	Örnek: adaeyedipadanadapideyeecealipapilaanastasmumsatsanaxxx
	Örnek: adaeyedipadanadapideecealipapilanastasmumsatsanaxxx
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		LongestPalindromTest.run();
	}
}

class LongestPalindromTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(StringUtil.getLongestPalindrome(s));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
		
	}
}

class StringUtil {
	public static String getLongestPalindrome(String text)
	{
		String result = "";
		
		int end = text.length();
		
		while (end != 0) {
			int begin = 0;
			
			while (begin != end) {
				String str = text.substring(begin++, end);
				
				if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
					result = str;
			}
			
			--end;
		}
		
		return result;		
	}
	
	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;		
		
		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));
			
			if (!Character.isLetter(cLeft)) {
				++left;
				continue;
			}
			
			char cRight = Character.toLowerCase(s.charAt(right));
			
			if (!Character.isLetter(cRight)) {
				--right;
				continue;
			}			
			
			if (cLeft != cRight)
				return false;
			
			++left;
			--right;
		}
		
		return true;		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n tane rasgele üretilmiş Türkçe karakterlerden
	oluşan bir yazı döndüren getRandomTextTR ile n tane rasgele üretilmiş İngilizce karakterlerden oluşan bir yazı döndüren 
	getRandomTextTR ile getRandomTextEN metotlarını yazınız ve test ediniz 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		GetRandomTextTR.run();
	}
}

class GetRandomTextTR {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				break;
			
			System.out.printf("Şifre:%s%n", StringUtil.getRandomTextTR(r, n));
			System.out.printf("Password:%s%n", StringUtil.getRandomTextEN(r, n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
		
	}
}

class StringUtil {
	public static String getRandomTextTR(java.util.Random r, int n)
	{
		return getRandomText(r, n, "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz");
	}
	
	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new java.util.Random(), n);
	}
	
	public static String getRandomTextEN(java.util.Random r, int n)
	{
		return getRandomText(r, n, "ABCDEFGHIJKLMNOPQRSTUWXVYZabcdefghijklmnopqrstuvwxyz");
	}
	
	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new java.util.Random(), n);
	}
	
	public static String getRandomText(java.util.Random r, int n, String sourceText)
	{
		String result = "";
		int length = sourceText.length();
		
		for (int i = 0; i < n; ++i)
			result += sourceText.charAt(r.nextInt(length));
		
		return result;		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sarmalayan sınıfların (wrapper classes) parseXXX static metotları ile yazılar sayıya çevrilebilir. Bu metotlar
	genel olarak aldıkları yazı çevrilemiyor ise exception fırlatırlar 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();		
		
		System.out.print("Bir sayı giriniz:");
		String str = kb.nextLine();
		int val = Integer.parseInt(str);
		
		
		System.out.printf("%d * %d = %d%n", val, val, val * val);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Integer sınıfının sayı sistemi (radix) parametreli parseInt metodu 
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();		
		
		System.out.print("Bir sayı giriniz:");
		String str = kb.nextLine();
		int val = Integer.parseInt(str, 16);
		
		
		System.out.printf("%d * %d = %d%n", val, val, val * val);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Kabaca söylenirse Scanner'ın çalışma sistematiği dolayısıyla nextInt, nextLong ve nextDouble gibi metotlar nextLine metodu
	ile aynı Scanner nesnesi üzerinden klavye işlemlerinde kullanılmamalıdır. Bu yüzden klavye işlemlerinde nextLine 
	metodu dışındakiler	tercih edilmez. Aşağıdaki programı çalıştırarak problemi gözlemleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);				
		
		for (;;) {
			System.out.print("Numarayı giriniz:");		
			int number = kb.nextInt();
			
			if (number == 0)
				break;
			
			System.out.print("İsmi giriniz:");
			String name = kb.nextLine();
			
			System.out.printf("%d, %s%n", number, name);
		}		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının valueOf metotları ile temel türlerin yazı karşılığı elde edilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 10;
		String str = String.valueOf(a);
		
		
		System.out.println(str);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Aynı işlem aşağıdaki gibi de yapılabilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 10;
		String str = a + "";		
		
		System.out.println(str);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının format metodu ile formatlanmış bir yazı elde edilebilir. Bu metodun kullanımı ekrana basması
	dışında printf metodu ile birebir aynıdır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		String str = String.format("%d + %d = %d", a, b, a + b);
		
		System.out.println(str);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Tüm öğrendiklerimize göre örneğin int türden bir değerin yazı karşılığı 3(üç) şekilde elde edilebilir
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 10;
		String s1 = a + "";
		String s2 = String.valueOf(a);
		String s3 = String.format("%d", a);
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s3);			
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Point sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Point p = new Point(100, 100);
		
		System.out.println(p.toString());
	}
}

class Point {
	public int x;
	public int y;
	
	public Point()
	{	
	}
	
	public Point(int a)
	{
		x = a;		
	}		
	
	public Point(int a, int b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b)
	{
		return Math.sqrt((x - a) * (x - a) + (y - b) * (y - b));				
	}
	
	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public String toString()
	{
		return String.format("{x : %d, y : %d}", x, y);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Complex sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		Complex z = new Complex(3, 4);
		
		System.out.println(z.toString());
	}
}

class Complex {
	public static Complex add(double a1, double b1, double a2, double b2) //ileride gizlenecek
	{		
		return new Complex(a1 + a2, b1 + b2);
	}
	
	public static Complex subtract(double a1, double b1, double a2, double b2) //ileride gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public double re;
	public double im;
	
	public Complex()
	{		
	}	
	
	public Complex(double a)
	{
		re = a;
	}
	
	public Complex(double a, double b)
	{
		re = a;
		im = b;
	}
	
	public double getNorm()
	{
		return Math.sqrt(re * re + im * im);
	}
	
	public Complex getConjugate()
	{
		return new Complex(re, -im);		
	}
	
	//add methods
	public Complex add(Complex other)
	{
		return add(re, im, other.re, other.im);						
	}
	
	public Complex add(double val)
	{
		return add(re, im, val, 0);
	}
	
	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.re, z.im);
	}
	
	//subtract methods
	public Complex subtract(Complex other)
	{
		return subtract(re, im, other.re, other.im);						
	}
	
	public Complex subtract(double val)
	{
		return subtract(re, im, val, 0);
	}
	
	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.re, z.im);
	}
	
	public String toString()
	{
		return String.format("|%.2f + %.2f * i| = %f", re, im, getNorm());
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının replace metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		String str = "Bugün hava çok sıcak. Bu sıcak havada dolaşamıyoruz";
		
		str = str.replace("sıcak", "soğuk");
		
		System.out.println(str);		
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	String sınıfının replace metodu
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		String str = "ankara";
		
		str = str.replace('a', 'b');
		
		System.out.println(str);		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Sınıf Çalışması: Java 11 ile eklenen repeat metodunu kullanmadan ve döngü de kullanmadan, parametresi ile
	aldığı int türden n değeri ve bir karakter için n tane o karakterden oluşan yazıyı döndüren repeat metodunu
	yazınız
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		int count = 4;
		
		System.out.println(StringUtil.repeat1(count, 'c'));		
		System.out.println(StringUtil.repeat2(count, 'c'));
	}
}

class StringUtil {
	public static String repeat1(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}
	
	public static String repeat2(int count, char ch)
	{
		return String.format("%" + count + "c", ' ').replace(' ', ch);
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	Java 7 ile birlikte switch deyiminde Strinf de kullanılabilmektedir. Bu durumda case bölümlerinin String literal
	olması zorunludur. String sınıfı switch deyimi ile kullanıldığında karşılaştırma equals metodu ile yapılır
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Şehir ismini giriniz:");
		String city = kb.nextLine();
		
		switch (city.toLowerCase()) {
		case "ankara":
		case "çankırı":
		case "konya":
			System.out.println("İç Anadolu Bölgesi");
			break;
		case "istanbul":
		case "bursa":
		case "çanakkale":
			System.out.println("Marmara Bölgesi");
			break;
			
		case "zonguldak":
		case "bolu":
		case "sinop":
			System.out.println("Batı Karadeniz Bölgesi");
			break;
		default:
			System.out.println("Geçersiz şehir ismi");			
		}		
	}
}

/*--------------------------------------------------------------------------------------------------------------------		
	13.02.2021
	Homework-006 sorusunun bir çözümü
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		CrapsSimulationApp.run();				
	}
}

class CrapsSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		Craps craps = new Craps();
		
		System.out.print("Kaç kez oynamak istersiniz?");
		int n = Integer.parseInt(kb.nextLine());
		
		int count = 0;
		
		for (int i = 0; i < n; ++i) {
			craps.play();
			if (craps.win)
				++count;			
		}
		
		System.out.printf("p = %f%n", (double)count / n);
	}
}

class Craps {
	public boolean win;
	public java.util.Random r;	
	
	public int total()
	{
		return r.nextInt(6) + 1 + r.nextInt(6) + 1;
	}
	
	public void doWorkForIndeterminite(int sum)
	{
		int newSum;
		
		while ((newSum = total()) != sum) {
			if (newSum == 7) {
				win = false;
				return;
			}				
		}	
		
		win = true;
	}
	
	public void doWorkForSum(int sum)
	{
		switch (sum) {
		case 7:
		case 11:
			win = true;
			break;
		case 2:
		case 3:
		case 12:
			win = false;
			break;
		default:
			doWorkForIndeterminite(sum);
		}		
	}
	
	public Craps()
	{
		r = new java.util.Random();
	}
	
	public void play()
	{		
		doWorkForSum(total());
	}
}


/*--------------------------------------------------------------------------------------------------------------------		
	Homework-006 sorusunun bir çözümü
---------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		CrapsSimulationApp.run();				
	}
}

class CrapsSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		Craps craps = new Craps();
		
		System.out.print("Kaç kez oynamak istersiniz?");
		int n = Integer.parseInt(kb.nextLine());
		
		int count = 0;
		
		for (int i = 0; i < n; ++i) {
			craps.play();
			if (craps.win)
				++count;			
		}
		
		System.out.printf("p = %f%n", (double)count / n);
	}
}

class Craps {
	public boolean win;
	public java.util.Random r;	
	
	public int total()
	{
		return r.nextInt(6) + 1 + r.nextInt(6) + 1;
	}
	
	public void doWorkForIndeterminite(int sum)
	{
		int newSum;
		
		while ((newSum = total()) != sum)
			if (newSum == 7)
				break;		
		
		win = newSum == sum;
	}
	
	public void doWorkForSum(int sum)
	{
		switch (sum) {
		case 7:
		case 11:
			win = true;
			break;
		case 2:
		case 3:
		case 12:
			win = false;
			break;
		default:
			doWorkForIndeterminite(sum);
		}		
	}
	
	public Craps()
	{
		r = new java.util.Random();
	}
	
	public void play()
	{		
		doWorkForSum(total());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Paketler ve isim arama:
	
	Aşağıdaki maddelerde aksi belirtilmediği sürece "sınıf" kavramı aslında "tür" kavramı olarak kullanılacaktır. Burada 
	"tür" temel türler dışında kalan programcının tanımladığı türlerdir (user defined types).
	Yani tüm referans türleri için geçerli olacaktır.
	
	Anahtar Notlar: Bir java kaynak kodlarını içeren ".java" uzantılı dosyaya (derlenen dosya) "derleme birimi (compilation unit)"
	denir 
	
	Paketler:

	- javac her sınıf için ayrı bir .class uzantılı dosya (byte code) üretir. Bu işlem sınıflar aynı java dosyasında 
	olsa bile yapılır.

  	- Bir .class dosyasının ait olduğu pakete ilişkin bir dizinde (directory) bulunması gerekir. Aslında java dosyaları 
  	için böyle bir zorunluluk yoktur. Ancak bir çok IDE bunu kendi içinde zorunlu tutar.

  	- Bir sınıf herhangi bir pakette olabilir. Bir proje içerisinde kullanılan sınıfların aynı pakette olma zorunluluğu yoktur
  	
  	- Bir sınıfa onun bulunduğu paket dışında (başka bir paketin içerisinde), paket ismi ve nokta operatörü ile erişilebilir

  	- Bir paket içerisinde bildirilen bir sınıfın farklı bir paketten kullanılabilmesi için public olarak bildirilmesi gerekir. 
  	public olarak bildirilmeyen bir sınıf ancak aynı paketteki diğer sınıflar tarafından kullanılabilir (friendly, internal)  	 	

  	- Farklı paketlerdeki sınıflar için byte kodların da uygun yerde olması gerekir. Uygulamanın çalışmaya başlatıldığı dizin 
  	tüm paketlerin olması gereken dizindir. Ancak bu durumun istisnaları olabilir

  	- Uygulamada kullanılan sınıflar içerisinde bir tane main metodu olmak zorunda değildir. Ancak şüphesiz java programına 
  	verilen byte koda ilişkin sınıfta (bu kesinlikle sınıf olmalı) mutlaka uygun main metodunun olması gerekir. main metodunun 
  	aşağıdaki yapıya sahip olması gerekir.
  		public static void main(String [] args)
  	java programına verilen main metoduna giriş noktası (entry point) denilmektedir

  	- public olarak bildirilen bir sınıfın kendi ismiyle aynı isimde bir ".java" uzantılı dosyada olması zorunludur.

  	- Bir ".java" uzantılı dosyanın içerisinde yalnızca dosya ismi ile aynı olan sınıf public olarak bildirilebilir.

  	- Bir java dosyası içerisinde public sınıf olmak zorunda değildir. public sınıf olacaksa dosya ismi ile aynı 
  	isimde olan sınıf ancak public olabilir.

	- Bir java dosyası içerisinde public olmayan istenildiği kadar sınıf yazılabilir. Bu sınıflar aynı pakette bildirilmiş 
	olur.
	
  	- Bir java dosyası içerisinde dosya ismi ile aynı isimde sınıf olmak zorunda değildir  	

  	- Bir paket içerisinde aynı isimde birden fazla sınıf bildirimi yapılamaz. Aynı java dosyası veya farklı java dosyası 
  	içerisinde olmak bu durumu değiştirmez
  	
  	- Farklı paketler içerisinde aynı isimde sınıflar olabilir

  	- Bir java dosyası içerisindeki sınıflar o java dosyasının başında bildirilen paket içerisinde olurlar.

  	- Bir java dosyasında farklı paket bildirimleri yapılamaz

  	- Hiç bir paket bildirimi olmayan java dosyalarında bildirilen sınıflar isimsiz paket (unnamed package) denilen bir 
  	paket içerisinde kabul edilir. Ancak projelerde isimsiz paket içerisinde sınıf bildirimi yapılmamalıdır.
  	
  	- Bir paket içerisinde alt paketler olabilir. Alt paketler
  		package <paket ismi>.<alt paket ismi>.<alt paket isimi>...;

  	  biçiminde bildirilir. Alt paketlerde bulunan sınıfların .class dosyaları (byte code) paket hiyararşisine uygun alt 
  	  dizinlerde bulunmalıdır.

  	- Paketler içiçe bile olsa farklı paketlerdir. Yani örneğin org.csystem.util paketi içerisinde ArrayUtil sınıfı 
  	varsa org.csystem paketi içerisinde de ArrayUtil sınıfı olabilir. Bu isimler kesinlikle çakışmaz

  	- Paket isimleri genelde firmaya ilişkin tekil bir bilgi olan domain isimleri ile belirlenir. Örneğin CSD firmasının 
  	paketleri ve sınıfları domain adresi "csystem.org" olduğundan "org.csystem" paketi altında yazılabilir. Bu şekilde 
  	yaklaşıma uyulmalıdır.

	- Java'nın standart tüm paketleri ve sınıfları java isimli bir paket altında toplanmıştır

	- java.lang isimli paketi altında bulunan tüm sınıflar her yerden görülebilirdir. Yani buradaki isimleri paket ismi 
	ile kombine etmeye gerek yoktur (import bildirimi olmadan da kullanılabilir)
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

public class Point {
	public int x;
	public int y;
	
	public Point()
	{	
	}
	
	public Point(int a)
	{
		x = a;		
	}		
	
	public Point(int a, int b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b)
	{
		return Math.sqrt((x - a) * (x - a) + (y - b) * (y - b));				
	}
	
	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public String toString()
	{
		return String.format("{x : %d, y : %d}", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math;

public class Complex {
	public static Complex add(double a1, double b1, double a2, double b2) //ileride gizlenecek
	{		
		return new Complex(a1 + a2, b1 + b2);
	}
	
	public static Complex subtract(double a1, double b1, double a2, double b2) //ileride gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public double re;
	public double im;
	
	public Complex()
	{		
	}	
	
	public Complex(double a)
	{
		re = a;
	}
	
	public Complex(double a, double b)
	{
		re = a;
		im = b;
	}
	
	public double getNorm()
	{
		return Math.sqrt(re * re + im * im);
	}
	
	public Complex getConjugate()
	{
		return new Complex(re, -im);		
	}
	
	//add methods
	public Complex add(Complex other)
	{
		return add(re, im, other.re, other.im);						
	}
	
	public Complex add(double val)
	{
		return add(re, im, val, 0);
	}
	
	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.re, z.im);
	}
	
	//subtract methods
	public Complex subtract(Complex other)
	{
		return subtract(re, im, other.re, other.im);						
	}
	
	public Complex subtract(double val)
	{
		return subtract(re, im, val, 0);
	}
	
	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.re, z.im);
	}
	
	public String toString()
	{
		return String.format("|%.2f + %.2f * i| = %f", re, im, getNorm());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İsim arama (name lookup): Derleyici kullanılan bir ismi gördüğünde önce arar. Eğer bulursa doğru kullanılıp
	kullanılmadığına bakar. Derleyici isim aramayı belirli kurallara göre yapar. Burada anlatılacak kuralların
	dışında başka detaylar da vardır. Bu detaylar da isim aramanın bir parçasıdır. Özel durumlar olarak düşünülebilir
	Yani burada genel kurallar sonra özel durumlar ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bildirimi yapılan isimleri bildirim noktasında aramaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{		
		int a = 10; //a aranmaz
		
		
		//...		
	}
}

class Sample { //Sample aranmaz
	public int a; // a aranmaz
	
	public void foo() //foo aranmaz
	{
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir isim programlamada iki şekilde kullanılabilir: nitelikli (qualified), niteliksiz (unqualified)
	
	Kullanılan bir ismin solunda nokta operatörü yoksa (yani doğrudan ya da yalnızca sağında nokta operatörü varsa)
	niteliksiz kullanılmış olur ve niteliksiz isim arama (unqualified name lookup) kurallarına göre aranır.
	
	Kullanılan ismin solunda nokta operatörü varsa nitelikli kullanılmış olur ve nitelikli isim arama (qualified name lookup)
	kurallarına göre aranır
	
	Özetle: Kullanılan bir isim nokta operatörünün sağında kalıyorsa nitelikli, kalmıyorsa niteliksiz aranır.
	
	Anahtar Notlar: Yukarıdaki tanımlarda nitelikli veya niteliksiz olmak olumlu veya olumsuz bir etki anlamında
	düşünülmemelidir
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli ve niteliksiz kullanıma örnekler 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{		
		Sample s;
		 
		s = new Sample(); //s niteliksiz, Sample niteliksiz aranır
		
		s.a = 10; //s niteliksiz, a nitelikli aranır
		s.foo(10); //s niteliksiz, foo nitelikli aranır
	}
}

class Sample {
	public int a;
	
	public void foo(int x)
	{
		a = x; // a ve niteliksiz aranır
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bir ismi bulduktan sonra doğru kullanılıp kullanılmadığına bakar. Aşağıdaki örnekte a ismi niteliksiz 
	olarak aranmış ve bulunmuştur ancak kullanım hatasından dolayı error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{		
		int a;
		
		a = 2.3; //error				
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte x ismi bulunamadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{		
		int a; 
		
		x = 2.3; //error				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	14.02.2021
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	1. Bir isim metot içerisinde kullanılmışsa, kullanıldığı yerden yukarıya doğru metot içerisinde aranır. Burada
	yerel değişken ve parametre değişken isimlerine de bakılır 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{		
		int a;	
		
		a = 10;						
	}
}


class Sample {
	public void foo(int x)
	{
		int a;
		
		a = x;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	2. İsim metodun ait olduğu sınıfın tamamında ancak tüm metotların dışında aranır. Burada sınıf içerisinde bulunamazsa
	taban sınıflara da (super class) bakılır. Taban sınıf kavramı ileride "inheritance" konusunda ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo(45);

        System.out.println(s.a);
    }
}

class Sample {
    public void foo(int x)
    {
        a = x;
    }

    public int a;
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki iki kurala göre bir sınıfın veri elemanı ile aynı isimde metot parametre değişkeni veya yerel değişken
    bildirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo(45);

        System.out.println(s.a);
    }
}

class Sample {
    public void foo(int a)
    {
        int a; //shadowing

        a = x;
    }

    public int a;
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte parametre değişkeni olan a'nın kendisine atandığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo(45);

        System.out.println(s.a);
    }
}

class Sample {
    public void foo(int a)
    {
        a = a;
    }

    public int a;
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3. Sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere veya üst paketlere bakılmaz. Sadece ait olduğu
	pakete bakılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo(45);

        System.out.println(s.a);
    }
}

class Sample {
    public void foo(int x)
    {
        a = x;
    }

    public int a;
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3. Sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere veya üst paketlere bakılmaz. Sadece ait olduğu
	pakete bakılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(); //error

        s.foo(45);

        System.out.println(s.a);
    }
}

package org.csystem;

public class Sample {
    public void foo(int x)
    {
        a = x;
    }

    public int a;
}
/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3. Sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere veya üst paketlere bakılmaz. Sadece ait olduğu
	pakete bakılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(); //error

        s.foo(45);

        System.out.println(s.a);
    }
}

package org.csystem.app.test;

public class Sample {
    public void foo(int x)
    {
        a = x;
    }

    public int a;
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kurala göre isimsiz paket altında bulunan bir sınıfa bir paket içerisinden erişileme. Nitelikli
	olarak da erişilemez. Yalnızca bu sebepten bile isimsiz paket altında sınıf bildirilmemelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(); //error

        s.foo(45);

        System.out.println(s.a);
    }
}

public class Sample {
    public void foo(int x)
    {
        a = x;
    }

    public int a;
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	4. "import on demand declaration" varsa o paketlere de bakılır. Bu konu ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki isim arama işleminde sonuna kadar hiçbir yerde isim bulunamamışsa error oluşur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
    1. Aranacak ismin solunda sınıf ismi varsa isim ilgili sınıf içerisinde aranır. Bulunamazsa taban sınıflara da
    bakılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo();
        Sample.a = 10;
    }
}

class Sample {
    public static int a;

    public static void foo()
    {

    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
    2. Aranacak ismin solunda referans ismi varsa isim referansa ilişkin sınıf içerisinde aranır. Bulunamazsa
    taban sınıflara da bakılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo();
        s.a = 10;
    }
}

class Sample {
    public int a;

    public void foo()
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
    3. Aranacak ismin solunda paket ismi varsa bu durumda isim paket içerisinde aranır. Alt ya da üst paketlere
    bakılmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        test.Sample s;
    }
}

package test;

public class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Alt paket isimleri niteliksiz aramaya dahil değildir. Yani aşağıdaki örnekte test isimli paket
	org.csystem.app paketi içerisinde olduğu halde dikkate alınmaz. Bit paket isminin niteliksiz aranması ve bulunması
	için global düzeyde olması gerelir. Yani üst paketinin olmaması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        test.Sample s; //error

    }
}

package org.csystem.app.test;

public class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Alt paket isimleri niteliksiz aramaya dahil değildir. Yani aşağıdaki örnekte test isimli paket
	org.csystem.app paketi içerisinde olduğu halde dikkate alınmaz. Bit paket isminin niteliksiz aranması ve bulunması
	için global düzeyde olması gerelir. Yani üste paketinin olmaması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        test.Sample s; //error

    }
}

package test;

public class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    import bildirimi genel olarak niteliklendirmeyi azaltmak, dolayısıyla daha kolay açık (clean) kod yazımı için
    kullanılır.
    import bildirimi bir kütüphaneyi "import etmek" anlamına GELMEZ

    import bildirimi (static olmayan import bildirimi) iki şekilde kullanılabilir:
    1. Yıldızlı import bildirimi (import on demand declaration)
    2. Yıldızsız import bildirimi (import single type declaration)

    import bildirimleri ".java" dosyasında paket bildiriminden sonra diğer bildirimlerden önce yazılmalıdır. import
    bildirimlerinin yazılma sırasının önemi yoktur. import bildirimleri o ".java" dosyasına özgüdür. Aynı paket
    bildirimine sahip farklı ".java" dosyalarını etkilemez. Şüphesiz farklı paket bildirimine sahip ".java" dosyalarını
    da etkilemez.

    Anahtar Notlar: "Yıldızlı ve yıldızsız import bidirimi" tercümesi kolay anlatmak için tarafımdan uydurulmuştur.
    Teknik terim olarak kesinlikle "import with asterisk" veya "import without asterisk" DENMEMELİDİR.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildiriminin (import on demand declaration) genel biçimi:
	import <paket ismi>[.alt paketler].*;

	Yıldızlı import bildirimi niteliksiz olarak aranan bir isim paket içerisinde bulunamazsa arama için bakılacak olan
	paketi temsil eder. Yani adeta bir paketin başka paket içerisine isim arama anlamında enjekte edilmesidir. Burada da
	bulunamaması durumunda alt ya da üst paketlere bakılmaz

	Daha açık olarak yıldızlı import bildirimleri derleyiciye "eğer niteliksiz bir ismi pakette de bulamazsan bu paketlere de
	bak" anlamına gelir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.*;
import org.csystem.util.math.geometry.*;
import org.csystem.util.math.*;

class App {
    public static void main(String [] args)
    {
        Point p;
        Random r;
        Scanner kb;
        Complex z;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildirimlerinde paketlerin hepsine bakılır. Birden fazla oaket içerisinde isim bulunursa error
	oluşur (ambiguity)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.*;
import mest.*;

class App {
    public static void main(String [] args)
    {
        Mample m;
        Sample s; //error: ambiguity
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problemin bir çözümü
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.*;
import mest.*;

class App {
    public static void main(String [] args)
    {
        Mample m;
        test.Sample st;
        mest.Sample sm;

        //...
    }
}

package test;

public class Sample {
    //...
}

package mest;

public class Sample {
    //..
}

package test;

public class Mample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildiriminin kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.*;
import java.util.*;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (int i = 0; i < 10; ++i) {
            Point p = new Point(r.nextInt(100), r.nextInt(100));

            System.out.println(p.toString());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızsız import bildiriminin (import single type declaration) genel biçimi:
	import <paket ismi>[.alt paketler].<sınıf ismi>;
	Not: Burada sınıf ismi bir "user defined type" ismi anlamındadır

    Bu bildirim sınıf isminin doğrudan kullanılabileceğini belirtir. Bu bildirimin yazılabildiği durumda bu isim için
    genel niteliksiz isim arama kuralları uygulanmaz. Porgramcı mümkün olduğunda bü bildirimi tercih etmelidir. Zaten
    bir çok IDE de programcıyı bu şekilde yönlendirir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte
	    import java.util.Scanner;
	bildirimi "bu dosyada Scanner ismi doğrudan kullanılabilir ve bu isim java.util.Scanner sınıfıdır" anlamına gelir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.Point;
import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (int i = 0; i < 10; ++i) {
            Point p = new Point(r.nextInt(100), r.nextInt(100));

            System.out.println(p.toString());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Sample isiminin niteliksiz kullanımına ilişkin birden fazla yıldızsız import bildirimi
    yapılmaya çalışıldığından error oluşur. Örnekte Sample ismi kullanılmasa bile import bildirimlerinde error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


import test.Sample;
import mest.Sample; //error

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo();
    }
}

package test;

public class Sample {
    public void foo()
    {
        System.out.println("test.Sample.foo");
    }
}
package mest;

public class Sample {
    public void foo()
    {
        System.out.println("mest.Sample.foo");

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte yıldızsız import bildirimi dolayısıyla test.Sample sınıfının foo metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.Sample;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo();
    }
}

package org.csystem.app;

public class Sample {
    public void foo()
    {
        System.out.println("org.csystem.app.Sample.foo");
    }
}

package test;

public class Sample {
    public void foo()
    {
        System.out.println("test.Sample.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte import bildirimine ilişkin java dosyasında Sample sınıfı zaten olduğundan yani bu java
    dosyasında Sample ismi adeta rezerve edilmiş olduğundan aşağıdaki gibi yıldızsız import bildirimi ile beraber sınıf
    bildirimi geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.Sample;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo();
    }
}

class Sample {
    public void foo()
    {
        System.out.println("org.csystem.app.Sample.foo");
    }
}

package test;

public class Sample {
    public void foo()
    {
        System.out.println("test.Sample.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.*;

public class StringUtil {
    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (Character.isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        String result = "";
        int length = sourceText.length();

        for (int i = 0; i < n; ++i)
            result += sourceText.charAt(r.nextInt(length));

        return result;
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, "ABCDEFGHIJKLMNOPQRSTUWXVYZabcdefghijklmnopqrstuvwxyz");
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = Character.toLowerCase(s.charAt(left));

            if (!Character.isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = Character.toLowerCase(s.charAt(right));

            if (!Character.isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!Character.isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        String str = "";

        for (int i = s.length() - 1; i >= 0; --i)
            str += s.charAt(i);

        return str;
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && Character.isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public class StringUtil {
    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (Character.isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        String result = "";
        int length = sourceText.length();

        for (int i = 0; i < n; ++i)
            result += sourceText.charAt(r.nextInt(length));

        return result;
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, "ABCDEFGHIJKLMNOPQRSTUWXVYZabcdefghijklmnopqrstuvwxyz");
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = Character.toLowerCase(s.charAt(left));

            if (!Character.isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = Character.toLowerCase(s.charAt(right));

            if (!Character.isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!Character.isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        String str = "";

        for (int i = s.length() - 1; i >= 0; --i)
            str += s.charAt(i);

        return str;
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && Character.isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    20.02.2021
    Aşağıdaki örnekte import bildirimleri ile nitelendiklendirme azaltılmış ve kod basitleştirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.NumberUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            int val = r.nextInt(100);

            System.out.printf("%d sayısı %s%n", val, NumberUtil.isPrime(val) ? "asaldır" : "asal değildir");
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Java 5 ile birlikte import static bildirimleri dile eklenmiştir. import static bildirimlerinin de iki biçimi vardır:
    1. Yıldızlı import static bildirimi (import static on demand declaration)
    2. Yıldızsız import static bildirimi (import static single type declaration)

    import static bildirimlerinde okunabilirliği etkilen durumlar olabilir. Buna dikkat edilmelidir. import static
    bildirimleri de import bildirimleri ile aynı yerde yazılır. Bildirim sırasının hiçbir önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Yıldızlı import static bildiriminin genel biçimi:
    import static <paket ismi>[.alt paketler].<tür ismi>.*;

    Bu bildirim ile bildirimin yapıldığı derleme biriminde (.java dosyasında) bildirime ilişkin türün tüm static
    elemanları doğrudan kullanılabilir duruma gelir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static java.lang.Math.*;
import static org.csystem.util.NumberUtil.*;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            int val = r.nextInt(100);

            if (isPrime(val))
                System.out.printf("%f * %d = %f%n", PI,  val, PI * val);
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	NumberUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import static java.lang.Math.*;

public class NumberUtil {
    public static int countDigits(int val)
    {
        return val == 0 ? 1 : (int)log10(abs(val)) + 1;
    }

    public static void displayCollatz(int n)
    {
        if (n <= 0) {
            System.out.println("Geçersiz değer");
            return;
        }

        for (;;) {
            System.out.println(n);

            if (n == 1)
                break;

            if (n % 2 == 0)
                n /= 2;
            else
                n = 3 * n + 1;
        }
    }

    public static long factorial(int n)
    {
        long result = 1L;

        for (int i = 2; i <= n; ++i)
            result *= i;

        return result;
    }

    public static int getDigitalRoot(int val)
    {
        int root = abs(val);

        while (root > 9)
            root = sumDigits(root);

        return root;
    }


    public static int getDigitsFactorialSum(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += factorial(val % 10);
            val /= 10;
        }

        return sum;
    }

    public static int getDigitsPowSum(int val)
    {
        int n = countDigits(val);
        int sum = 0;

        while (val != 0) {
            sum += pow(val % 10, n);
            val /= 10;
        }

        return sum;
    }

    public static int getFibonacciNumber(int n)
    {
        if (n <= 0)
            return -1;

        if (n <= 2)
            return n - 1;

        int prev1 = 1, prev2 = 0, val = 0;

        for (int i = 2; i < n; ++i) {
            val = prev1 + prev2;
            prev2 = prev1;
            prev1 = val;
        }

        return val;
    }

    public static int getIndexOfPrimeNumber(int n)
    {
        int index = 1;
        int val = 2;

        for (;;) {
            if (val == n)
                return index;

            if (isPrime(val))
                ++index;

            ++val;
        }
    }

    public static int getNextFibonacciNumber(int val)
    {
        if (val < 0)
            return 0;

        int prev1 = 1, prev2 = 0, result;

        for (;;) {
            result = prev1 + prev2;

            if (result > val)
                return result;

            prev2 = prev1;
            prev1 = result;
        }
    }

    public static int getPrime(int n)
    {
        if (n <= 0)
            return -1;

        int count = 0;
        int val = 2;

        for (;;) {
            if (isPrime(val))
                ++count;

            if (count == n)
                return val;

            ++val;
        }
    }

    public static boolean isArmstrong(int val)
    {
        return val >= 0 && getDigitsPowSum(val) == val;
    }

    public static boolean isDecimalHarshad(int val)
    {
        if (val < 0)
            return false;

        return val % sumDigits(val) == 0;
    }

    public static boolean isEven(int val)
    {
        return val % 2 == 0;
    }

    public static boolean isFactorian(int val)
    {
        if (val <= 0)
            return false;

        return getDigitsFactorialSum(val) == val;
    }

    public static boolean isHardyRamanujan(int val)
    {
        if (val <= 0)
            return false;

        int count = 0;

        for (int x = 1; x * x * x < val;) {
            for (int y = x + 1; x * x * x + y * y * y <= val; ++y)  {
                if (x * x * x + y * y * y == val) {
                    ++count;
                    ++x;
                }
            }
            ++x;
        }

        return count >= 2;
    }

    public static boolean isOdd(int val)
    {
        return !isEven(val);
    }

    public static boolean isPalindrome(int val)
    {
        return reversed(val) == val;
    }

    public static boolean isPrime(int val)
    {
        if (val <= 1)
            return false;

        if (val % 2 == 0)
            return val == 2;

        if (val % 3 == 0)
            return val == 3;

        if (val % 5 == 0)
            return val == 5;

        if (val % 7 == 0)
            return val == 7;

        for (int i = 11; i * i <= val; i += 2)
            if (val % i == 0)
                return false;

        return true;

    }

    public static boolean isSuperPrime(int val)
    {
        return isPrime(val) && isPrime(getIndexOfPrimeNumber(val));
    }

    public static int max(int a, int b, int c)
    {
        return Math.max(Math.max(a, b),  c);
    }

    public static int min(int a, int b, int c)
    {
        return Math.min(Math.min(a, b),  c);
    }

    public static int reversed(int val)
    {
        int reverse = 0;

        while (val != 0) {
            reverse = reverse * 10 + val % 10;
            val /= 10;
        }

        return reverse;
    }

    public static int sumDigits(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += val % 10;
            val /= 10;
        }

        return Math.abs(sum);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;
import static java.lang.Character.*;

public class StringUtil {
    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        String result = "";
        int length = sourceText.length();

        for (int i = 0; i < n; ++i)
            result += sourceText.charAt(r.nextInt(length));

        return result;
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, "ABCDEFGHIJKLMNOPQRSTUWXVYZabcdefghijklmnopqrstuvwxyz");
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        String str = "";

        for (int i = s.length() - 1; i >= 0; --i)
            str += s.charAt(i);

        return str;
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.*;


public class Point {
	public int x;
	public int y;

	public Point()
	{
	}

	public Point(int a)
	{
		x = a;
	}

	public Point(int a, int b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(int a, int b)
	{
		return sqrt((x - a) * (x - a) + (y - b) * (y - b));
	}

	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("{x : %d, y : %d}", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Yıldızsız import bildiriminin genel biçimi:
    import static <paket ismi>[.alt paketler].<tür ismi>.<static eleman ismi>;
    Bu bildirim ile belirtilen static eleman ilgili derleme biriminde doğrudan kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static java.lang.Math.PI;
import static org.csystem.util.NumberUtil.isPrime;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            int val = r.nextInt(100);

            if (isPrime(val))
                System.out.printf("%f * %d = %f%n", PI,  val, PI * val);
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	NumberUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import static java.lang.Math.log10;
import static java.lang.Math.abs;
import static java.lang.Math.pow;

public class NumberUtil {
    public static int countDigits(int val)
    {
        return val == 0 ? 1 : (int)log10(abs(val)) + 1;
    }

    public static void displayCollatz(int n)
    {
        if (n <= 0) {
            System.out.println("Geçersiz değer");
            return;
        }

        for (;;) {
            System.out.println(n);

            if (n == 1)
                break;

            if (n % 2 == 0)
                n /= 2;
            else
                n = 3 * n + 1;
        }
    }

    public static long factorial(int n)
    {
        long result = 1L;

        for (int i = 2; i <= n; ++i)
            result *= i;

        return result;
    }

    public static int getDigitalRoot(int val)
    {
        int root = abs(val);

        while (root > 9)
            root = sumDigits(root);

        return root;
    }


    public static int getDigitsFactorialSum(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += factorial(val % 10);
            val /= 10;
        }

        return sum;
    }

    public static int getDigitsPowSum(int val)
    {
        int n = countDigits(val);
        int sum = 0;

        while (val != 0) {
            sum += pow(val % 10, n);
            val /= 10;
        }

        return sum;
    }

    public static int getFibonacciNumber(int n)
    {
        if (n <= 0)
            return -1;

        if (n <= 2)
            return n - 1;

        int prev1 = 1, prev2 = 0, val = 0;

        for (int i = 2; i < n; ++i) {
            val = prev1 + prev2;
            prev2 = prev1;
            prev1 = val;
        }

        return val;
    }

    public static int getIndexOfPrimeNumber(int n)
    {
        int index = 1;
        int val = 2;

        for (;;) {
            if (val == n)
                return index;

            if (isPrime(val))
                ++index;

            ++val;
        }
    }

    public static int getNextFibonacciNumber(int val)
    {
        if (val < 0)
            return 0;

        int prev1 = 1, prev2 = 0, result;

        for (;;) {
            result = prev1 + prev2;

            if (result > val)
                return result;

            prev2 = prev1;
            prev1 = result;
        }
    }

    public static int getPrime(int n)
    {
        if (n <= 0)
            return -1;

        int count = 0;
        int val = 2;

        for (;;) {
            if (isPrime(val))
                ++count;

            if (count == n)
                return val;

            ++val;
        }
    }

    public static boolean isArmstrong(int val)
    {
        return val >= 0 && getDigitsPowSum(val) == val;
    }

    public static boolean isDecimalHarshad(int val)
    {
        if (val < 0)
            return false;

        return val % sumDigits(val) == 0;
    }

    public static boolean isEven(int val)
    {
        return val % 2 == 0;
    }

    public static boolean isFactorian(int val)
    {
        if (val <= 0)
            return false;

        return getDigitsFactorialSum(val) == val;
    }

    public static boolean isHardyRamanujan(int val)
    {
        if (val <= 0)
            return false;

        int count = 0;

        for (int x = 1; x * x * x < val;) {
            for (int y = x + 1; x * x * x + y * y * y <= val; ++y)  {
                if (x * x * x + y * y * y == val) {
                    ++count;
                    ++x;
                }
            }
            ++x;
        }

        return count >= 2;
    }

    public static boolean isOdd(int val)
    {
        return !isEven(val);
    }

    public static boolean isPalindrome(int val)
    {
        return reversed(val) == val;
    }

    public static boolean isPrime(int val)
    {
        if (val <= 1)
            return false;

        if (val % 2 == 0)
            return val == 2;

        if (val % 3 == 0)
            return val == 3;

        if (val % 5 == 0)
            return val == 5;

        if (val % 7 == 0)
            return val == 7;

        for (int i = 11; i * i <= val; i += 2)
            if (val % i == 0)
                return false;

        return true;

    }

    public static boolean isSuperPrime(int val)
    {
        return isPrime(val) && isPrime(getIndexOfPrimeNumber(val));
    }

    public static int max(int a, int b, int c)
    {
        return Math.max(Math.max(a, b),  c);
    }

    public static int min(int a, int b, int c)
    {
        return Math.min(Math.min(a, b),  c);
    }

    public static int reversed(int val)
    {
        int reverse = 0;

        while (val != 0) {
            reverse = reverse * 10 + val % 10;
            val /= 10;
        }

        return reverse;
    }

    public static int sumDigits(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += val % 10;
            val /= 10;
        }

        return Math.abs(sum);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;
import static java.lang.Character.isWhitespace;
import static java.lang.Character.toLowerCase;
import static java.lang.Character.toUpperCase;
import static java.lang.Character.isLetter;

public class StringUtil {
    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        String result = "";
        int length = sourceText.length();

        for (int i = 0; i < n; ++i)
            result += sourceText.charAt(r.nextInt(length));

        return result;
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, "ABCDEFGHIJKLMNOPQRSTUWXVYZabcdefghijklmnopqrstuvwxyz");
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        String str = "";

        for (int i = s.length() - 1; i >= 0; --i)
            str += s.charAt(i);

        return str;
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Veri Yapısı (Data Structure): Verileri bir algoritmaya göre tutan ve istenildiğinde bu verilere erişilebilen
    yapılardır

    Diziler (Arrays):
    Elemanları aynı türden olan ve elemanların bellekte peşpeşe olarak tutulduğu veri yapılarıdır. Java'da diziler
    sınıfsal olarak temsil edilirler. Yani dizi türü bir referans türüdür. Diziler heap'de yaratılır. Şüphesiz dizi
    referansı stack'de olabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Dizi referansı bildirimi Java'da iki şekilde yapılabilir:
    T bir tür olmak üzere

    T [] a;
    T b[];

    Biz birinci bildirim biçimini kullanacağız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int [] a; //dizi referansı bildirimi
        int b[]; //dizi referansı bildirimi
        double [] c; //dizi referansı bildirimi
        float d[]; //dizi referansı bildirimi

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    []'in referans bildiriminde bulunduğu yere göre farkları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int [] a, b, c;
        int d[], e, f;

        b = 10; //error
        e = 20;
        f = 30;



    }
}
/*----------------------------------------------------------------------------------------------------------------------
    Dizi yaratmak için new operatörü kullanılır. Dizi yaratmanın genel biçimi:
    new <tür>[<dizinin negatif olmayan int türden (int'e doğrudan dönüşebilen) eleman sayısı>];
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int [] a;

        a = new int[10];

        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dizinin eleman sayısı değişken olarak da verilebilir. Dizinin eleman sayısı bilgisi negatif bir değer olarak
    verilirde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        int [] a;

        a = new int[n];

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dizinin uzunluğu (eleman sayısı) length isimli veri elemanı ile elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        int [] a;

        a = new int[n];

        System.out.printf("Length:%d%n", a.length);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    length veri elemanına atama yapılamaz. Zaten bir dizinin yaratıldıktan sonra uzunluğu değiştirilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        int [] a;

        a = new int[n];

        System.out.printf("Length:%d%n", a.length);

        a.length *= 2; //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dizinin elemanlarına [] operatörü ile erişilir. Bu operatör iki operandlı (binary) ve araek (infix) bir operatördür.
    Ürettiği değer erişilen elemanın değişkenidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        int [] a;

        a = new int[n];

        for (int i = 0; i < a.length; ++i)
            a[i] = i + 1;

        for (int i = 0; i < a.length; ++i)
            System.out.printf("%d ", a[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dizinin elemanlarına erişim
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        int [] a;

        a = new int[n];

        for (int i = 0; i < a.length; ++i)
            a[i] = r.nextInt(100);

        for (int i = 0; i < a.length; ++i)
            System.out.printf("%02d ", a[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    [] operatörüne pozitif ya da negatif bakımdan sınırlar dışında bir değer verildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        int [] a;

        a = new int[n];

        for (int i = 0; i < a.length; ++i)
            a[i] = r.nextInt(100);

        System.out.printf("a[4]=%d%n", a[4]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir dizi yaratılıdığında tüm elemanlarına default değerler atanır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        int [] a;

        a = new int[n];

        for (int i = 0; i < a.length; ++i)
            System.out.printf("%d ", a[i]);

        System.out.println();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir dizi yaratılıdığında tüm elemanlarına default değerler atanır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        boolean []flags;

        flags = new boolean[n];

        for (int i = 0; i < flags.length; ++i)
            System.out.printf("%b ", flags[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte flags referansı ** ile belirtilen ifade için artık yeni bir diziyi gösterir duruma gelir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());
        boolean []flags;

        flags = new boolean[n];

        for (int i = 0; i < flags.length; ++i)
            System.out.printf("%b ", flags[i]);

        System.out.println();

        flags = new boolean[2 * n]; //***

        for (int i = 0; i < flags.length; ++i)
            System.out.printf("%b ", flags[i]);

        System.out.println();

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dizilere ilkdeğer verilmesi (initialization) küme parantezi ile yapılır. Burada [] içerisi boş bırakılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int [] a;

        a = new int[] {1, 2, 3, 4, 5};

        for (int i = 0; i < a.length; ++i)
            System.out.printf("%d ", a[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dizilere ilkdeğer verilmesi sırasında küme paranetezi içerisindeki son elemandan sonra yazılan virgül (trailing comma)
    geçerlidir. Dizinin eleman sayısını değiştirmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int [] a;

        a = new int[] {1, 2, 3, 4, 5,};

        System.out.printf("Length:%d%n", a.length);

        for (int i = 0; i < a.length; ++i)
            System.out.printf("%d ", a[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Diziye ilkdeğer verilirken dizinin adresinin atandığı referansa da ilkdeğer veriliyorsa new operatörü kullanılması
    gerekmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int [] a = {1, 3, 5, 2, 4, 5, 2,};

        System.out.printf("Length:%d%n", a.length);

        for (int i = 0; i < a.length; ++i)
            System.out.printf("%d ", a[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki ilkdeğer verme ifadesinden new operatörü kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int [] a;

        a = {1, 3, 5, 2, 4, 5, 2,}; //error

        System.out.printf("Length:%d%n", a.length);

        for (int i = 0; i < a.length; ++i)
            System.out.printf("%d ", a[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Diziye ilkdeğer olarak verilen elemanlar sabit ifadesi olmak zorunda değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int x = Integer.parseInt(kb.nextLine());

        int [] a = {x, x + 1, x + 2, x + 30,};

        for (int i = 0; i < a.length; ++i)
            System.out.printf("%d ", a[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir metodun parametresi bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String [] args)
    {
        int [] a = {3, -5, 7, 9, 10};

        ArrayUtil.display(a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir metodun parametresi bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String [] args)
    {
        int [] a = {3, -5, 7, 9, 10};

        ArrayUtil.display(a);
        ArrayUtil.swap(a, 2, 4);
        ArrayUtil.display(a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir metodun geri dönüş değer bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;

class App {
    public static void main(String [] args)
    {
        Random r = new Random();
        int [] a = ArrayUtil.generateRandomArray(r, 10, 10, 20);

        ArrayUtil.display(a);
        ArrayUtil.swap(a, 2, 4);
        ArrayUtil.display(a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayUtil sınıfının generateRandomArray metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static org.csystem.util.ArrayUtil.*;

class App {
    public static void main(String [] args)
    {
        int [] a = generateRandomArray(10, 10, 20);

        display(a);
        swap(a, 2, 4);
        display(a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elamanlarını parametresi ile aldığı min ve max
    değerleri için [min, max) aralığında rasgele değerlerle dolduran fillRandomArray metodunu ArrayUtil sınıfı içerisinde
    yazınız ve test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

import static org.csystem.util.ArrayUtil.*;

class App {
    public static void main(String [] args)
    {
        Random r = new Random();
        int [] a = new int[10];
        fillRandomArray(r, a, 10, 20);

        display(a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanlarının toplamını döndüren sum isimli
    metodu ArrayUtil sınıfı içerisinde yazınız ve elemanları rasgele üretilmiş diziler ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.ArrayUtil.*;

class App {
    public static void main(String [] args)
    {
        SumTest.run();
    }
}

class SumTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            int [] a = generateRandomArray(r, n, 1, 100);
            display(a);
            System.out.printf("Toplam:%d%n", sum(a));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir diziyi teryüz eden reverse isimli metodu yazınız ve test ediniz.
    Metodu ikinci bir dizi kullanmadan yazınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.ArrayUtil.*;

class App {
    public static void main(String [] args)
    {
        ReverseTest.run();
    }
}

class ReverseTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            int [] a = generateRandomArray(r, n, 1, 100);
            display(a);
            reverse(a);
            display(a);
            System.out.println("-----------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir diziyi teryüz eden reverse isimli metodu yazınız ve test ediniz.
    Metodu ikinci bir dizi kullanmadan yazınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.ArrayUtil.*;

class App {
    public static void main(String [] args)
    {
        ReverseTest.run();
    }
}

class ReverseTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            int [] a = generateRandomArray(r, n, 1, 100);
            display(a);
            Util.reverse(a);
            display(a);
            System.out.println("-----------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Util {
    public static void reverse(int [] a)
    {
        int left = 0;
        int right = a.length - 1;

        while (left < right)
            swap(a, left++, right--);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Java'da length bilgisi sıfır olan dizi yaratılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int [] a = new int[0];
        int [] b = {};

        System.out.printf("Length:%d%n", a.length);
        System.out.printf("Length:%d%n", b.length);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elamanlarını yine parametresi ile aldığı değer
    kadar karıştıran shuffle isimli metodu yazınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        ShuffleTest.run();
    }
}

class ShuffleTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n == 0)
                break;

            int [] a = ArrayUtil.generateRandomArray(r, n, 0, 14);

            ArrayUtil.display(a);
            Util.shuffle(r, a, 100);
            ArrayUtil.display(a);
        }
    }
}

class Util {
    public static void shuffle(Random r, int [] a, int count)
    {
        int i, k;

        while (count-- > 0) {
            while ((i = r.nextInt(a.length)) == (k = r.nextInt(a.length)))
                ;
            swap(a, i, k);
        }
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    21.02.2021
    ArrayUtil sınıfının display metotları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String [] args)
    {
        int [] a = ArrayUtil.generateRandomArray(30, 0, 100);

        ArrayUtil.display(3, a);
        System.out.println("//////////////////");
        ArrayUtil.display(a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Homework-003-2. sorunun bir çözümü
    (Kod ödev verilen zamandaki bilgilere göre yazılmıştır)
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String[] args)
    {
        IsPrimeXTest.run();
    }
}

class IsPrimeXTest {
    public static void run()
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);

        for (;;) {
            System.out.print("Sayıyı giriniz:");
            int val = Integer.parseInt(kb.nextLine());

            if (val == -999)
                return;

            System.out.println(NumberUtil.isPrimeX(val) ? "Özel asal sayı" : "Özel asal sayı değil");
        }
    }
}

class NumberUtil {
    public static boolean isPrime(int val)
    {
        if (val <= 1)
            return false;

        if (val % 2 == 0)
            return val == 2;

        if (val % 3 == 0)
            return val == 3;

        if (val % 5 == 0)
            return val == 5;

        if (val % 7 == 0)
            return val == 7;

        int sqrtVal = (int)Math.sqrt(val);

        for (int i = 11; i <= sqrtVal; i += 2)
            if (val % i == 0)
                return false;

        return true;

    }

    public static boolean isPrimeX(int val)
    {
        do {
            if (!isPrime(val))
                return false;
            val = sumDigits(val);
        } while (val > 9);

        return isPrime(val);
    }

    public static int sumDigits(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += val % 10;
            val /= 10;
        }

        return Math.abs(sum);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamanklarından oluşan diziyi döndüren getDigits isimli
    metodu NumberUtil sınıfı içerisinde yazınız ve test ediniz. Metot negatif sayılar için basamak değerlerini yine
    pozitif olarak verecektir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;
import org.csystem.util.NumberUtil;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        GetDigitsTest.run();
    }
}

class GetDigitsTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int val = Integer.parseInt(kb.nextLine());

            ArrayUtil.display(NumberUtil.getDigits(val));

            if (val == 0)
                break;
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Sayısal loto kupon üreten programı yazınız
    (İleride daha iyileri yazılacaktır)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.numericlotto.NumericLottoApp;

class App {
    public static void main(String[] args)
    {
        NumericLottoApp.run();
    }
}



package org.csystem.app.samples.numericlotto;

import org.csystem.util.ArrayUtil;

import java.util.Scanner;

public class NumericLottoApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        NumericLotto lotto = new NumericLotto();

        for (;;) {
            System.out.print("Kaç kupon oynamak istersin?");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            for (int i = 0; i < n; ++i)
                ArrayUtil.display(2, lotto.getNumbers());
        }
    }
}

package org.csystem.app.samples.numericlotto;

import java.util.Arrays;
import java.util.Random;

public class NumericLotto {
    public Random random;

    public NumericLotto()
    {
        random = new Random();
    }

    public NumericLotto(Random r)
    {
        random = r;
    }

    public int [] getNumbers()
    {
        int [] numbers = new int[6];

        for (int i = 0; i < 6; ++i) {
            boolean repeat;

            do {
                repeat = false;
                numbers[i] = random.nextInt(49) + 1;
                for (int k = 0; k < i; ++k)
                    if (numbers[k] == numbers[i]) {
                        repeat = true;
                        break;
                    }
            } while (repeat);
        }

        Arrays.sort(numbers); //Küçükten büyüğe sıralar

        return numbers;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Sayısal loto kupon üreten programı yazınız
    (Yukarıdakine göre daha iyi versiyon)
    (İleride daha iyileri yazılacaktır)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.numericlotto.NumericLottoApp;

class App {
    public static void main(String[] args)
    {
        NumericLottoApp.run();
    }
}

package org.csystem.app.samples.numericlotto;

import org.csystem.util.ArrayUtil;

import java.util.Scanner;

public class NumericLottoApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        NumericLotto lotto = new NumericLotto();

        for (;;) {
            System.out.print("Kaç kupon oynamak istersin?");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            for (int i = 0; i < n; ++i)
                ArrayUtil.display(2, lotto.getNumbers());
        }
    }
}

package org.csystem.app.samples.numericlotto;

import java.util.Random;

public class NumericLotto {
    public Random random;

    public boolean [] getFlags()
    {
        boolean [] flags = new boolean[50];

        for (int i = 0; i < 6; ++i) {
            int val;
            for (;;) {
                val = random.nextInt(49) + 1;
                if (!flags[val])
                    break;
            }
            flags[val] = true;
        }

        return flags;
    }

    public static int [] getNumbers(boolean [] flags)
    {
        int [] numbers = new int[6];

        int index = 0;

        for (int i = 1; i < 50; ++i)
            if (flags[i])
                numbers[index++] = i;

        return numbers;
    }

    public NumericLotto()
    {
        random = new Random();
    }

    public NumericLotto(Random r)
    {
        random = r;
    }

    public int [] getNumbers()
    {
        return getNumbers(getFlags());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dizilerin Sıraya Dizilmesi (Sorting):
    Dizilerin sıraya dizilmesine yönelik çok algoritma bulunmaktadır. Sıralama işleminin küçükten büyüğe yani
    artan sırada (ascending order) yapılmasında doğal sıralama (natural sort order) denir. Biz burada kabarcık
    sıralama (bubble sort) ve seçerek sıralama (selection sort) algoritmalarını kodlayacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kabarcık sıralama algoritmasında dizinin yan yana iki elemanı karşılaştırılır duruma göre yer değiştirilir. Her
    yinelemede en büyük eleman daraltılmış dizinin sonuna gider. Böylece her yinelemede askisinden bir geriye kadar
    gitmek yeterli olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        BubbleSortTest.run();
    }
}

class BubbleSortTest {
    public static void run()
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Dizinin eleman sayını giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            int [] a = ArrayUtil.generateRandomArray(r, n, 0, 100);

            ArrayUtil.display(2, a);
            boolean descending = r.nextBoolean();

            ArrayUtil.bubbleSort(a, descending);

            System.out.printf("%s sıralanmış dizi%n", descending ? "Büyükten küçüğe" : "Küçükten büyüğe");
            ArrayUtil.display(2, a);
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Seçerek sıralama algoritmasında en küçük eleman bulunur, ilk eleman ile yer değiştirilir. Dizi bir daraltılır,
    aynı şey daraltılmış dizi için de yapılır. Böylece ilerlenir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        SelectionSortTest.run();
    }
}

class SelectionSortTest {
    public static void run()
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Dizinin eleman sayını giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            int [] a = ArrayUtil.generateRandomArray(r, n, 0, 100);

            ArrayUtil.display(2, a);
            boolean descending = r.nextBoolean();

            ArrayUtil.selectionSort(a, descending);

            System.out.printf("%s sıralanmış dizi%n", descending ? "Büyükten küçüğe" : "Küçükten büyüğe");
            ArrayUtil.display(2, a);
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayUtil sınıfının partition metodu (partition algoritması kullanılmıştır)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        PartitionTest.run();
    }
}

class PartitionTest {
    public static void run()
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Dizinin eleman sayını giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            System.out.print("Eşik değerini giriniz:");
            int threshold = Integer.parseInt(kb.nextLine());

            int [] a = ArrayUtil.generateRandomArray(r, n, 0, 100);

            ArrayUtil.display(2, a);
            int index = ArrayUtil.partition(a, threshold);
            System.out.printf("Partition Index:%d%n", index);
            ArrayUtil.display(2, a);
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayUtil sınıfının partition metodu (partition algoritması kullanılmıştır)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        PartitionTest.run();
    }
}

class PartitionTest {
    public static void run()
    {
        int [] a = {-2, -3, -5, 1, -3, -7};

        ArrayUtil.display(a);
        int index = ArrayUtil.partition(a, 3);
        System.out.printf("Partition Index:%d%n", index);
        ArrayUtil.display(a);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayUtil sınıfının partition metodu (partition algoritması kullanılmıştır)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        PartitionTest.run();
    }
}

class PartitionTest {
    public static void run()
    {
        int [] a = {12, 13, 5, 10, 3, 7};

        ArrayUtil.display(a);
        int index = ArrayUtil.partition(a, 3);
        System.out.printf("Partition Index:%d%n", index);
        ArrayUtil.display(a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    27.02.2021
    ArrayUtil sınıfının getHistogramData metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        GetHistogramDataTest.run();
    }
}

class GetHistogramDataTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            int [] a = ArrayUtil.generateRandomArray(r, n, 0, 11);
            ArrayUtil.display(a);
            int [] data = ArrayUtil.getHistogramData(a, 10);
            ArrayUtil.display(data);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    char türden diziler String sınıfına benzetilebilse de örneğin dizinin elemanları değiştirilebildiğinden String'den
    farklıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        char [] c = {'a', 'n', 'k', 'a', 'r', 'a'};

        c[0] = Character.toUpperCase(c[0]);

        for (int i = 0; i < c.length; ++i)
            System.out.printf("%c",  c[i]);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    String sınıfının char türden dizi parametreli ctr'u ile char türden diziden içerisindeki karakterlerden oluşan bir
    String elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        char [] c = {'a', 'n', 'k', 'a', 'r', 'a'};

        String s = new String(c);

        System.out.println(s);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    String sınıfının toCharArray metodu ile bir String'in karakterlerinden oluşan char türden bir dizi elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String s = "ankara";

        char [] c = s.toCharArray();

        for (int i = 0; i < c.length; ++i)
            System.out.println(c[i]);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayUtil sınıfının reverse metodunun char türden dizi ile yazılmış halinin test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        ReverseTest.run();
    }
}

class ReverseTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            String s = StringUtil.getRandomTextTR(n);
            System.out.println(s);
            System.out.println(StringUtil.reverse(s));
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Homework-008-5. sorunun char türden dizi kullanarak bir çözümü
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        ChangeCaseTest.run();
    }
}

class ChangeCaseTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            String s = StringUtil.getRandomTextTR(n);
            System.out.println(s);
            System.out.println(StringUtil.changeCase(s));
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayUtil sınıfının drawHistogram metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.ArrayUtil.*;

class App {
    public static void main(String[] args)
    {
        DrawHistogramTest.run();
    }
}

class DrawHistogramTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;
            int [] a = generateRandomArray(r, n, 0, 11);
            int [] data = getHistogramData(a, 10);
            display(a);
            display(data);
            System.out.println("////////////////////////");
            drawHistogram(data, 10, '-');
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Referans dizilerinde dizinin yaratılması dizinin elemanları olan referansların gösterdikleri nesnelerin de yaratılması
    anlamına gelmez.Bu durumda programcının referans dizisinin elemanları olan referanslara da uygun nesnelerin adreslerini
    vermesi gerekir. Aşağıdaki örnekte referans dizisi yaratılmıştır ancak referansların gösterdiği nesneler olmadığı
    için errişmeye çalışmak exception oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample [] samples;

        samples = new Sample[6];

        for (int i = 0; i < samples.length; ++i)
            samples[i].x = i * 10;

        for (int i = 0; i < samples.length; ++i)
            System.out.println(samples[i].x);
    }
}

class Sample {
    public int x;

    public Sample(int a)
    {
        x = a;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problemin çözümü aşağıdaki gibi olabilir. Şüphesiz çözüm senaryoya bağlıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample [] samples;

        samples = new Sample[6];

        for (int i = 0; i < samples.length; ++i)
            samples[i] = new Sample(i * 10);

        for (int i = 0; i < samples.length; ++i)
            System.out.printf("%d ", samples[i].x);

        System.out.println();
    }
}

class Sample {
    public int x;

    public Sample(int a)
    {
        x = a;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Referans dizilerine ilkdeğer verilmesi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample(30);
        Sample k = new Sample(67);
        Sample [] samples = {new Sample(10), s, k, new Sample(34), k, new Sample(35)};

        for (int i = 0; i < samples.length; ++i)
            System.out.printf("%d ", samples[i].x);

        System.out.println();
    }
}

class Sample {
    public int x;

    public Sample(int a)
    {
        x = a;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    String dizileri prtaikte çok karşılaştığımız referans dizilerindendir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String [] names = {"ali", "kaan", "oğuz", "güray"};

        for (int i = 0; i < names.length; ++i)
            System.out.println(names[i]);
    }
}


/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgisine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek metodunu yazınız
	Açıklamalar:
		- Metot geçersiz bir tarih için -1 değerine döndecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasınddaki gün sayısının 7 ile bölümünden elde edilen kalan ile
		bulunabilir. Bu değer 0 (sıfır) için "Pazar", 1 için "Pazartesi", ..., 6 için "Cumartesi" gününe ilişkindir.
		- 1.1.1900 öncesindeki tarihler geçersiz kabul edilecektir
		- Ekran çıktısında haftanın günü bilgisini Türkçe olarak da gösteriniz. Örneğin:
			03/01/2021 Pazar
		- Parametresi ile aldığı gün, ay ve yıl bilgisine ilişkin tarihin hafta sonu olup olmadığını test eden
		isWeekend metodunu yazınız. Metot geçerlilik kontrolü yapmayacaktır
		- Parametresi ile aldığı gün, ay ve yıl bilgisine ilişkin tarihin hafta içi olup olmadığını test eden
		isWeekday metodunu yazınız. Metot geçerlilik kontrolü yapmayacaktır
		- İleride daha iyileri yazılacaktır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.date.DateApp;

class App {
    public static void main(String[] args)
    {
        DateApp.run();
    }
}

package org.csystem.app.samples.date;

public class DateApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Gün?");
			int day = Integer.parseInt(kb.nextLine());

			if (day == 0)
				break;

			System.out.print("Ay?");
			int month = Integer.parseInt(kb.nextLine());

			System.out.print("Yıl?");
			int year = Integer.parseInt(kb.nextLine());

			DateUtil.displayDateTR(day, month, year);
			System.out.println("/////////////////");
			DateUtil.displayDateEN(day, month, year);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}
package org.csystem.app.samples.date;

public class DateUtil {
	public static int [] daysOfMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	public static String [] monthsTR = {
						"", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz",
						"Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};
	public static String [] monthsEN = {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	public static String [] daysOfWeekTR = {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
	public static String [] daysOfWeekEN = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

	public static void displayDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		System.out.printf("%d %s %d %s%n", day, monthsTR[month], year, daysOfWeekTR[dayOfWeek]);

		if (isWeekend(day, month, year))
			System.out.println("Bugün kurs var tekrar yaptınız mı?");
		else
			System.out.println("Hafta sonu kurs var. Tekrar yapmayı unutmayınız!!!");
	}

	public static void displayDateEN(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Invalid Date");
			return;
		}
		System.out.printf("%d%s %s %d %s%n", day, getDaySuffix(day), monthsEN[month], year, daysOfWeekEN[dayOfWeek]);

		if (isWeekend(day, month, year))
			System.out.println("It is course day. I hope you reviewed!....");
		else
			System.out.println("There will be a course on weekend. Do not forget to review!...");
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		return dayOfWeek == 0 || dayOfWeek == 6;
	}

	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}

	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;

		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;

		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;

		return totalDays % 7;
	}

	public static int getDayOfYear(int day, int month, int year)
	{
		return isValidDate(day, month, year) ? day + getTotalDaysByMonth(month, year) : -1;
	}

	public static int getTotalDaysByMonth(int month, int year)
	{
		int totalDays = 0;

		for (int m  = month - 1; m >= 1; --m)
			totalDays += daysOfMonth[m];

		return month > 2 && isLeapYear(year) ? totalDays + 1 : totalDays;
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		if (day < 1 || day > 31 || month < 1 || month > 12)
			return false;

		return day <= (month == 2 && isLeapYear(year) ? 29 : daysOfMonth[month]);
	}

	public static String getDaySuffix(int day)
	{
		String suffix = "th";

		switch (day) {
			case 1:
			case 21:
			case 31:
				suffix = "st";
				break;
			case 2:
			case 22:
				suffix = "nd";
				break;
			case 3:
			case 23:
				suffix = "rd";
				break;
		}

		return suffix;
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının en fazla 3 basamaklı ayrılmış sayılarından
	oluşan diziyi döndüren getDigitsInThrees metodunu NumberUtil sınıfı içerisinde yazınız ve test ediniz.
	Örnek: 1234567 -> 1 234 567
	Örnek: 2345 -> 2 345
	Örnek: 567 -> 567
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;
import org.csystem.util.NumberUtil;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        GetDigitsInThreesTest.run();
    }
}

class GetDigitsInThreesTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            long val = Long.parseLong(kb.nextLine());

            ArrayUtil.display(NumberUtil.getDigits(val));
            ArrayUtil.display(NumberUtil.getDigitsInTwos(val));
            ArrayUtil.display(NumberUtil.getDigitsInThrees(val));

            if (val == 0)
                break;
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı en fazla üç basamaklı bir sayının Türkçe okunuşunu döndüren
	numberToText3DigitsTR metodunu yazınız ve test ediniz. Metot 3 basamaktan daha büyü sayılar için kontrol
	yapmayacaktır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;
import org.csystem.util.NumberUtil;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        NumberToText3DigitsTR.run();
    }
}

class NumberToText3DigitsTR {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Üç basamaklı bir sayı giriniz:");
            int val = Integer.parseInt(kb.nextLine());

            System.out.println(NumberUtil.numberToText3DigitsTR(val));

            if (val == 0)
                break;
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    28.02.2021
	Sınıf Çalışması: Klavyeden int türden bir n sayısı isteyiniz. n elemanlı bir String dizisi yaratınız. Bu dizinin
	her bir elemanı rasgele uzunlukta rasgele üretilmiş yazılarla doldurunuz. Bu işlemden sonra ArrayUtil sınıfı
	içerisinde yazacağınız parametresi ile aldığı bir String dizisini yine parametresi aldığı bir ayraç ile birleştiren
	join isimli metodu çağırarak sonucu ekrana bastırınız
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;
import org.csystem.util.StringUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        JoinWithDelimiterApp.run();
    }
}

class JoinWithDelimiterApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            System.out.print("Ayracı giriniz:");
            String sep = kb.nextLine();

            String [] texts = StringUtil.getRandomTextsTR(r, n, 5, 11);
            ArrayUtil.display(texts);
            System.out.println("---------------------");
            System.out.println(StringUtil.join(texts, sep));
            System.out.println("///////////////////////////");
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte split metodu space karakterini ayraç kabul ederek yazıyı ayrıştırmıştır. Ancak split metodu
    regex (regular expression) kullanıdığından bu şekildeki bir kullanım her karakter için doğru sonuç vermez. Ayraç
    tek bir karakterden oluşsa bile bu kullanım tavsiye edilmez. Örneği split metoduna "." argümanını geçerek ve
    yazıda boşluk yerine . koyarak test ediniz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String text = "Bugün hava çok güzel";
        String [] strings = text.split(" ");

        for (int i = 0; i < strings.length; ++i)
            System.out.println(strings[i]);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    split metodunda ile kullanılacak ayraç(lar) [ ile ] arasında yazılmalıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String text = "Bugün hava çok güzel";
        String [] strings = text.split("[ ]");

        for (int i = 0; i < strings.length; ++i)
            System.out.println(strings[i]);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    split metodunda ile kullanılacak ayraçlar [ ile ] arasında yazılmalıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String text = "Bugün hava çok güzel.Bu güzel havada ders yapıyoruz";
        String [] strings = text.split("[ .]");

        for (int i = 0; i < strings.length; ++i)
            System.out.println(strings[i]);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    split'in aşağıdaki kullanımında iki ayraç yanyana geldiğinde aralarında kalan boş string de diziye eklenir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String text = "Bugün hava  çok güzel. Bu güzel havada ders yapıyoruz";
        String [] strings = text.split("[ .]");

        for (int i = 0; i < strings.length; ++i)
            System.out.println(strings[i]);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    split metodunda yukarıdaki gibi boş string'i de diziye eklemesi istenmiyorsa ]'den sonra + konmalıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String text = "Bugün                        hava  çok güzel.............. Bu güzel havada ders yapıyoruz";
        String [] strings = text.split("[ .]+");

        for (int i = 0; i < strings.length; ++i)
            System.out.println(strings[i]);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    [ ve ] karakterlerinin ayraç olarak verilebilmesi için ters bölü ile yazılması gerekir. Hatırlanacağı gibi bir
    String sabiti (string literal) içerisinde ters bölü elde etmek için iki tane ters bölü yazılması gerekir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String text = "Bugün hava çok güzel.Bu [[[[[[güzel]]]]] havada ders yapıyoruz";
        String [] strings = text.split("[ .\\]\\[]+");

        for (int i = 0; i < strings.length; ++i)
            System.out.println(strings[i]);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kalıplar dışında başka kalıplar da gerekebilir. Bu durum az kullanıldığı burada ele alınmayacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Klavyeden aşağıdaki formatta girilen bilgiyi ayrıştırarak ekrana sonuçları yazdıran programı yazınız.
    Not: Format geçerlilik kontrolü yapılmayacaktır
    <isim>:<gg/aa/yyyy>:<ders adı>:<vize>:<final>
    Oğuz Karan:10/09/1976:Programlamaya Giriş:76:89
    Oğuz Karan:10/09/1976:Elektronik:55:40
    Bu formatta kişimin vize ve final notlarına göre vize * 0.4 + final * 0.6 formülüne göre geçme notunu hesaplayan ve
    doğum tarihinin hangi güne geldiğini de ekrana yazdıran programı yazınız
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.studentinfoparser.StudentInfoParserApp;

class App {
    public static void main(String[] args)
    {
        StudentInfoParserApp.run();
    }
}

package org.csystem.app.samples.studentinfoparser;

import java.util.Scanner;

public class StudentInfoParserConsoleApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Formatlı yazıyı giriniz:");
            String str = kb.nextLine();

            if ("quit".equals(str))
                break;
            StudentInfoParser parser = new StudentInfoParser(str);
            StudentInfo studentInfo = parser.studentInfo;

            System.out.println(studentInfo.toString());
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

package org.csystem.app.samples.studentinfoparser;

import org.csystem.app.samples.date.DateUtil;

public class StudentInfo {
    public String name;
    public String birthDate;
    public String lectureName;
    public int midtermGrade;
    public int finalGrade;

    public double getGrade()
    {
        return midtermGrade * 0.3 + finalGrade * 0.6;
    }

    public String getDate()
    {
        String [] birthDateInfo = birthDate.split("[/]");
        int day = Integer.parseInt(birthDateInfo[0]);
        int month = Integer.parseInt(birthDateInfo[1]);
        int year = Integer.parseInt(birthDateInfo[2]);

        return DateUtil.getDateTR(day, month, year);
    }

    public String toString()
    {
        double grade = getGrade();
        String fmt = "{name: %s, birthDate: %s, lectureName: %s, midtermGrade: %d, finalGrade: %d, grade: %f, status:%s}";

        return String.format(fmt, name, getDate(), lectureName, midtermGrade, finalGrade, grade,  grade >= 50 ? "Geçti" : "Kaldı");
    }
}
package org.csystem.app.samples.studentinfoparser;

public class StudentInfoParser {
    public StudentInfo studentInfo;

    //...
    public StudentInfoParser(String str)
    {
        /*
            <isim>:<gg/aa/yyyy>:<ders adı>:<vize>:<final>
            Oğuz Karan:10/09/1976:Programlamaya Giriş:76:89
        */
        String [] studentInfoStr = str.split("[:]+");

        //...

        studentInfo = new StudentInfo();
        studentInfo.name = studentInfoStr[0];
        studentInfo.birthDate = studentInfoStr[1];
        studentInfo.lectureName = studentInfoStr[2];
        studentInfo.midtermGrade = Integer.parseInt(studentInfoStr[3]);
        studentInfo.finalGrade = Integer.parseInt(studentInfoStr[4]);
    }
}

package org.csystem.app.samples.date;

public class DateUtil {
	public static int [] daysOfMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	public static String [] monthsTR = {
						"", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz",
						"Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};
	public static String [] monthsEN = {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	public static String [] daysOfWeekTR = {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
	public static String [] daysOfWeekEN = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

	public static void displayDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		System.out.printf("%d %s %d %s%n", day, monthsTR[month], year, daysOfWeekTR[dayOfWeek]);

		if (isWeekend(day, month, year))
			System.out.println("Bugün kurs var tekrar yaptınız mı?");
		else
			System.out.println("Hafta sonu kurs var. Tekrar yapmayı unutmayınız!!!");
	}

	public static void displayDateEN(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Invalid Date");
			return;
		}
		System.out.printf("%d%s %s %d %s%n", day, getDaySuffix(day), monthsEN[month], year, daysOfWeekEN[dayOfWeek]);

		if (isWeekend(day, month, year))
			System.out.println("It is course day. I hope you reviewed!....");
		else
			System.out.println("There will be a course on weekend. Do not forget to review!...");
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		return dayOfWeek == 0 || dayOfWeek == 6;
	}

	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}


	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;

		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;

		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;

		return totalDays % 7;
	}

	public static String getDateTR(int day, int month, int year)
	{
		return String.format("%d %s %d %s", day, getMonthTR(month), year, getDayOfWeekTR(day, month, year));
	}

	public static String getDayOfWeekTR(int day, int month, int year)
	{
		return daysOfWeekTR[getDayOfWeek(day, month, year)];
	}

	public static String getMonthTR(int month)
	{
		return monthsTR[month];
	}

	public static int getDayOfYear(int day, int month, int year)
	{
		return isValidDate(day, month, year) ? day + getTotalDaysByMonth(month, year) : -1;
	}

	public static int getTotalDaysByMonth(int month, int year)
	{
		int totalDays = 0;

		for (int m  = month - 1; m >= 1; --m)
			totalDays += daysOfMonth[m];

		return month > 2 && isLeapYear(year) ? totalDays + 1 : totalDays;
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		if (day < 1 || day > 31 || month < 1 || month > 12)
			return false;

		return day <= (month == 2 && isLeapYear(year) ? 29 : daysOfMonth[month]);
	}

	public static String getDaySuffix(int day)
	{
		String suffix = "th";

		switch (day) {
			case 1:
			case 21:
			case 31:
				suffix = "st";
				break;
			case 2:
			case 22:
				suffix = "nd";
				break;
			case 3:
			case 23:
				suffix = "rd";
				break;
		}

		return suffix;
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*--------------------------------------------------------------------------------------------------------------------
    Mademki T [] a ifadesi a'nın gösterdiği dizinin herbir elemanının türünün T olduğu anlamına geliyorsa örneğin
    int [][] a ifadesi "herbir elemanı bir dizi referansı olan dizi referansı" bildirimidir. a referansı
    herbir elemanı bir dizi referansı olan dizinin referansını tutar. Yani aslında a'nın gösterdiği dizi
    bir "dizi dizisidir."
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Dizi dizisi yaratılırken kullanılan new operatörüne ilişkin ifadede tür isminden sonra referans bildiriminde kullanılan
    [] kadar [] yazılmalıdır. Bu []'lerin ilki ana dizinin uzunluğunu temsil ettiği için boş bırakılamaz. Diğer []'ler
    boş bırakılabilir. int [][] türünden bir dizinin herbir lemanı olan dizi referanslarının gösterdiği dizilerin uzunlukları
    aynı ise buna mantıksal olarak matris denebilir. Yani bir matrisi temsil eder. En az bir dizinin uzunluğu diğerlerinden
    farklı ise artık matris belirtmez. Java'da çok boyutlu dizi kavramı yoktur. Bu sebeple örneğin "İki boyutlu bir dizi
    matris belirtir" Java için yanlış bir cümledir. Yani aslında Java'da matrisler de dizi dizisidir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Aşğıdaki örnekte m * n'lik bir matris yaratılmış ve elemanlarına rasgele değerler atanmıştır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);
        System.out.print("Satır sayısını giriniz:");
        int m = Integer.parseInt(kb.nextLine());

        System.out.print("Sütun sayısını giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        int [][] a;

        a = new int[m][];

        for (int i = 0; i < m; ++i)
            a[i] = new int[n];

        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                a[i][j] = r.nextInt(100);

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j)
                System.out.printf("%02d ", a[i][j]);
            System.out.println();
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Java 5 ile birlikte aşağıdaki gibi ikinci [] içerisinde yazılan uzunluk matrisin sütün sayısı anlamına gelir. Yani
    dizi dizisinin herbir elemanının gösterdiği dizilerde o uzunlukta otomatik olarak yaratılır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);
        System.out.print("Satır sayısını giriniz:");
        int m = Integer.parseInt(kb.nextLine());

        System.out.print("Sütun sayısını giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        int [][] a;

        a = new int[m][n];

        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                a[i][j] = r.nextInt(100);

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j)
                System.out.printf("%02d ", a[i][j]);
            System.out.println();
        }
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Bir metodun parametresi dizi dizisi referansı olabilir. Bir metot dizi dizisi referansına dönebilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);
        System.out.print("Satır sayısını giriniz:");
        int m = Integer.parseInt(kb.nextLine());

        System.out.print("Sütun sayısını giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        int [][] a;

        a = ArrayUtil.generateRandomMatrix(r, m, n, 0, 100);

        ArrayUtil.display(2, a);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Dizi dizilerine ilkdeğer verilmesi
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        int [][] a = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};

        ArrayUtil.display(2, a);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Dizi dizilerine ilk değer verirken içteki diziler için new operatörünün kullanımı geçerli olsa da hiçbir zaman
    yazılmasına gerek olmaz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        int [][] a;

        a = new int[][]{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};

        ArrayUtil.display(2, a);
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    06.03.2021
    Sınıf Çalışması: Parametresi ile aldığı int türden bir dizi dizisinin elemanlarının toplamını döndüren sum
    isimli metodu ArrayUtil sınıfı içerisinde yazınız ve test ediniz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        SumTest.run();
    }
}

class SumTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n == 0)
                break;

            int [][] a = ArrayUtil.generateRandomSquareMatrix(r, n, 0, 100);
            ArrayUtil.display(2, a);
            System.out.printf("Toplam:%d%n", ArrayUtil.sum(a));
        }
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı matrisin devriğini (transpose) döndüren transpose isimli metodu yazınız
    ve test ediniz
    Not: "Matris mi ? değil mi?" kontrolü yapılmayacaktır
    Örnek:
    1 2 3
    4 5 6

    1 4
    2 5
    3 6
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        TransposeTest.run();
    }
}

class TransposeTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Satır sayısını giriniz:");
            int row = Integer.parseInt(kb.nextLine());

            if (row == 0)
                break;

            System.out.print("Sütun sayısını giriniz:");
            int col = Integer.parseInt(kb.nextLine());

            int [][] a = ArrayUtil.generateRandomMatrix(r, row, col, 0, 100);
            ArrayUtil.display(2, a);
            System.out.println("//////////////////////////");
            ArrayUtil.display(2, ArrayUtil.transpose(a));
        }
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden dizi dizisinin matris olup olmadığını test eden isMatrix isimli
    metodu ve parametresi ile aldığı dizi dizisinin bir kare matris olup olmadığını test eden isSquareMatrix
    isimli metodu ArrayUtil sınıfı içerisinde yazınız ve test ediniz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static org.csystem.util.ArrayUtil.*;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        IsMatrixSquareMatrixTest.run();
    }
}

class IsMatrixSquareMatrixTest {
    public static int [][] getArray(Random r, int row, int col)
    {
        return r.nextBoolean() ? generateRandomMatrix(r, row, col, 0, 100) : generateRandomSquareMatrix(r, row, 0, 100);
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Satır sayısını giriniz:");
            int row = Integer.parseInt(kb.nextLine());

            if (row == 0)
                break;

            System.out.print("Sütun sayısını giriniz:");
            int col = Integer.parseInt(kb.nextLine());

            int [][] a = getArray(r, row, col);
            display(2, a);
            System.out.println("//////////////////////////");
            System.out.println(isMatrix(a) ? "Matris" : "Matris değil");
            System.out.println(isSquareMatrix(a) ? "Kare matris" : "Kare matris değil");
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir kare matrisin esas köşegeni üzerindeki elemanlarının
    toplamını döndüren sumDiagonal isimli metodu yazınız ve test ediniz.
    Açıklamalar:
    - Metot matris veya kare matris kontrolü yapmayacktır
    - Metodun testini elemanları rasgele üretilmiiş kare matrisler ile yapınız.
    - Bir kare matrisin esas köşegen üzerindeki elemanları: Örneğin:
    1 2 3
    4 5 6
    7 8 9
    matrisi için
    1 5 ve 7 elemanlarıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.ArrayUtil.*;

class App {
    public static void main(String[] args)
    {
        SumDiagonalTest.run();
    }
}

class SumDiagonalTest {

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n == 0)
                break;

            int [][] a = generateRandomSquareMatrix(r, n, 0, 100);
            display(2, a);
            System.out.printf("Esas Köşegen Elemanları Toplamı:%d%n", sumDiagonal(a));
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sayısal loto kupon üreten program
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.numericlotto.NumericLottoApp;

class App {
    public static void main(String[] args)
    {
        NumericLottoApp.run();
    }
}

package org.csystem.app.samples.numericlotto;

import org.csystem.util.ArrayUtil;

import java.util.Scanner;

public class NumericLottoApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        NumericLotto lotto = new NumericLotto();

        for (;;) {
            System.out.print("Kaç kupon oynamak istersin?");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            ArrayUtil.display(2, lotto.getNumbers(n));
        }
    }
}

package org.csystem.app.samples.numericlotto;

import java.util.Random;

public class NumericLotto {
    public Random random;

    public boolean [] getFlags()
    {
        boolean [] flags = new boolean[50];

        for (int i = 0; i < 6; ++i) {
            int val;
            for (;;) {
                val = random.nextInt(49) + 1;
                if (!flags[val])
                    break;
            }
            flags[val] = true;
        }

        return flags;
    }

    public static int [] getNumbers(boolean [] flags)
    {
        int [] numbers = new int[6];

        int index = 0;

        for (int i = 1; i < 50; ++i)
            if (flags[i])
                numbers[index++] = i;

        return numbers;
    }

    public NumericLotto()
    {
        random = new Random();
    }

    public NumericLotto(Random r)
    {
        random = r;
    }

    public int [] getNumbers()
    {
        return getNumbers(getFlags());
    }

    public int [][] getNumbers(int n)
    {
        int [][] result = new int[n][];

        for (int i = 0; i < n; ++i)
            result[i] = getNumbers();

        return result;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Dizi dizilerine ilişkin karmaşık bildirimler
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        int [][][] a;

        a = new int[3][4][5];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                for (int k = 0; k < a[i][j].length ; ++k)
                    a[i][j][k] = i + j + k;

        //...
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Bir okulda Fizik sınavı ortak olarak yapılıyor. Kaç şube olduğu ve herbir şubede kaç öğrenci
    olduğu bilgisi klavyeden alınsın. Bu işlem sonrasında öğrencilerin notları rasgele belirlensin. Tüm bu işlemlerden
    sonra Fizik sınavı için herbir şubenin ayrı ayrı not ortalamaları ile okulun ortalamasını bulan basit bir simülasyon
    programını yazınız. Programı mümkün olduğunda genel yazmaya çalışınız
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.simulation.centralexam.ExamSimulationApp;

class App {
    public static void main(String[] args)
    {
        ExamSimulationApp.run();
    }
}

package org.csystem.app.samples.simulation.centralexam;

public class ExamSimulationApp {
    public static void run()
    {
        ExamSimulation physSimulation = new ExamSimulation("Fizik");
        ExamSimulation mathSimulation = new ExamSimulation("Matematik");

        physSimulation.run();
        mathSimulation.run();
        physSimulation.displayReport();
        mathSimulation.displayReport();
    }
}

package org.csystem.app.samples.simulation.centralexam;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ExamSimulation {
    public String lectureName;
    public int [][] grades;
    public double [] averages;
    public double average;

    public void findAverages()
    {
        int totalNumberOfStudents = 0;
        int totalGrades = 0;

        for (int i = 0; i < grades.length; ++i) {
            int total = ArrayUtil.sum(grades[i]);

            averages[i] = (double)total / grades[i].length;
            totalGrades += total;
            totalNumberOfStudents += grades[i].length;
        }

        average = (double)totalGrades / totalNumberOfStudents;
    }

    public void fillGrades()
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);
        System.out.printf("%s sınavı şube sayısını giriniz:", lectureName);
        grades = new int[Integer.parseInt(kb.nextLine())][];
        averages = new double[grades.length];

        for (int i = 0; i < grades.length; ++i) {
            System.out.printf("%d. şube öğrenci sayısı?", i + 1);
            int count = Integer.parseInt(kb.nextLine());

            grades[i] = ArrayUtil.generateRandomArray(r, count, 0, 101);
        }
    }

    public ExamSimulation(String name)
    {
        lectureName = name;
    }

    public void run()
    {
        fillGrades();
        findAverages();
    }

    public void displayGrades()
    {
        System.out.printf("%s dersi sınav notları:%n", lectureName);
        System.out.println("-------------------------------------------------------");
        for (int i = 0; i < grades.length; ++i) {
            System.out.printf("%d. şube notları:", i + 1);
            ArrayUtil.display(3, grades[i]);
        }

        System.out.println("-------------------------------------------------------");
    }

    public void displayReport()
    {
        System.out.println("*******************************************************");
        displayGrades();
        System.out.printf("%s dersi için not ortalamaları:%n", lectureName);
        System.out.println("-------------------------------------------------------");
        for (int i = 0; i < averages.length; ++i)
            System.out.printf("%d.şube not ortalaması:%f%n", i + 1, averages[i]);
        System.out.printf("Okul Ortalaması:%f%n", average);
        System.out.println("-------------------------------------------------------");
        System.out.println("*******************************************************");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public class ArrayUtil {
    public static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    public static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] > a[k])
                    swap(a, k, k + 1);
    }

    public static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }

            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    public static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] > max) {
                    max = a[k];
                    maxIndex = k;
                }

            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    public static void bubbleSort(int [] a, boolean descending)
    {
        if (descending)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void display(int [] a)
    {
        display(1, a);
    }

    public static void display(int n, int [] a)
    {
        String fmt = String.format("%%0%dd ", n);

        for (int i = 0; i < a.length; ++i)
            System.out.printf(fmt, a[i]);

        System.out.println();
    }

    public static void display(int n, int [][] a)
    {
        for (int i = 0; i < a.length; ++i)
            display(n, a[i]);
    }

    public static void display(String [] str)
    {
        display('\n', str);
    }

    public static void display(char sep, String [] str)
    {
        for (int i = 0; i < str.length; ++i)
            System.out.printf("%s%c", str[i], sep);
    }

    public static void drawHistogram(int [] data, int n, char ch)
    {
        int mavValue = max(data);

        for (int i = 0; i < data.length; ++i) {
            int count = (int)Math.ceil((double)data[i] * n / mavValue);

            while (count -- > 0)
                System.out.print(ch);

            System.out.println();
        }
    }

    public static void fillRandomArray(int [] a, int min, int max) //[min, max)
    {
        fillRandomArray(new Random(), a, min, max);
    }

    public static void fillRandomArray(Random r, int [] a, int min, int max) //[min, max)
    {
        for (int i = 0; i < a.length; ++i)
            a[i] = r.nextInt(max - min) + min;
    }

    public static int [] generateRandomArray(int n, int min, int max) //[min, max)
    {
        return generateRandomArray(new Random(), n, min, max);
    }

    public static int [] generateRandomArray(Random r, int n, int min, int max) //[min, max)
    {
        int [] a = new int[n];

        fillRandomArray(r, a, min, max);

        return a;
    }

    public static int [][] generateRandomMatrix(int row, int col, int min, int max)
    {
        return generateRandomMatrix(new Random(), row, col, min, max);
    }

    public static int [][] generateRandomMatrix(Random r, int row, int col, int min, int max)
    {
        int [][] m = new int[row][];

        for (int i = 0; i < row; ++i)
            m[i] = generateRandomArray(r, col, min, max);

        return m;
    }

    public static int [][] generateRandomSquareMatrix(int n, int min, int max)
    {
        return generateRandomSquareMatrix(new Random(), n, min, max);
    }

    public static int [][] generateRandomSquareMatrix(Random r, int n, int min, int max)
    {
        return generateRandomMatrix(r, n, n, min, max);
    }

    public static int [] getHistogramData(int [] a, int n) //[0, n]
    {
        int [] data = new int[n + 1];

        for (int i = 0; i < a.length; ++i)
            ++data[a[i]];

        return data;
    }

    public static boolean isMatrix(int [][] a)
    {
        for (int i = 1; i < a.length; ++i)
            if (a[i].length != a[0].length)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result < a[i])
                result = a[i];

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result > a[i])
                result = a[i];

        return result;
    }

    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void reverse(int [] a)
    {
        int halfLength = a.length / 2;

        for (int i = 0; i < halfLength; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] a)
    {
        int halfLength = a.length / 2;

        for (int i = 0; i < halfLength; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void selectionSort(int [] a, boolean descending)
    {
        if (descending)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i];

        return total;
    }


    public static int sum(int [][] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += sum(a[i]);

        return total;
    }

    public static int sumDiagonal(int [][] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i][i];

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(double [] a, int i, int k)
    {
        double temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static int [][] transpose(int [][] a)
    {
        int row = a.length;
        int col = a[0].length;
        int [][] t = new int[col][row];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                t[j][i] = a[i][j];

        return t;
    }

}

/*----------------------------------------------------------------------------------------------------------------------
	NumberUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import static java.lang.Math.log10;
import static java.lang.Math.abs;
import static java.lang.Math.pow;

public class NumberUtil {
    public static int [] getDigits(long val, int n)
    {
        int [] digits = new int[val == 0 ? 1 : (int)(log10(abs(val)) / n) + 1];
        int powOfTen = (int)Math.pow(10, n);

        for (int i = digits.length - 1; i >= 0; digits[i--] = (int)(val % powOfTen), val /= powOfTen)
            ;

        return digits;
    }

    public static String numberToText3DigitsTR(int val)
    {
        if (val == 0)
            return "sıfır";

        String [] ones = {"", "bir", "iki", "üç", "dört", "beş", "altı", "yedi", "sekiz", "dokuz"};
        String [] tens = {"", "on", "yirmi", "otuz", "kırk", "elli", "altmış", "yetmiş", "seksen", "doksan"};

        String str = val < 0 ? "eksi" : "";
        val = Math.abs(val);

        int a, b, c;

        a = val / 100;
        b = val / 10 % 10;
        c = val % 10;

        if (a != 0) {
            if (a != 1)
                str += ones[a];
            str += "yüz";
        }
        if (b != 0)
            str += tens[b];

        if (c != 0)
            str += ones[c];

        return str;
    }

    public static int countDigits(long val)
    {
        return val == 0 ? 1 : (int)log10(abs(val)) + 1;
    }

    public static void displayCollatz(int n)
    {
        if (n <= 0) {
            System.out.println("Geçersiz değer");
            return;
        }

        for (;;) {
            System.out.println(n);

            if (n == 1)
                break;

            if (n % 2 == 0)
                n /= 2;
            else
                n = 3 * n + 1;
        }
    }

    public static long factorial(int n)
    {
        long result = 1L;

        for (int i = 2; i <= n; ++i)
            result *= i;

        return result;
    }

    public static int getDigitalRoot(int val)
    {
        int root = abs(val);

        while (root > 9)
            root = sumDigits(root);

        return root;
    }

    public static int [] getDigits(long val)
    {
        return getDigits(val, 1);
    }

    public static int [] getDigitsInThrees(long val)
    {
        return getDigits(val, 3);
    }

    public static int [] getDigitsInTwos(long val)
    {
        return getDigits(val, 2);
    }

    public static int getDigitsFactorialSum(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += factorial(val % 10);
            val /= 10;
        }

        return sum;
    }

    public static int getDigitsPowSum(int val)
    {
        int n = countDigits(val);
        int sum = 0;

        while (val != 0) {
            sum += pow(val % 10, n);
            val /= 10;
        }

        return sum;
    }

    public static int getFibonacciNumber(int n)
    {
        if (n <= 0)
            return -1;

        if (n <= 2)
            return n - 1;

        int prev1 = 1, prev2 = 0, val = 0;

        for (int i = 2; i < n; ++i) {
            val = prev1 + prev2;
            prev2 = prev1;
            prev1 = val;
        }

        return val;
    }

    public static int getIndexOfPrimeNumber(int n)
    {
        int index = 1;
        int val = 2;

        for (;;) {
            if (val == n)
                return index;

            if (isPrime(val))
                ++index;

            ++val;
        }
    }

    public static int getNextFibonacciNumber(int val)
    {
        if (val < 0)
            return 0;

        int prev1 = 1, prev2 = 0, result;

        for (;;) {
            result = prev1 + prev2;

            if (result > val)
                return result;

            prev2 = prev1;
            prev1 = result;
        }
    }

    public static int getPrime(int n)
    {
        if (n <= 0)
            return -1;

        int count = 0;
        int val = 2;

        for (;;) {
            if (isPrime(val))
                ++count;

            if (count == n)
                return val;

            ++val;
        }
    }

    public static boolean isArmstrong(int val)
    {
        return val >= 0 && getDigitsPowSum(val) == val;
    }

    public static boolean isDecimalHarshad(int val)
    {
        if (val < 0)
            return false;

        return val % sumDigits(val) == 0;
    }

    public static boolean isEven(int val)
    {
        return val % 2 == 0;
    }

    public static boolean isFactorian(int val)
    {
        if (val <= 0)
            return false;

        return getDigitsFactorialSum(val) == val;
    }

    public static boolean isHardyRamanujan(int val)
    {
        if (val <= 0)
            return false;

        int count = 0;

        for (int x = 1; x * x * x < val;) {
            for (int y = x + 1; x * x * x + y * y * y <= val; ++y)  {
                if (x * x * x + y * y * y == val) {
                    ++count;
                    ++x;
                }
            }
            ++x;
        }

        return count >= 2;
    }

    public static boolean isOdd(int val)
    {
        return !isEven(val);
    }

    public static boolean isPalindrome(int val)
    {
        return reversed(val) == val;
    }

    public static boolean isPrime(int val)
    {
        if (val <= 1)
            return false;

        if (val % 2 == 0)
            return val == 2;

        if (val % 3 == 0)
            return val == 3;

        if (val % 5 == 0)
            return val == 5;

        if (val % 7 == 0)
            return val == 7;

        int sqrtVal = (int)Math.sqrt(val);

        for (int i = 11; i <= sqrtVal; i += 2)
            if (val % i == 0)
                return false;

        return true;

    }

    public static boolean isPrimeX(int val)
    {
        do {
            if (!isPrime(val))
                return false;
            val = sumDigits(val);
        } while (val > 9);

        return isPrime(val);
    }

    public static boolean isSuperPrime(int val)
    {
        return isPrime(val) && isPrime(getIndexOfPrimeNumber(val));
    }



    public static int max(int a, int b, int c)
    {
        return Math.max(Math.max(a, b),  c);
    }

    public static int min(int a, int b, int c)
    {
        return Math.min(Math.min(a, b),  c);
    }


    public static String numberToText(long val)
    {
        int [] digits = getDigitsInThrees(val);

        String result = "";

        //TODO:
        for (int i = 0; i < digits.length; ++i)
            result += numberToText3DigitsTR(digits[i]) + " ";

        return result;
    }

    public static int reversed(int val)
    {
        int reverse = 0;

        while (val != 0) {
            reverse = reverse * 10 + val % 10;
            val /= 10;
        }

        return reverse;
    }

    public static int sumDigits(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += val % 10;
            val /= 10;
        }

        return Math.abs(sum);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;
import static java.lang.Character.isWhitespace;
import static java.lang.Character.toLowerCase;
import static java.lang.Character.toUpperCase;
import static java.lang.Character.isLetter;

public class StringUtil {
    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static String changeCase(String s)
    {
        char [] c = new char[s.length()];

        for (int i = 0; i < c.length; ++i) {
            char ch = s.charAt(i);

            c[i] = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);
        }

        return String.valueOf(c);
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        int length = sourceText.length();
        char [] c = new char[n];

        for (int i = 0; i < n; ++i)
            c[i] = sourceText.charAt(r.nextInt(length));

        return String.valueOf(c);
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String [] getRandomTextsTR(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextTR(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, "ABCDEFGHIJKLMNOPQRSTUWXVYZabcdefghijklmnopqrstuvwxyz");
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static String [] getRandomTextsEN(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextEN(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String join(String [] str, char sep)
    {
        return join(str, sep + "");
    }

    public static String join(String [] str, String sep)
    {
        String result = "";

        for (int i = 0; i < str.length; ++i) {
            if (!result.isEmpty())
                result += sep;

            result += str[i];
        }

        return result;
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        char [] c = s.toCharArray();

        ArrayUtil.reverse(c);

        return String.valueOf(c);
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    for-each döngü deyiminin genel biçimi:
    for (<tür> <değişken> : <dolaşılabilir bir türe ilişkin referans>)
        <deyim>

   Burada dolaşılabilir (iterable) tür kavramının detayları uygulama kursunda ele alınacaktır. Diziler dolaşılabilir
   türler olduğundan for-each döngü deyimi ile kullanılabilirler.

   for-each döngü deyimi ile kod daha yalın hale gelir. Bu durumda hep for-each döngü deyimi kullanılmalıdır. Kodu
   yalınlaştırmadığı durumlarda klasik for döngü deyimi tercih edilmelidir.

   for-each döngü deyimi kodun okunabilirliğini de artırır. Yani kodu okuyan kişi for-each döngü deyimi gördüğünde dizinin
   tüm elemanlarıyla sırasıyla bir işlem yapılıyor olduğunu anlar. Okunabilirlik kullanılmadığı durum için de düşünülebilir.
   Yani kodu okuyan kişi bir dizi için klasik for döngüsü görürse "for-each ile yazılmadığına göre dizinin baştan sona
   dolaşılsa bile örneğin indekx değeri gerekiyor" anlayabilir. Yani temel kural kodun okunabilirliğini bozmadığı sürece
   her zaman for-each döngü deyimi kullanılmalıdır. for-each döngü deyimine İngilizce olarak "enhanced for, range based
   loop, special for" gibi terimler de kullanılmaktadır
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    for-each döngü deyiminin ile dizi ile kullanımında döngü değişkenine her adımda o anki elemanın değer atanır. Bu işlem
    dizinin başından sonuna kadar tekrarlanır. Aşağıdaki for-each döngü deyiminin yaklaşık karşılığı (gerçek  karşılığı değil)
    şu şekildedir:

    {
        int val;

        for (int i = 0; i < a.length; ++i) {
            val = a[i];
            System.out.printf("%d ", val);
        }
    }
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        int [] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};

        for (int val : a)
            System.out.printf("%d ", val);

        System.out.println();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    for-each döngü deyiminde döngü değişkenine atama işlemi doğrudan (implicit) yapılır. Aşağıdaki örnekte error
    oluşmaz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        int [] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};

        for (long val : a)
            System.out.printf("%d ", val);

        System.out.println();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    for-each deyiminde döngü değişkeninin faaliyet alanı (scope) döngü deyimi boyuncadır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        int [] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};

        for (int val : a)
            System.out.printf("%d ", val);

        System.out.println(val); //error
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    for-each döngü deyiminde : den sonraki ifade bir kez yapılır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        for (int val : Sample.getArray())
            System.out.printf("%d ", val);

        System.out.println();
    }
}

class Sample {
    public static int [] getArray()
    {
        System.out.println("getArray");
        return new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9};
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    for-each döngü deyiminde döngü değişkenin değeri değiştirilebilir. Bu çok işe yarar bir işlem değildir. Şüphesiz
    döngü değişkenini değiştirmek dizi elemanlarını değiştirmez
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        int [] a =  {1, 2, 3, 4, 5, 6, 7, 8, 9};

        for (int val : a) {
            val *= 2;
            System.out.printf("%d ", val);
        }

        System.out.println();

        for (int val : a)
            System.out.printf("%d ", val);

        System.out.println();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte for-each döngü deyimi kullanabilmiş olsa da kod okunabilir olmaktan çıkmıştır. Bu durumda
    programcının klasik for döngü deyimi kullanması daha uygun olur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        int [] a =  {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        int i = 0;
        int count = 0;

        for (int val : a) {
            System.out.printf("%d ", val);
            if (++count == a.length / 2)
                break;
        }

        System.out.println();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    String sınıfı for-each döngü deyimi ile kullanılamamaktadır. Teknik olarak for-each döngü deyimi "iterable" olarak
    yazılmamıştır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String s = "ankara";

        for (char c : s) //error
            System.out.println(c);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    İstenirse toCharArray metodu ile tüm karakterler yine for-each döngü deyimi ile dolaşılabilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String s = "ankara";

        for (char c : s.toCharArray())
            System.out.println(c);
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    for-each döngü deyimi ile dizilerinin dolaşılması
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        int [][] a = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {1, 9, 8}};

        for (int [] array : a) {
            for (int val : array)
                System.out.printf("%d ", val);

            System.out.println();
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public class ArrayUtil {
    public static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    public static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] > a[k])
                    swap(a, k, k + 1);
    }

    public static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }

            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    public static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] > max) {
                    max = a[k];
                    maxIndex = k;
                }

            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    public static void bubbleSort(int [] a, boolean descending)
    {
        if (descending)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void display(int [] a)
    {
        display(1, a);
    }

    public static void display(int n, int [] a)
    {
        String fmt = String.format("%%0%dd ", n);

        for (int val : a)
            System.out.printf(fmt, val);

        System.out.println();
    }

    public static void display(int n, int [][] a)
    {
        for (int [] array : a)
            display(n, array);
    }

    public static void display(String [] str)
    {
        display('\n', str);
    }

    public static void display(char sep, String [] str)
    {
        for (String s : str)
            System.out.printf("%s%c", s, sep);
    }

    public static void drawHistogram(int [] data, int n, char ch)
    {
        int mavValue = max(data);

        for (int val : data) {
            int count = (int)Math.ceil((double)val * n / mavValue);

            while (count -- > 0)
                System.out.print(ch);

            System.out.println();
        }
    }

    public static void fillRandomArray(int [] a, int min, int max) //[min, max)
    {
        fillRandomArray(new Random(), a, min, max);
    }

    public static void fillRandomArray(Random r, int [] a, int min, int max) //[min, max)
    {
        for (int i = 0; i < a.length; ++i)
            a[i] = r.nextInt(max - min) + min;
    }

    public static int [] generateRandomArray(int n, int min, int max) //[min, max)
    {
        return generateRandomArray(new Random(), n, min, max);
    }

    public static int [] generateRandomArray(Random r, int n, int min, int max) //[min, max)
    {
        int [] a = new int[n];

        fillRandomArray(r, a, min, max);

        return a;
    }

    public static int [][] generateRandomMatrix(int row, int col, int min, int max)
    {
        return generateRandomMatrix(new Random(), row, col, min, max);
    }

    public static int [][] generateRandomMatrix(Random r, int row, int col, int min, int max)
    {
        int [][] m = new int[row][];

        for (int i = 0; i < row; ++i)
            m[i] = generateRandomArray(r, col, min, max);

        return m;
    }

    public static int [][] generateRandomSquareMatrix(int n, int min, int max)
    {
        return generateRandomSquareMatrix(new Random(), n, min, max);
    }

    public static int [][] generateRandomSquareMatrix(Random r, int n, int min, int max)
    {
        return generateRandomMatrix(r, n, n, min, max);
    }

    public static int [] getHistogramData(int [] a, int n) //[0, n]
    {
        int [] data = new int[n + 1];

        for (int val : a)
            ++data[val];

        return data;
    }

    public static boolean isMatrix(int [][] a)
    {
        for (int i = 1; i < a.length; ++i)
            if (a[i].length != a[0].length)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result < a[i])
                result = a[i];

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result > a[i])
                result = a[i];

        return result;
    }

    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void reverse(int [] a)
    {
        int halfLength = a.length / 2;

        for (int i = 0; i < halfLength; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] a)
    {
        int halfLength = a.length / 2;

        for (int i = 0; i < halfLength; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void selectionSort(int [] a, boolean descending)
    {
        if (descending)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int val : a)
            total += val;

        return total;
    }


    public static int sum(int [][] a)
    {
        int total = 0;

        for (int[] array : a)
            total += sum(array);

        return total;
    }

    public static int sumDiagonal(int [][] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i][i];

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(double [] a, int i, int k)
    {
        double temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static int [][] transpose(int [][] a)
    {
        int row = a.length;
        int col = a[0].length;
        int [][] t = new int[col][row];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                t[j][i] = a[i][j];

        return t;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;
import static java.lang.Character.isWhitespace;
import static java.lang.Character.toLowerCase;
import static java.lang.Character.toUpperCase;
import static java.lang.Character.isLetter;

public class StringUtil {
    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static String changeCase(String s)
    {
        char [] c = new char[s.length()];

        for (int i = 0; i < c.length; ++i) {
            char ch = s.charAt(i);

            c[i] = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);
        }

        return String.valueOf(c);
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        int length = sourceText.length();
        char [] c = new char[n];

        for (int i = 0; i < n; ++i)
            c[i] = sourceText.charAt(r.nextInt(length));

        return String.valueOf(c);
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String [] getRandomTextsTR(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextTR(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, "ABCDEFGHIJKLMNOPQRSTUWXVYZabcdefghijklmnopqrstuvwxyz");
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static String [] getRandomTextsEN(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextEN(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String join(String [] str, char sep)
    {
        return join(str, sep + "");
    }

    public static String join(String [] str, String sep)
    {
        String result = "";

        for (String s : str) {
            if (!result.isEmpty())
                result += sep;

            result += s;
        }

        return result;
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        char [] c = s.toCharArray();

        ArrayUtil.reverse(c);

        return String.valueOf(c);
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    07.03.2021
    Homework007-1. sorunun bir çözümü
    (İleride daha iyisi yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.simulation.lotto.SpecialLottoSimulationApp;

class App {
    public static void main(String[] args)
    {
        SpecialLottoSimulationApp.run();
    }
}

package org.csystem.app.samples.simulation.lotto;

import java.util.Scanner;

public class SpecialLottoSimulationApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Kaç kez oynatmak istiyorsunuz?");
        int n = Integer.parseInt(kb.nextLine());
        SpecialLottoSimulation simulation = new SpecialLottoSimulation();

        simulation.run(n);
        System.out.printf("p1 = %f%n", simulation.firstGameWinProbability);
        System.out.printf("p1 = %f%n", simulation.secondGameWinProbability);
        System.out.printf("p1 = %f%n", simulation.thirdGameWinProbability);
    }
}

package org.csystem.app.samples.simulation.lotto;

import org.csystem.util.NumberUtil;

import java.util.Random;

public class SpecialLotto {
    public Random random;
    public boolean firstGameWinStatus;
    public boolean secondGameWinStatus;
    public boolean thirdGameWinStatus;

    public int getNumber()
    {
        return random.nextInt(99) + 1;
    }

    public int getFirst()
    {
        return getNumber();
    }

    public int getSecond(int first)
    {
        int second;

        while ((second = getNumber()) == first)
            ;

        return second;
    }

    public int getThird(int first, int second)
    {
        int third;

        while ((third = getNumber()) == first || third == second)
            ;

        return third;
    }

    public void playFirstGame(int first, int second, int third)
    {
        firstGameWinStatus = first + second + third < 150;
    }

    public void playSecondGame(int first, int second, int third)
    {
        secondGameWinStatus = NumberUtil.isPrime(first + second + third);
    }

    public void playThirdGame(int first, int second, int third)
    {
        int max = Math.max(Math.max(first, second), third);
        int min = Math.min(Math.min(first, second), third);
        int mid = first + second + third - max - min;

        thirdGameWinStatus = max - min > mid;
    }

    public SpecialLotto()
    {
        random = new Random();
    }

    public SpecialLotto(Random rand)
    {
        random = rand;
    }

    public void playFirstGame()
    {
        int first = getFirst();
        int second = getSecond(first);
        int third = getThird(first, second);

        playFirstGame(first, second, third);
    }

    public void playSecondGame()
    {
        int first = getFirst();
        int second = getSecond(first);
        int third = getThird(first, second);

        playSecondGame(first, second, third);
    }

    public void playThirdGame()
    {
        int first = getFirst();
        int second = getSecond(first);
        int third = getThird(first, second);

        playThirdGame(first, second, third);
    }

    public void play()
    {
        int first = getFirst();
        int second = getSecond(first);
        int third = getThird(first, second);

        playFirstGame(first, second, third);
        playSecondGame(first, second, third);
        playThirdGame(first, second, third);
    }
}
package org.csystem.app.samples.simulation.lotto;

import java.util.Random;

public class SpecialLottoSimulation {
    public double firstGameWinProbability;
    public double secondGameWinProbability;
    public double thirdGameWinProbability;

    public void runSimulation(int n)
    {
        SpecialLotto lotto = new SpecialLotto(new Random());

        int firstGameWinCount = 0;
        int secondGameWinCount = 0;
        int thirdGameWinCount = 0;

        for (int i = 0; i < n; ++i) {
            lotto.play();
            if (lotto.firstGameWinStatus)
                ++firstGameWinCount;

            if (lotto.secondGameWinStatus)
                ++secondGameWinCount;

            if (lotto.thirdGameWinStatus)
                ++thirdGameWinCount;
        }

        firstGameWinProbability = (double)firstGameWinCount / n;
        secondGameWinProbability = (double)secondGameWinCount / n;
        thirdGameWinProbability = (double)thirdGameWinCount / n;
    }

    public void run(int n)
    {
        runSimulation(n);
    }
}



/*--------------------------------------------------------------------------------------------------------------------
    Homework007-1. sorunun bir çözümü
    (İleride daha iyisi yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.simulation.lotto.SpecialLottoSimulationApp;

class App {
    public static void main(String[] args)
    {
        SpecialLottoSimulationApp.run();
    }
}

package org.csystem.app.samples.simulation.lotto;

import java.util.Scanner;

public class SpecialLottoSimulationApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Kaç kez oynatmak istiyorsunuz?");
        int n = Integer.parseInt(kb.nextLine());
        SpecialLottoSimulation simulation = new SpecialLottoSimulation();

        simulation.run(n);
        System.out.printf("p1 = %f%n", simulation.firstGameWinProbability);
        System.out.printf("p1 = %f%n", simulation.secondGameWinProbability);
        System.out.printf("p1 = %f%n", simulation.thirdGameWinProbability);
    }
}

package org.csystem.app.samples.simulation.lotto;

import org.csystem.util.NumberUtil;

import java.util.Random;

public class SpecialLotto {
    public Random random;
    public boolean firstGameWinStatus;
    public boolean secondGameWinStatus;
    public boolean thirdGameWinStatus;
    public int first;
    public int second;
    public int third;

    public int getNumber()
    {
        return random.nextInt(99) + 1;
    }

    public void setNumbers()
    {
        setFirst();
        setSecond();
        setThird();
    }

    public void setFirst()
    {
        first = getNumber();
    }

    public void setSecond()
    {

        while ((second = getNumber()) == first)
            ;
    }

    public void setThird()
    {
        while ((third = getNumber()) == first || third == second)
            ;
    }

    public void playFirstGame(int first, int second, int third)
    {
        firstGameWinStatus = first + second + third < 150;
    }

    public void playSecondGame(int first, int second, int third)
    {
        secondGameWinStatus = NumberUtil.isPrime(first + second + third);
    }

    public void playThirdGame(int first, int second, int third)
    {
        int max = Math.max(Math.max(first, second), third);
        int min = Math.min(Math.min(first, second), third);
        int mid = first + second + third - max - min;

        thirdGameWinStatus = max - min > mid;
    }

    public SpecialLotto()
    {
        random = new Random();
    }

    public SpecialLotto(Random rand)
    {
        random = rand;
    }

    public void playFirstGame()
    {
        setNumbers();
        playFirstGame(first, second, third);
    }

    public void playSecondGame()
    {
        setNumbers();
        playSecondGame(first, second, third);
    }

    public void playThirdGame()
    {
        setNumbers();
        playThirdGame(first, second, third);
    }

    public void play()
    {
        setNumbers();
        playFirstGame(first, second, third);
        playSecondGame(first, second, third);
        playThirdGame(first, second, third);
    }
}

package org.csystem.app.samples.simulation.lotto;

import java.util.Random;

public class SpecialLottoSimulation {
    public double firstGameWinProbability;
    public double secondGameWinProbability;
    public double thirdGameWinProbability;

    public void runSimulation(int n)
    {
        SpecialLotto lotto = new SpecialLotto(new Random());

        int firstGameWinCount = 0;
        int secondGameWinCount = 0;
        int thirdGameWinCount = 0;

        for (int i = 0; i < n; ++i) {
            lotto.play();
            if (lotto.firstGameWinStatus)
                ++firstGameWinCount;

            if (lotto.secondGameWinStatus)
                ++secondGameWinCount;

            if (lotto.thirdGameWinStatus)
                ++thirdGameWinCount;
        }

        firstGameWinProbability = (double)firstGameWinCount / n;
        secondGameWinProbability = (double)secondGameWinCount / n;
        thirdGameWinProbability = (double)thirdGameWinCount / n;
    }

    public void run(int n)
    {
        runSimulation(n);
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Homework007-2. sorunun bir çözümü
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.date.PrintRandomDateTest;

class App {
    public static void main(String[] args)
    {
        PrintRandomDateTest.run();
    }
}



package org.csystem.app.samples.date;

import java.util.Random;

public class DateUtil {
	public static int [] daysOfMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	public static String [] monthsTR = {
						"", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz",
						"Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};
	public static String [] monthsEN = {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	public static String [] daysOfWeekTR = {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
	public static String [] daysOfWeekEN = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

	public static void displayDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		System.out.printf("%d %s %d %s%n", day, monthsTR[month], year, daysOfWeekTR[dayOfWeek]);

		if (isWeekend(day, month, year))
			System.out.println("Bugün kurs var tekrar yaptınız mı?");
		else
			System.out.println("Hafta sonu kurs var. Tekrar yapmayı unutmayınız!!!");
	}

	public static void displayDateEN(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Invalid Date");
			return;
		}
		System.out.printf("%d%s %s %d %s%n", day, getDaySuffix(day), monthsEN[month], year, daysOfWeekEN[dayOfWeek]);

		if (isWeekend(day, month, year))
			System.out.println("It is course day. I hope you reviewed!....");
		else
			System.out.println("There will be a course on weekend. Do not forget to review!...");
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		return dayOfWeek == 0 || dayOfWeek == 6;
	}

	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}


	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;

		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;

		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;

		return totalDays % 7;
	}

	public static String getDateTR(int day, int month, int year)
	{
		return String.format("%d %s %d %s", day, getMonthTR(month), year, getDayOfWeekTR(day, month, year));
	}

	public static String getDayOfWeekTR(int day, int month, int year)
	{
		return daysOfWeekTR[getDayOfWeek(day, month, year)];
	}

	public static String getMonthTR(int month)
	{
		return monthsTR[month];
	}

	public static int getDayOfYear(int day, int month, int year)
	{
		return isValidDate(day, month, year) ? day + getTotalDaysByMonth(month, year) : -1;
	}

	public static int getTotalDaysByMonth(int month, int year)
	{
		int totalDays = 0;

		for (int m  = month - 1; m >= 1; --m)
			totalDays += daysOfMonth[m];

		return month > 2 && isLeapYear(year) ? totalDays + 1 : totalDays;
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		if (day < 1 || day > 31 || month < 1 || month > 12)
			return false;

		return day <= (month == 2 && isLeapYear(year) ? 29 : daysOfMonth[month]);
	}

	public static String getDaySuffix(int day)
	{
		String suffix = "th";

		switch (day) {
			case 1:
			case 21:
			case 31:
				suffix = "st";
				break;
			case 2:
			case 22:
				suffix = "nd";
				break;
			case 3:
			case 23:
				suffix = "rd";
				break;
		}

		return suffix;
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}

	public static void printRandomDate()
	{
		Random r = new Random();
		int year = r.nextInt(2100 - 1900 + 1) + 1900;
		int month = r.nextInt(12) + 1;
		int day = r.nextInt(month == 2 && isLeapYear(year) ? 29 : daysOfMonth[month]) + 1;

		System.out.printf("%d%s %s %d%n", day, getDaySuffix(day), monthsEN[month], year);
	}
}


package org.csystem.app.samples.date;

public class PrintRandomDateTest {
    public static void run()
    {
        for (int i = 0; i < 20; ++i)
            DateUtil.printRandomDate();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Homework001-2. sorunun bir çözümü
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.NumberUtil;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        MidTest.run();
    }
}

class MidTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Birinci sayıyı giriniz:");
            int a = Integer.parseInt(kb.nextLine());

            System.out.print("İkinci sayıyı giriniz:");
            int b = Integer.parseInt(kb.nextLine());

            System.out.print("Üçüncü sayıyı giriniz:");
            int c = Integer.parseInt(kb.nextLine());

            System.out.println(NumberUtil.mid(a, b, c));
            System.out.println(NumberUtil.mid(b, a, c));
            System.out.println(NumberUtil.mid(c, a, b));
            System.out.println(NumberUtil.mid(a, c, b));
            System.out.println(NumberUtil.mid(c, b, a));
            System.out.println(NumberUtil.mid(b, c, a));

            if (a == 0)
                break;
        }
    }
}



/*--------------------------------------------------------------------------------------------------------------------
    Sınıf elemanlarının temel erişim belirleyicileri:
    Sınıf elemanlarının (veri elemanları, metotlar, ctor'lar vb.) erişim belirleyicileri 4(dört) tanedir:
    public, protected, no-modifier, private.
    Erişim belirleyici anlamında sınıf dört bölüme ayrılmıştır. Yani örneğin sınıfın public bir elemanı sınıfın
    public bölümüne eklenmiş olur. Erişim belileyiciler sınıf dışından erişim için anlamlıdır. Sınıfın dışı başka
    bir sınıfın içi demektir. Sınıfın içinde erişim belirleyici anlamında bir kısıt yoktur. Yani sınıf içerisinde her
    bölüme erişilebilir.

    Anahtar Notlar: Sınıfın no-modifier elemanı (hiçbir erişim belirleyici yazılmaması) Java'da erişim anlamında
    diğerlerinden (public, protected, private) farklıdır. Bazı dillerde olduğu gibi no-modifier diğerlerinden biri anlamına
    gelmez. Bu durumun bir tek enum class'larda istisnası vardır. İleride ele alınacaktır

    Sınıfın protected ve no-modifier bölümlerinin anlamları sınıfların aynı pakette veya farklı pakette olmasına
    göre değişmektedir. private ve public bölümlerinin anlamları aynı pakette veya farklı pakette değişmemektedir
---------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın public bölümüne sınıf dışından erişilebilir
---------------------------------------------------------------------------------------------------------------------*/
package test;

public class A {
    public int a;

    public A()
    {}

    public void foo()
    {
        //...
    }
}

package test;

public class B {
    public void bar()
    {
        A x = new A();

        x.a = 10;
        x.foo();
    }
}



/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın public bölümüne sınıf dışından erişilebilir
---------------------------------------------------------------------------------------------------------------------*/
package test;

public class A {
    public int a;

    public A()
    {}

    public void foo()
    {
        //...
    }
}

package mest;

import test.A;

public class B {
    public void bar()
    {
        A x = new A();

        x.a = 10;
        x.foo();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın private bölümüne sınıf dışından erişilemez
---------------------------------------------------------------------------------------------------------------------*/
package test;

public class A {
    private int a;

    private A()
    {}

    private void foo()
    {
        //...
    }
}

package test;

public class B {
    public void bar()
    {
        A x = new A(); //error

        x.a = 10; //error
        x.foo(); //error
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın private bölümüne sınıf dışından erişilemez
---------------------------------------------------------------------------------------------------------------------*/
package test;

public class A {
    private int a;

    private A()
    {}

    private void foo()
    {
        //...
    }
}

package mest;

import test.A;

public class B {
    public void bar()
    {
        A x = new A(); //error

        x.a = 10; //error
        x.foo(); //error
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Görüldüğü gibi sınıfın public ve private bölümlerinin anlamları aynı pakette olan (frieendly) sınıflar ve
    farklı pakette olan sınıflar açısında değişiklik göstermemektedir
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın no-modifier bölümü aynı paketteki diğer sınıflar için public anlamındadır (friendly)
---------------------------------------------------------------------------------------------------------------------*/
package test;

public class A {
    int a;

    A()
    {}

    void foo()
    {
        //...
    }
}


package test;

public class B {
    public void bar()
    {
        A x = new A();

        x.a = 10;
        x.foo();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın no-modifier bölümü farklı paketteki diğer sınıflar için private anlamındadır
---------------------------------------------------------------------------------------------------------------------*/

package test;

public class A {
    int a;

    A()
    {}

    void foo()
    {
        //...
    }
}


package mest;

import test.A;

public class B {
    public void bar()
    {
        A x = new A(); //error

        x.a = 10; //error
        x.foo(); //error
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın protected bölümü aynı paketteki diğer sınıflar için public anlamındadır
---------------------------------------------------------------------------------------------------------------------*/
package test;

public class A {
    protected int a;

    protected A()
    {}

    protected void foo()
    {
        //...
    }
}

package test;

public class B {
    public void bar()
    {
        A x = new A();

        x.a = 10;
        x.foo();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın protected bölümü farklı paketteki diğer sınıflar için "türetme/kalıtım (inheritance)" söz konusu değilse
    private anlamındadır. Farklı pakette ancak "türemiş sınıf (derived class/sub class)" kendisine ait protected
    bölüme erişebilir. Türetme ve protected bölümün anlamı ileride detaylı olarak ele alınacaktır
---------------------------------------------------------------------------------------------------------------------*/
package test;

public class A {
    protected int a;

    protected A()
    {}

    protected void foo()
    {
        //...
    }
}

package mest;

import test.A;

public class B {
    public void bar()
    {
        A x = new A(); //error

        x.a = 10; //error
        x.foo(); //error
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Sınıf elemanlarının bölümlerine erişim durumları:
    Erişim Belirleyici      Kendisi     Aynı paketteki diğer sınıflar   Farklı paketteki diğer sınıflar     Türemiş sınıflar
    public                     T                    T                               T                              T
    protected                  T                    T                               F                              T
    no-modifier                T                    T                               F                              F
    private                    T                    F                               F                              F
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfların özellikle veri elemanlarının gizlenmesine (yani diğer sınıflardan erişilememesine) nesne yönelimli
    programlama tekniğinde "kapsülleme/sınıfsal temsil (encapsulation)" denir. Bu kavramın geneline
    "veri/bilgi gizleme (data/information hiding)" denir. Burada temel amaç dışarıyı yani sınıf dışını ilgilendirmeyecek
    verilerin/bilgilerin dışarıya verilmemesidir. Bu kavram gerçek hayattan programlamaya aktarılmıştır.
    Örneğin, televizyon izlerken televizyonun içsel detaylarının (donanmım, yazılım vb.) bilinmesi gerekmez. Çünkü
    televizyon izlerken bu bilgilerin kullanılması gerekmez. Bilinse bile izlerken anlamı olmaz.

    Bu anlamda sınıfı yazan (server) ve sınıfı kullanan (client) bakış açısı farklıdır. Şüphesiz sınıfın yazan için
    iki bakış açısı da düşünülmelidir. Sınıfı kullanan bakış açısı ise (müşteri kodlar) içsel detayı bilmek zorunda
    değildir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Programlamada isimlendirme için bazı teknikler kullanılmaktadır. Bu teknikler dışında da isimlendirme
    yapılabilir. Bunlar çok kullanılan ve bilinen tekniklerdir:
    1. Unix stili (snake case): Bu isimlendirmede karakterlerin tamamı küçük harfle yazılır ve birden fazla kelimeden
    oluşan isimlerde kelimeler arasına alttire karakteri konur. Bu isimlendirme Java'da çok tercih edilmez.
    Örnek:
        number_of_devices, serial_port

    2. Camel case (lower camel case): Bu isimlendirmede kelimeler bitişik yazılır. İlk kelimenin baş harfi küçük, diğer
    kelimelerin baş harfleri büyük harf olarak yazılır. Geri kalan karakterler de küçük harfle yazılır. Bu isimlendirme
    Java'da genel olarak yerel değişkenlerde, metot isimlerinde ve parametre değişken isimlerinde tercih edilir.
    Örneğin:
        parseInt, nextInt, nextBoolean, isPrime

    3. Pascal case (upper camel case): Bu isimlendirmede kelimeler bitişik yazılır. Tüm kelimelerin baş harfleri büyük
    geri kalan karakterler ise küçük harflerle yazılır.Bu isimlendirme Java'da genel olarak sınıf ve benzeri tür
    isimlendirmelerinde kullanılır.
    Örneğin:
        Random, String, ArrayUtil, LottaryApp

    İsimlendirmede bunlardan biri ya da birden fazlası kullanılabilir. Kullanılmak zorunda da değildir. Örneğin Java'da
    paket isimlerinin tamamı küçük harfle ve birden fazla kelimeden oluşanlar bitişik yazılır.
    Örneğin:
        org.csystem.util, java.lang, android.os, java.util, org.csystem.android.application.scratchpad

    Yukarıdaki anlatılan teknikler tamamen geneldir. Hatta bazen bir teknik biraz değiştirilerek de kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Nesne yönelimli programlamada sınıfın özellikle private bölümündeki veri elemanlarının isimlendirilmesine yönelik
    bazı teknikler kullanılmaktadır. Örneğin bazı programcılar private veri elemanları için "m_", "d_", "_", "m" gibi
    önekler kullanabilir. Biz sınıfın private veri elemanları için "m_" önekini kullanacağız. Veri elemanı static ise
    "ms_" önekini kullanacağız.
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Bir veri elemanı gizlendiğinde sınıfın müşteri kodlarının bu elemana değer ataması veya elemanın değerini elde
    etmesi için public metotlar yazılabilir. Veri elemanlarına erişip değerini elde etmek için yazılan metotlara
    "get metotları (getters)" denir. Veri elemanlarına erişip değerini değiştirmeye yarayan metotlara ise
    "set metotları (setters)" denir. Sınıfın bu şekildeki metotlarına "accessors" denir. Tersine get veya set metotlarının
    veri elemanlarına erişmesi gerekmez. Hatta her get metodunun ve/veay set metodunun karşılık geldiği ayrı bir veri elemanı
    olmak zorunda değildir. Bu durumda yazılan metotlar müşteri kodlar için yine "accessor" metotlardır.
    Bu durum ileride örneklerle ele alınacaktır.

    Sınıfın set metotlarının isimleri "set" ile balşatılır. get metotları ise "get" ile başlatılır. Eğer bir get metodu
    boolean bir değer döndürecekse (örneğin bir veri elemanının değerini döndürecekse) ismi genel olarak "is" ile başlatılır.
    Sınıfı yazan programcı aksi bir durum olmadıkça bu isimlendirmeye dikkat etmelidir. Bir takım işlem yapan ve uygulamada
    kullanılan ortamlar (framework) veya kütüphaneler (library) programcı tarafından yazılmış olan sınıflar için
    bu şekilde isimlendirilmiş metotlar ararlar ve çağırırlar.
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Date sınıfında veriler gizlenmiş ve get, set metotları yazılmıştır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Date birthDate = new Date(10, 9, 1976);

        System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());

        birthDate.setDay(11);
        birthDate.setMonth(7);
        birthDate.setYear(1983);

        System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());
    }
}

class Date {
    private int m_day, m_month, m_year;

    public Date(int day, int month, int year)
    {
        //...
        m_day = day;
        m_month = month;
        m_year = year;
    }

    public int getDay()
    {
        return m_day;
    }

    public void setDay(int val)
    {
        //...
        m_day = val;
    }

    public int getMonth()
    {
        return m_month;
    }

    public void setMonth(int val)
    {
        //...
        m_month = val;
    }

    public int getYear()
    {
        return m_year;
    }

    public void setYear(int val)
    {
        //...
        m_year = val;
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki Person sınıfında m_married veri elemanı için get metodu "is" ile başlatılmıştır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {

    }
}

class Person {
    private String m_name;
    private int m_no;
    private boolean m_married;

    //...

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    //...

    public boolean isMarried()
    {
        return m_married;
    }

    public void setMarried(boolean married)
    {
        m_married = married;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    13.03.2021
    Aşağıdaki durumlardan en az biri varsa veri elemanının gizlenmesi gerekir:
    - Sınıfın geliştirilmesinde versiyon değiştikçe (ilerledikçe) bir elemanının isminin hatta türünün değişmesine
    çok sık rastlanır. Bu durumda eski müşteri kodların bu değişimden etkilenmemesi için veri elemanı gizlenmelidir

    - Bir veri elemanın sınır değerleri olabilir. Bu değerlerin kontrol edilip değiştirilebilmesi için veri elemanı
    gizlenmelidir

    - Bir veri elemanı değiştirildiğinde başka bir elemanının değerinin de değişen elemana göre takrar elde edilmesi
    gerekebilir. Bu durumda veri elemanı gizlenmelidir

    - Bir veri elemanı değiştiğinde yeni değere göre bazı işlemlerin yapılması gerekevilir. Örneğin bir dosya ismini
    alan bir sınıf bu isme göre dosyayı "açar". Açılan bir dosyanın kapatılması gerektiğine göre o nesne için dosya ismi
    değiştiğinde eski dosyanın kapatılıp yeni dosyanın açılması gerekir. Bu durumda da veri elemanı gizlenmelidir

    - Bazen bir elemanını gizlenmesi gerekmese de gizleyebiliriz. Örneğin sınıfın tüm veri elemanları bir ya da birkaç
    sebepten dolayı gizlenmiş, ancak bir veri elemanının yukarıdaki yazılan durumlar ile karşılaşılmasa bile bütünlük
    açısından gizlenmesi uygun olabilir

    Bu durumlar dışında (%3 ile %5 arasında) sınıfın veri elemanı public yapılabilir.
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Date sınıfının içsel algoritması değişmesine rağmen müşteri kodları bundan etkilenmemiştir.
    Detayları gözardı sadece değiştikten sonra müşteri kodların değişmemesine odaklanınız
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Date birthDate = new Date(10, 9, 1976);

        System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());

        birthDate.setDay(11);
        birthDate.setMonth(7);
        birthDate.setYear(1983);

        System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());
    }
}

class Date {
    private String m_dateStr;

    public Date(int day, int month, int year)
    {
        //...
        m_dateStr = String.format("%02d/%02d/%04d", day, month, year);
    }

    public int getDay()
    {
        return Integer.parseInt(m_dateStr.substring(0, 2));
    }

    public void setDay(int val)
    {
        //...
        m_dateStr = String.format("%02d/%02d/%04d", val, getMonth(), getYear());
    }

    public int getMonth()
    {
        return Integer.parseInt(m_dateStr.substring(3, 5));
    }

    public void setMonth(int val)
    {
        //...
        m_dateStr = String.format("%02d/%02d/%04d", getDay(), val, getYear());
    }

    public int getYear()
    {
        return Integer.parseInt(m_dateStr.substring(6));
    }

    public void setYear(int val)
    {
        //...
        m_dateStr = String.format("%02d/%02d/%04d", getDay(), getMonth(), val);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Circle sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.Circle;

class App {
    public static void main(String[] args)
    {
        Circle c = new Circle();

        System.out.printf("Yarıçap:%f%n", c.getRadius());
        System.out.printf("Alan:%f%n", c.getArea());
        System.out.printf("Çevre:%f%n", c.getCircumference());

        c.setRadius(-3.5);

        System.out.printf("Yarıçap:%f%n", c.getRadius());
        System.out.printf("Alan:%f%n", c.getArea());
        System.out.printf("Çevre:%f%n", c.getCircumference());
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Circle sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.Circle;

class App {
    public static void main(String[] args)
    {
        Circle c = new Circle(-3.7);

        System.out.printf("Yarıçap:%f%n", c.getRadius());
        System.out.printf("Alan:%f%n", c.getArea());
        System.out.printf("Çevre:%f%n", c.getCircumference());

        c.setRadius(-3.5);

        System.out.printf("Yarıçap:%f%n", c.getRadius());
        System.out.printf("Alan:%f%n", c.getArea());
        System.out.printf("Çevre:%f%n", c.getCircumference());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Circle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.PI;

public class Circle {
    private double m_r;
    private double m_area;
    private double m_circumference;

    private void calculateArea()
    {
        m_area = PI * m_r * m_r;
    }

    private void calculateCircumference()
    {
        m_circumference = 2 * PI * m_r;
    }

    private void calculate()
    {
        calculateArea();
        calculateCircumference();
    }

    public Circle()
    {
    }

    public Circle(double r)
    {
        setRadius(r);
    }

    public double getRadius()
    {
        return m_r;
    }

    public void setRadius(double r)
    {
        m_r = Math.abs(r);
        calculate();
    }

    public double getArea()
    {
        return m_area;
    }

    public double getCircumference()
    {
        return m_circumference;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Circle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.PI;

public class Circle {
    private double m_r;

    public Circle()
    {
    }

    public Circle(double r)
    {
        setRadius(r);
    }

    public double getRadius()
    {
        return m_r;
    }

    public void setRadius(double r)
    {
        m_r = Math.abs(r);
    }

    public double getArea()
    {
        return PI * m_r * m_r;
    }

    public double getCircumference()
    {
        return 2 * PI * m_r;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math;

public class Complex {
	private static Complex add(double a1, double b1, double a2, double b2)
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	private static Complex subtract(double a1, double b1, double a2, double b2)
	{
		return add(a1, b1, -a2, -b2);
	}

	public double re;
	public double im;

	public Complex()
	{
	}

	public Complex(double a)
	{
		re = a;
	}

	public Complex(double a, double b)
	{
		re = a;
		im = b;
	}

	public double getNorm()
	{
		return Math.sqrt(re * re + im * im);
	}

	public Complex getConjugate()
	{
		return new Complex(re, -im);
	}

	//add methods
	public Complex add(Complex other)
	{
		return add(re, im, other.re, other.im);
	}

	public Complex add(double val)
	{
		return add(re, im, val, 0);
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.re, z.im);
	}

	//subtract methods
	public Complex subtract(Complex other)
	{
		return subtract(re, im, other.re, other.im);
	}

	public Complex subtract(double val)
	{
		return subtract(re, im, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.re, z.im);
	}

	public String toString()
	{
		return String.format("|%.2f + %.2f * i| = %f", re, im, getNorm());
	}
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte dizinin elemanlarının değiştirilmesi engellenmemiştir. Burada gizlenen dizinin referansıdır.
    Referans getNumbers metodu ile dışarıya verildiğinden artık sınıf dışından da dizi nesnesine erişilebilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample(10, 1, 100);

        ArrayUtil.display(2, s.getNumbers());
        int[] a = s.getNumbers();

        for (int i = 0; i < a.length; ++i)
            a[i] *= 2;

        ArrayUtil.display(2, s.getNumbers());
    }
}


class Sample {
    private int [] m_a;

    public Sample(int n, int min, int max)
    {
        m_a = ArrayUtil.generateRandomArray(n, min, max);
    }

    public int [] getNumbers()
    {
        return m_a;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte hem referans hem de mantıksal olarak dizi nesnesi sınıf dışından erişilemez hale getirilmiştir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample(10, 1, 100);

        int length = s.getArrayLength();

        for (int i = 0; i < length; ++i)
            System.out.printf("%02d ", s.get(i));

        System.out.println();
    }
}


class Sample {
    private int [] m_a;

    public Sample(int n, int min, int max)
    {
        m_a = ArrayUtil.generateRandomArray(n, min, max);
    }

    public int getArrayLength()
    {
        return m_a.length;
    }

    public int get(int i)
    {
        return m_a[i];
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte dizinin içsel olarak tutulan dizinin elemanlarından oluşan yeni bir dizi referansı döndürülmüştür
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample(10, 1, 100);

        System.out.println("numbers:");
        ArrayUtil.display(2, s.getNumbers());
        int[] a = s.getNumbers();

        for (int i = 0; i < a.length; ++i)
            a[i] *= 2;

        System.out.println("a:");
        ArrayUtil.display(2, a);
        System.out.println("numbers:");
        ArrayUtil.display(2, s.getNumbers());
    }
}

class Sample {
    private int [] m_a;

    public Sample(int n, int min, int max)
    {
        m_a = ArrayUtil.generateRandomArray(n, min, max);
    }

    public int [] getNumbers()
    {
        int [] result = new int[m_a.length];

        for (int i = 0; i < result.length; ++i)
            result[i] = m_a[i];

        return result;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Tüm elemanları static olarak bildirilmiş sınıflar türünden nesnelerin anlamı olmayacağından ctor private yapılır.
    Bu durum Java'nın bu tarz standart sınıflarının hepsinde böyledir. Programcının bu tarz sınıflar için ctor'u
    private yapması gerekir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        Math math = new Math();
        ArrayUtil arrayUtil = new ArrayUtil();

        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public class ArrayUtil {
    private static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    private static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] > a[k])
                    swap(a, k, k + 1);
    }

    private static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }

            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    private static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] > max) {
                    max = a[k];
                    maxIndex = k;
                }

            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    private ArrayUtil()
    {
    }

    public static void bubbleSort(int [] a, boolean descending)
    {
        if (descending)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void display(int [] a)
    {
        display(1, a);
    }

    public static void display(int n, int [] a)
    {
        String fmt = String.format("%%0%dd ", n);

        for (int val : a)
            System.out.printf(fmt, val);

        System.out.println();
    }

    public static void display(int n, int [][] a)
    {
        for (int [] array : a)
            display(n, array);
    }

    public static void display(String [] str)
    {
        display('\n', str);
    }

    public static void display(char sep, String [] str)
    {
        for (String s : str)
            System.out.printf("%s%c", s, sep);
    }

    public static void drawHistogram(int [] data, int n, char ch)
    {
        int mavValue = max(data);

        for (int val : data) {
            int count = (int)Math.ceil((double)val * n / mavValue);

            while (count -- > 0)
                System.out.print(ch);

            System.out.println();
        }
    }

    public static void fillRandomArray(int [] a, int min, int max) //[min, max)
    {
        fillRandomArray(new Random(), a, min, max);
    }

    public static void fillRandomArray(Random r, int [] a, int min, int max) //[min, max)
    {
        for (int i = 0; i < a.length; ++i)
            a[i] = r.nextInt(max - min) + min;
    }

    public static int [] generateRandomArray(int n, int min, int max) //[min, max)
    {
        return generateRandomArray(new Random(), n, min, max);
    }

    public static int [] generateRandomArray(Random r, int n, int min, int max) //[min, max)
    {
        int [] a = new int[n];

        fillRandomArray(r, a, min, max);

        return a;
    }

    public static int [][] generateRandomMatrix(int row, int col, int min, int max)
    {
        return generateRandomMatrix(new Random(), row, col, min, max);
    }

    public static int [][] generateRandomMatrix(Random r, int row, int col, int min, int max)
    {
        int [][] m = new int[row][];

        for (int i = 0; i < row; ++i)
            m[i] = generateRandomArray(r, col, min, max);

        return m;
    }

    public static int [][] generateRandomSquareMatrix(int n, int min, int max)
    {
        return generateRandomSquareMatrix(new Random(), n, min, max);
    }

    public static int [][] generateRandomSquareMatrix(Random r, int n, int min, int max)
    {
        return generateRandomMatrix(r, n, n, min, max);
    }

    public static int [] getHistogramData(int [] a, int n) //[0, n]
    {
        int [] data = new int[n + 1];

        for (int val : a)
            ++data[val];

        return data;
    }

    public static boolean isMatrix(int [][] a)
    {
        for (int i = 1; i < a.length; ++i)
            if (a[i].length != a[0].length)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result < a[i])
                result = a[i];

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result > a[i])
                result = a[i];

        return result;
    }

    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void reverse(int [] a)
    {
        int halfLength = a.length / 2;

        for (int i = 0; i < halfLength; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] a)
    {
        int halfLength = a.length / 2;

        for (int i = 0; i < halfLength; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void selectionSort(int [] a, boolean descending)
    {
        if (descending)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int val : a)
            total += val;

        return total;
    }


    public static int sum(int [][] a)
    {
        int total = 0;

        for (int[] array : a)
            total += sum(array);

        return total;
    }

    public static int sumDiagonal(int [][] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i][i];

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(double [] a, int i, int k)
    {
        double temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static int [][] transpose(int [][] a)
    {
        int row = a.length;
        int col = a[0].length;
        int [][] t = new int[col][row];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                t[j][i] = a[i][j];

        return t;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	NumberUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import static java.lang.Math.log10;
import static java.lang.Math.abs;
import static java.lang.Math.pow;

public class NumberUtil {
    private static int [] getDigits(long val, int n)
    {
        int [] digits = new int[val == 0 ? 1 : (int)(log10(abs(val)) / n) + 1];
        int powOfTen = (int)Math.pow(10, n);

        for (int i = digits.length - 1; i >= 0; digits[i--] = (int)(val % powOfTen), val /= powOfTen)
            ;

        return digits;
    }

    private static String numberToText3DigitsTR(int val)
    {
        if (val == 0)
            return "sıfır";

        String [] ones = {"", "bir", "iki", "üç", "dört", "beş", "altı", "yedi", "sekiz", "dokuz"};
        String [] tens = {"", "on", "yirmi", "otuz", "kırk", "elli", "altmış", "yetmiş", "seksen", "doksan"};

        String str = val < 0 ? "eksi" : "";
        val = Math.abs(val);

        int a, b, c;

        a = val / 100;
        b = val / 10 % 10;
        c = val % 10;

        if (a != 0) {
            if (a != 1)
                str += ones[a];
            str += "yüz";
        }
        if (b != 0)
            str += tens[b];

        if (c != 0)
            str += ones[c];

        return str;
    }

    private NumberUtil()
    {
    }

    public static int countDigits(long val)
    {
        return val == 0 ? 1 : (int)log10(abs(val)) + 1;
    }

    public static void displayCollatz(int n)
    {
        if (n <= 0) {
            System.out.println("Geçersiz değer");
            return;
        }

        for (;;) {
            System.out.println(n);

            if (n == 1)
                break;

            if (n % 2 == 0)
                n /= 2;
            else
                n = 3 * n + 1;
        }
    }

    public static long factorial(int n)
    {
        long result = 1L;

        for (int i = 2; i <= n; ++i)
            result *= i;

        return result;
    }

    public static int getDigitalRoot(int val)
    {
        int root = abs(val);

        while (root > 9)
            root = sumDigits(root);

        return root;
    }

    public static int [] getDigits(long val)
    {
        return getDigits(val, 1);
    }

    public static int [] getDigitsInThrees(long val)
    {
        return getDigits(val, 3);
    }

    public static int [] getDigitsInTwos(long val)
    {
        return getDigits(val, 2);
    }

    public static int getDigitsFactorialSum(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += factorial(val % 10);
            val /= 10;
        }

        return sum;
    }

    public static int getDigitsPowSum(int val)
    {
        int n = countDigits(val);
        int sum = 0;

        while (val != 0) {
            sum += pow(val % 10, n);
            val /= 10;
        }

        return sum;
    }

    public static int getFibonacciNumber(int n)
    {
        if (n <= 0)
            return -1;

        if (n <= 2)
            return n - 1;

        int prev1 = 1, prev2 = 0, val = 0;

        for (int i = 2; i < n; ++i) {
            val = prev1 + prev2;
            prev2 = prev1;
            prev1 = val;
        }

        return val;
    }

    public static int getIndexOfPrimeNumber(int n)
    {
        int index = 1;
        int val = 2;

        for (;;) {
            if (val == n)
                return index;

            if (isPrime(val))
                ++index;

            ++val;
        }
    }

    public static int getNextFibonacciNumber(int val)
    {
        if (val < 0)
            return 0;

        int prev1 = 1, prev2 = 0, result;

        for (;;) {
            result = prev1 + prev2;

            if (result > val)
                return result;

            prev2 = prev1;
            prev1 = result;
        }
    }

    public static int getPrime(int n)
    {
        if (n <= 0)
            return -1;

        int count = 0;
        int val = 2;

        for (;;) {
            if (isPrime(val))
                ++count;

            if (count == n)
                return val;

            ++val;
        }
    }

    public static boolean isArmstrong(int val)
    {
        return val >= 0 && getDigitsPowSum(val) == val;
    }

    public static boolean isDecimalHarshad(int val)
    {
        if (val < 0)
            return false;

        return val % sumDigits(val) == 0;
    }

    public static boolean isEven(int val)
    {
        return val % 2 == 0;
    }

    public static boolean isFactorian(int val)
    {
        if (val <= 0)
            return false;

        return getDigitsFactorialSum(val) == val;
    }

    public static boolean isHardyRamanujan(int val)
    {
        if (val <= 0)
            return false;

        int count = 0;

        for (int x = 1; x * x * x < val;) {
            for (int y = x + 1; x * x * x + y * y * y <= val; ++y)  {
                if (x * x * x + y * y * y == val) {
                    ++count;
                    ++x;
                }
            }
            ++x;
        }

        return count >= 2;
    }

    public static boolean isOdd(int val)
    {
        return !isEven(val);
    }

    public static boolean isPalindrome(int val)
    {
        return reversed(val) == val;
    }

    public static boolean isPrime(int val)
    {
        if (val <= 1)
            return false;

        if (val % 2 == 0)
            return val == 2;

        if (val % 3 == 0)
            return val == 3;

        if (val % 5 == 0)
            return val == 5;

        if (val % 7 == 0)
            return val == 7;

        int sqrtVal = (int)Math.sqrt(val);

        for (int i = 11; i <= sqrtVal; i += 2)
            if (val % i == 0)
                return false;

        return true;
    }

    public static boolean isPrimeX(int val)
    {
        do {
            if (!isPrime(val))
                return false;
            val = sumDigits(val);
        } while (val > 9);

        return isPrime(val);
    }

    public static boolean isSuperPrime(int val)
    {
        return isPrime(val) && isPrime(getIndexOfPrimeNumber(val));
    }

    public static int max(int a, int b, int c)
    {
        return Math.max(Math.max(a, b),  c);
    }

    public static int mid(int a, int b, int c)
    {
        if (a <= b && b <= c || c <= b && b <= a)
            return b;

        if (b <= a && a <= c || c <= a && a <= b)
            return a;

        return c;
    }

    public static int min(int a, int b, int c)
    {
        return Math.min(Math.min(a, b),  c);
    }

    public static String numberToText(long val)
    {
        int [] digits = getDigitsInThrees(val);

        String result = "";

        //TODO:
        for (int digit : digits)
            result += numberToText3DigitsTR(digit) + " ";

        return result;
    }

    public static int reversed(int val)
    {
        int reverse = 0;

        while (val != 0) {
            reverse = reverse * 10 + val % 10;
            val /= 10;
        }

        return reverse;
    }

    public static int sumDigits(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += val % 10;
            val /= 10;
        }

        return Math.abs(sum);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;
import static java.lang.Character.isWhitespace;
import static java.lang.Character.toLowerCase;
import static java.lang.Character.toUpperCase;
import static java.lang.Character.isLetter;

public class StringUtil {
    private StringUtil()
    {
    }

    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static String changeCase(String s)
    {
        char [] c = new char[s.length()];

        for (int i = 0; i < c.length; ++i) {
            char ch = s.charAt(i);

            c[i] = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);
        }

        return String.valueOf(c);
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        int length = sourceText.length();
        char [] c = new char[n];

        for (int i = 0; i < n; ++i)
            c[i] = sourceText.charAt(r.nextInt(length));

        return String.valueOf(c);
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String [] getRandomTextsTR(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextTR(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, "ABCDEFGHIJKLMNOPQRSTUWXVYZabcdefghijklmnopqrstuvwxyz");
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static String [] getRandomTextsEN(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextEN(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
    }

    public static String join(String [] str, char sep)
    {
        return join(str, sep + "");
    }

    public static String join(String [] str, String sep)
    {
        String result = "";

        for (String s : str) {
            if (!result.isEmpty())
                result += sep;

            result += s;
        }

        return result;
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        char [] c = s.toCharArray();

        ArrayUtil.reverse(c);

        return String.valueOf(c);
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Programlamada çalışma zamanında hiç yer ayrılmayan bellek bölgesinin adresine "null adres/referans"
    denir. Bu adres Java'da null isimli bir sabit ile temsil edilir. Bir referansa null atanabilir. Bir referansın
    default değeri null değeridir. null referans detayları ileride ele alınacaktır
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Singleton: Öyle bir sınıf olsun ki bu sınıf türünden program boyunca yalnızca bir tane nesne yaratılabilsin ve
    istendiğinde bu nesnenin referansına erişilebilsin.

    Anahtar Notlar: Singleton kalıbının bir çok "gerçekleştirimi (implementation)" yapılır
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Singleton kalıbının bir implementasyonu (lazy implementation)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();

        System.out.println(s1 == s2);

        s1.setX(20);

        System.out.println(s2.getX());
    }
}

class Singleton {
    private static Singleton ms_instance;
    private int m_x;

    private Singleton()
    {
    }

    public static Singleton getInstance()
    {
        if (ms_instance == null)
            ms_instance = new Singleton();

        return ms_instance;
    }

    public int getX()
    {
        return m_x;
    }

    public void setX(int x)
    {
        //...
        m_x = x;
    }

    //...
}


/*--------------------------------------------------------------------------------------------------------------------
    14.03.2021
    final değişkenler:
    Bir değişkeninin final olarak bildirilmesi o değişkenin bir kez değer alabileceği anlamına gelir ve değeri bir daha
    değiştirilemez. Değiştirilirse error oluşur. final değişkenler sabit ifadesi olarak ele alınır. Java 8'den itibaren
    yerel değişkenlerin ve parametre değişkenlerinin final olması durumunun artık bir anlamı kalmamıştır. Java 8 öncesinde
    yerel değişkenklerin parametre değişkenlerinin final olarak yapılması zorunlu olan (aksi durumda error olan) durumlar
    vardır. Ancak bu durumlar Java 8 ile birlikte değişti. Fakat final veri elemanları için bu durum söz konusu değildir.

    final veri elemanları için genel olarak şu kural programlama açısından geçerli bir teknik olarak kullanılır:
    Veri elemanının final yapılması algoritmik olarak (şüphesiz derleme anlamında) geçerliyse kesinlikle final
    yapılmalıdır
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    final yerel değişkenlere faaliyet alanmı boyunca bir kez atama yapılabilir. Genel olarak ilkdeğer verilse de
    faaliyet boyunca tek atama olması koşuluyla istenildiği yerde atama yapılabilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        final int a = 10;
        final double pi;

        pi = 3.14;

        pi = 3.15; //error
        ++a; //error
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Bir metodun parametre değişkeni final olarak bildirilebilir. Bu durumda metodun final olan parametre değişkeninin
    içerisinde değer metot içerisinde değiştirilemez
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    public static void foo(final int a, int b)
    {
        ++a; //error
        ++b;
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın non-static ve final bildirilmiş veri elemanına default değer atanmaz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    public final int x; //error
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın non-static ve final bildirilmiş veri elemanına bildirim noktasında değer verilebilir (initialization)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        System.out.println(s.x);
        System.out.println(k.x);
    }
}

class Sample {
    public final int x = 10;
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın non-static ve final veri elemanına bildirim noktasında atanan değerin sabit ifadesi olması gerekmez
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        System.out.println(s.x);
        System.out.println(k.x);
    }
}

class Sample {
    private int getRandomValue()
    {
        return new Random().nextInt(100);
    }

    public final int x = getRandomValue();
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın non-static ve final veri elemanına ctor dışında değer atanmamışsa, ctor içerisinde de değer
    atanmalıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        System.out.println(s.x);
        System.out.println(k.x);
    }
}

class Sample {
    private int getRandomValue()
    {
        return new Random().nextInt(100);
    }

    public final int x;

    public Sample()
    {
        x = getRandomValue();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın non-static ve final veri elemanına tüm ctor'lar içerisinde değer atanmalıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        System.out.println(s.x);
        System.out.println(k.x);
    }
}

class Sample {
    private int getRandomValue()
    {
        return new Random().nextInt(100);
    }

    public final int x;

    public Sample()
    {
        x = getRandomValue();
    }

    public Sample(int val)
    {
        x = val;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın static ve final veri elemanına default değer atanmaz.
    Anahtar Notlar: Sınıfın static ve final (özellikle public) veri elemanlarının isimlendirilmesinde tamamen büyük harfler
    ile kelime ayracı olarak alttire karakteri kullanımı yaygındır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {

    }
}

class Sample {
    public static final int DEFAULT_VALUE; //error
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın static ve final veri elemanlarına bildirim sırasında değer atanabilir. static ve final veri elemanlarına
    ilkdeğer verilmemişse sınıfın "static bloğu (static initializer)" içerisinde değer atanmalıdır. Sınıfın static
    bloğu ileride ele alınacaktır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    public static final int DEFAULT_VALUE = 67;
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıfın static ve final veri elemanlarının bir kullanımı. Math sınıfının PI ve E veri elemanları da static
    ve final olarak bildirilmiştir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        System.out.printf("%f%n", ChemistryUtil.AVOGADRO_NUMBER);
    }
}

class ChemistryUtil {
    public static final double AVOGADRO_NUMBER = 6.02E23;
    //...
}


/*--------------------------------------------------------------------------------------------------------------------
    Singleton kalıbının bir implementasyonu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Singleton s1 = Singleton.INSTANCE;
        Singleton s2 = Singleton.INSTANCE;

        System.out.println(s1 == s2);

        s1.setX(20);

        System.out.println(s2.getX());
    }
}

class Singleton {
    public static final Singleton INSTANCE = new Singleton();
    private int m_x;

    private Singleton()
    {
    }

    public int getX()
    {
        return m_x;
    }

    public void setX(int x)
    {
        //...
        m_x = x;
    }

    //...
}


/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte x veri elemanı y veri elemanından sonra yaratılacağından error oluşur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        System.out.printf("x = %d%n", Sample.x);
        System.out.printf("y = %d%n", Sample.y);
    }
}

class Sample {
    public static final int y = x + 1; //error
    public static final int x = 10;

}

/*--------------------------------------------------------------------------------------------------------------------
    NumericLotto sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.samples.numericlotto;

import java.util.Random;

public class NumericLotto {
    private final Random m_random;

    private boolean [] getFlags()
    {
        boolean [] flags = new boolean[50];

        for (int i = 0; i < 6; ++i) {
            int val;

            for (;;) {
                val = m_random.nextInt(49) + 1;
                if (!flags[val])
                    break;
            }
            flags[val] = true;
        }

        return flags;
    }

    private static int [] getNumbers(boolean [] flags)
    {
        int [] numbers = new int[6];

        int index = 0;

        for (int i = 1; i < 50; ++i)
            if (flags[i])
                numbers[index++] = i;

        return numbers;
    }

    public NumericLotto()
    {
        m_random = new Random();
    }

    public NumericLotto(Random r)
    {
        m_random = r;
    }

    public int [] getNumbers()
    {
        return getNumbers(getFlags());
    }

    public int [][] getNumbers(int n)
    {
        int [][] result = new int[n][];

        for (int i = 0; i < n; ++i)
            result[i] = getNumbers();

        return result;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    NumericLottoApp sınıfı
---------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.samples.numericlotto;

import org.csystem.util.ArrayUtil;

import java.util.Scanner;

public class NumericLottoApp {
    private NumericLottoApp()
    {
    }
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        NumericLotto lotto = new NumericLotto();

        for (;;) {
            System.out.print("Kaç kupon oynamak istersin?");
            int n = Integer.parseInt(kb.nextLine());

            if (n <= 0)
                break;

            ArrayUtil.display(2, lotto.getNumbers(n));
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Bir okulda Fizik sınavı ortak olarak yapılıyor. Kaç şube olduğu ve herbir şubede kaç öğrenci
    olduğu bilgisi klavyeden alınsın. Bu işlem sonrasında öğrencilerin notları rasgele belirlensin. Tüm bu işlemlerden
    sonra Fizik sınavı için herbir şubenin ayrı ayrı not ortalamaları ile okulun ortalamasını bulan basit bir simülasyon
    programını yazınız. Programı mümkün olduğunda genel yazmaya çalışınız
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.samples.simulation.centralexam;

public class ExamSimulationApp {
    private ExamSimulationApp()
    {
    }

    public static void run()
    {
        ExamSimulation physSimulation = new ExamSimulation("Fizik");
        ExamSimulation mathSimulation = new ExamSimulation("Matematik");

        physSimulation.run();
        mathSimulation.run();
        physSimulation.displayReport();
        mathSimulation.displayReport();
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    ExamSimulation sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.samples.simulation.centralexam;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ExamSimulation {
    private final String m_lectureName;
    private int [][] m_grades;
    private double [] m_averages;
    private double m_average;

    private void findAverages()
    {
        int totalNumberOfStudents = 0;
        int totalGrades = 0;

        for (int i = 0; i < m_grades.length; ++i) {
            int total = ArrayUtil.sum(m_grades[i]);

            m_averages[i] = (double)total / m_grades[i].length;
            totalGrades += total;
            totalNumberOfStudents += m_grades[i].length;
        }

        m_average = (double)totalGrades / totalNumberOfStudents;
    }

    private void fillGrades()
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);
        System.out.printf("%s sınavı şube sayısını giriniz:", m_lectureName);
        m_grades = new int[Integer.parseInt(kb.nextLine())][];
        m_averages = new double[m_grades.length];

        for (int i = 0; i < m_grades.length; ++i) {
            System.out.printf("%d. şube öğrenci sayısı?", i + 1);
            int count = Integer.parseInt(kb.nextLine());

            m_grades[i] = ArrayUtil.generateRandomArray(r, count, 0, 101);
        }
    }

    public ExamSimulation(String name)
    {
        m_lectureName = name;
    }

    public int getNumberOfClasses()
    {
        return m_grades.length;
    }

    public int getNumberOfStudents(int i)
    {
        return m_grades[i].length;
    }

    public int getGrade(int i, int k)
    {
        return m_grades[i][k];
    }

    public double getAverage(int i)
    {
        return m_averages[i];
    }

    public double getAverage()
    {
        return m_average;
    }

    public String getLectureName()
    {
        return m_lectureName;
    }

    public void run()
    {
        fillGrades();
        findAverages();
    }

    public void displayGrades()
    {
        System.out.printf("%s dersi sınav notları:%n", m_lectureName);
        System.out.println("-------------------------------------------------------");
        for (int i = 0; i < m_grades.length; ++i) {
            System.out.printf("%d. şube notları:", i + 1);
            ArrayUtil.display(3, m_grades[i]);
        }

        System.out.println("-------------------------------------------------------");
    }

    public void displayReport()
    {
        System.out.println("*******************************************************");
        displayGrades();
        System.out.printf("%s dersi için not ortalamaları:%n", m_lectureName);
        System.out.println("-------------------------------------------------------");
        for (int i = 0; i < m_averages.length; ++i)
            System.out.printf("%d.şube not ortalaması:%f%n", i + 1, m_averages[i]);
        System.out.printf("Okul Ortalaması:%f%n", m_average);
        System.out.println("-------------------------------------------------------");
        System.out.println("*******************************************************");
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    CrapsSimulationApp sınıfı
---------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.samples.simulation.craps;

import org.csystem.games.craps.Craps;

public class CrapsSimulationApp {
	private CrapsSimulationApp()
	{
	}

	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		Craps craps = new Craps();

		System.out.print("Kaç kez oynamak istersiniz?");
		int n = Integer.parseInt(kb.nextLine());

		int count = 0;

		for (int i = 0; i < n; ++i) {
			craps.play();
			if (craps.isWin())
				++count;
		}

		System.out.printf("p = %f%n", (double)count / n);
	}
}

/*--------------------------------------------------------------------------------------------------------------------
    Craps sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.games.craps;

import java.util.Random;

public class Craps {
	private boolean m_win;
	private final Random m_random;

	public int total()
	{
		return m_random.nextInt(6) + 1 + m_random.nextInt(6) + 1;
	}

	public void doWorkForIndeterminite(int sum)
	{
		int newSum;

		while ((newSum = total()) != sum)
			if (newSum == 7)
				break;

		m_win = newSum == sum;
	}

	public void doWorkForSum(int sum)
	{
		switch (sum) {
		case 7:
		case 11:
			m_win = true;
			break;
		case 2:
		case 3:
		case 12:
			m_win = false;
			break;
		default:
			doWorkForIndeterminite(sum);
		}
	}

	public Craps()
	{
		m_random = new Random();
	}

	public boolean isWin()
	{
		return m_win;
	}

	public void play()
	{
		doWorkForSum(total());
	}
}

/*--------------------------------------------------------------------------------------------------------------------
    SpecialLotto sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.samples.simulation.lotto;

import org.csystem.util.NumberUtil;

import java.util.Random;

public class SpecialLotto {
    private final Random m_random;
    private boolean m_firstWin;
    private boolean m_secondWin;
    private boolean m_thirdWin;
    private int first;
    private int second;
    private int third;

    private int getNumber()
    {
        return m_random.nextInt(99) + 1;
    }

    private void setNumbers()
    {
        setFirst();
        setSecond();
        setThird();
    }

    private void setFirst()
    {
        first = getNumber();
    }

    private void setSecond()
    {

        while ((second = getNumber()) == first)
            ;
    }

    private void setThird()
    {
        while ((third = getNumber()) == first || third == second)
            ;
    }

    private void playFirstGame(int first, int second, int third)
    {
        m_firstWin = first + second + third < 150;
    }

    private void playSecondGame(int first, int second, int third)
    {
        m_secondWin = NumberUtil.isPrime(first + second + third);
    }

    private void playThirdGame(int first, int second, int third)
    {
        int max = Math.max(Math.max(first, second), third);
        int min = Math.min(Math.min(first, second), third);
        int mid = first + second + third - max - min;

        m_thirdWin = max - min > mid;
    }

    public SpecialLotto()
    {
        m_random = new Random();
    }

    public SpecialLotto(Random rand)
    {
        m_random = rand;
    }

    public boolean isFirstWin()
    {
        return m_firstWin;
    }

    public boolean isSecondWin()
    {
        return m_secondWin;
    }

    public boolean isThirdWin()
    {
        return m_thirdWin;
    }

    public void playFirstGame()
    {
        setNumbers();
        playFirstGame(first, second, third);
    }

    public void playSecondGame()
    {
        setNumbers();
        playSecondGame(first, second, third);
    }

    public void playThirdGame()
    {
        setNumbers();
        playThirdGame(first, second, third);
    }

    public void play()
    {
        setNumbers();
        playFirstGame(first, second, third);
        playSecondGame(first, second, third);
        playThirdGame(first, second, third);
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    SpecialLottoSimulation sınıfı
---------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.samples.simulation.lotto;

import java.util.Random;

public class SpecialLottoSimulation {
    private double m_firstGameWinProbability;
    private double m_secondGameWinProbability;
    private double m_thirdGameWinProbability;

    private void runSimulation(int n)
    {
        SpecialLotto lotto = new SpecialLotto(new Random());

        int firstGameWinCount = 0;
        int secondGameWinCount = 0;
        int thirdGameWinCount = 0;

        for (int i = 0; i < n; ++i) {
            lotto.play();
            if (lotto.isFirstWin())
                ++firstGameWinCount;

            if (lotto.isSecondWin())
                ++secondGameWinCount;

            if (lotto.isThirdWin())
                ++thirdGameWinCount;
        }

        m_firstGameWinProbability = (double)firstGameWinCount / n;
        m_secondGameWinProbability = (double)secondGameWinCount / n;
        m_thirdGameWinProbability = (double)thirdGameWinCount / n;
    }

    public double getFirstGameWinProbability()
    {
        return m_firstGameWinProbability;
    }

    public double getSecondGameWinProbability()
    {
        return m_secondGameWinProbability;
    }

    public double getThirdGameWinProbability()
    {
        return m_thirdGameWinProbability;
    }

    public void run(int n)
    {
        runSimulation(n);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    SpecialLottoSimulationApp sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.samples.simulation.lotto;

import java.util.Scanner;

public class SpecialLottoSimulationApp {
    private SpecialLottoSimulationApp()
    {
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Kaç kez oynatmak istiyorsunuz?");
        int n = Integer.parseInt(kb.nextLine());
        SpecialLottoSimulation simulation = new SpecialLottoSimulation();

        simulation.run(n);
        System.out.printf("p1 = %f%n", simulation.getFirstGameWinProbability());
        System.out.printf("p2 = %f%n", simulation.getSecondGameWinProbability());
        System.out.printf("p3 = %f%n", simulation.getThirdGameWinProbability());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	NumberUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import static java.lang.Math.log10;
import static java.lang.Math.abs;
import static java.lang.Math.pow;

public class NumberUtil {
    private static final String [] ONES = {"", "bir", "iki", "üç", "dört", "beş", "altı", "yedi", "sekiz", "dokuz"};
    private static final String [] TENS = {"", "on", "yirmi", "otuz", "kırk", "elli", "altmış", "yetmiş", "seksen", "doksan"};

    private static int [] getDigits(long val, int n)
    {
        int [] digits = new int[val == 0 ? 1 : (int)(log10(abs(val)) / n) + 1];
        int powOfTen = (int)Math.pow(10, n);

        for (int i = digits.length - 1; i >= 0; digits[i--] = (int)(val % powOfTen), val /= powOfTen)
            ;

        return digits;
    }

    private static String numberToText3DigitsTR(int val)
    {
        if (val == 0)
            return "sıfır";

        String str = val < 0 ? "eksi" : "";
        val = Math.abs(val);

        int a, b, c;

        a = val / 100;
        b = val / 10 % 10;
        c = val % 10;

        if (a != 0) {
            if (a != 1)
                str += ONES[a];
            str += "yüz";
        }
        if (b != 0)
            str += TENS[b];

        if (c != 0)
            str += ONES[c];

        return str;
    }

    private NumberUtil()
    {
    }

    public static int countDigits(long val)
    {
        return val == 0 ? 1 : (int)log10(abs(val)) + 1;
    }

    public static void displayCollatz(int n)
    {
        if (n <= 0) {
            System.out.println("Geçersiz değer");
            return;
        }

        for (;;) {
            System.out.println(n);

            if (n == 1)
                break;

            if (n % 2 == 0)
                n /= 2;
            else
                n = 3 * n + 1;
        }
    }

    public static long factorial(int n)
    {
        long result = 1L;

        for (int i = 2; i <= n; ++i)
            result *= i;

        return result;
    }

    public static int getDigitalRoot(int val)
    {
        int root = abs(val);

        while (root > 9)
            root = sumDigits(root);

        return root;
    }

    public static int [] getDigits(long val)
    {
        return getDigits(val, 1);
    }

    public static int [] getDigitsInThrees(long val)
    {
        return getDigits(val, 3);
    }

    public static int [] getDigitsInTwos(long val)
    {
        return getDigits(val, 2);
    }

    public static int getDigitsFactorialSum(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += factorial(val % 10);
            val /= 10;
        }

        return sum;
    }

    public static int getDigitsPowSum(int val)
    {
        int n = countDigits(val);
        int sum = 0;

        while (val != 0) {
            sum += pow(val % 10, n);
            val /= 10;
        }

        return sum;
    }

    public static int getFibonacciNumber(int n)
    {
        if (n <= 0)
            return -1;

        if (n <= 2)
            return n - 1;

        int prev1 = 1, prev2 = 0, val = 0;

        for (int i = 2; i < n; ++i) {
            val = prev1 + prev2;
            prev2 = prev1;
            prev1 = val;
        }

        return val;
    }

    public static int getIndexOfPrimeNumber(int n)
    {
        int index = 1;
        int val = 2;

        for (;;) {
            if (val == n)
                return index;

            if (isPrime(val))
                ++index;

            ++val;
        }
    }

    public static int getNextFibonacciNumber(int val)
    {
        if (val < 0)
            return 0;

        int prev1 = 1, prev2 = 0, result;

        for (;;) {
            result = prev1 + prev2;

            if (result > val)
                return result;

            prev2 = prev1;
            prev1 = result;
        }
    }

    public static int getPrime(int n)
    {
        if (n <= 0)
            return -1;

        int count = 0;
        int val = 2;

        for (;;) {
            if (isPrime(val))
                ++count;

            if (count == n)
                return val;

            ++val;
        }
    }

    public static boolean isArmstrong(int val)
    {
        return val >= 0 && getDigitsPowSum(val) == val;
    }

    public static boolean isDecimalHarshad(int val)
    {
        if (val < 0)
            return false;

        return val % sumDigits(val) == 0;
    }

    public static boolean isEven(int val)
    {
        return val % 2 == 0;
    }

    public static boolean isFactorian(int val)
    {
        if (val <= 0)
            return false;

        return getDigitsFactorialSum(val) == val;
    }

    public static boolean isHardyRamanujan(int val)
    {
        if (val <= 0)
            return false;

        int count = 0;

        for (int x = 1; x * x * x < val;) {
            for (int y = x + 1; x * x * x + y * y * y <= val; ++y)  {
                if (x * x * x + y * y * y == val) {
                    ++count;
                    ++x;
                }
            }
            ++x;
        }

        return count >= 2;
    }

    public static boolean isOdd(int val)
    {
        return !isEven(val);
    }

    public static boolean isPalindrome(int val)
    {
        return reversed(val) == val;
    }

    public static boolean isPrime(int val)
    {
        if (val <= 1)
            return false;

        if (val % 2 == 0)
            return val == 2;

        if (val % 3 == 0)
            return val == 3;

        if (val % 5 == 0)
            return val == 5;

        if (val % 7 == 0)
            return val == 7;

        int sqrtVal = (int)Math.sqrt(val);

        for (int i = 11; i <= sqrtVal; i += 2)
            if (val % i == 0)
                return false;

        return true;
    }

    public static boolean isPrimeX(int val)
    {
        do {
            if (!isPrime(val))
                return false;
            val = sumDigits(val);
        } while (val > 9);

        return isPrime(val);
    }

    public static boolean isSuperPrime(int val)
    {
        return isPrime(val) && isPrime(getIndexOfPrimeNumber(val));
    }

    public static int max(int a, int b, int c)
    {
        return Math.max(Math.max(a, b),  c);
    }

    public static int mid(int a, int b, int c)
    {
        if (a <= b && b <= c || c <= b && b <= a)
            return b;

        if (b <= a && a <= c || c <= a && a <= b)
            return a;

        return c;
    }

    public static int min(int a, int b, int c)
    {
        return Math.min(Math.min(a, b),  c);
    }

    public static String numberToText(long val)
    {
        int [] digits = getDigitsInThrees(val);

        String result = "";

        //TODO:
        for (int digit : digits)
            result += numberToText3DigitsTR(digit) + " ";

        return result;
    }

    public static int reversed(int val)
    {
        int reverse = 0;

        while (val != 0) {
            reverse = reverse * 10 + val % 10;
            val /= 10;
        }

        return reverse;
    }

    public static int sumDigits(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += val % 10;
            val /= 10;
        }

        return Math.abs(sum);
    }
}
/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte final olan referanstır. Nesne final yapılamaz. Ancak sınıfın içeriğinin değiştirilemeyecek
    biçimde (immutable) olarak yazılması durumu olabilir. Örnekte sınıf bu şekşilde yazılmamıştır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        final Sample s = new Sample();

        s.x = 10;

        s = new Sample(); //error
    }
}

class Sample {
    public int x;

    //...
}


/*--------------------------------------------------------------------------------------------------------------------
    Homework-013 çalışma sorusuna ilişkin bir iskelet
    (İleride dha iyileri yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.commandprompt.CommandPromptApp;

class App {
    public static void main(String[] args)
    {
        CommandPromptApp.run();

    }
}



package org.csystem.app.samples.commandprompt;

public class CommandPromptApp {
    private CommandPromptApp()
    {
    }
    public static void run()
    {
        CommandPrompt commandPrompt = new CommandPrompt("CSD");

        commandPrompt.run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	CommandPrompt sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.samples.commandprompt;

import org.csystem.util.StringUtil;

import java.util.Scanner;

public class CommandPrompt {
    private static final String [] COMMANDS = {"length", "reverse", "upper", "lower", "change", "quit"};
    private final Scanner m_kb = new Scanner(System.in);
    private String m_prompt;

    private static String getCommandByText(String text)
    {
        if (text.length() < 3)
            return "";

        for (String cmdStr : COMMANDS)
            if (cmdStr.startsWith(text))
                return cmdStr;

        return "";
    }

    private static void lengthProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("length bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].length());
    }

    private static void reverseProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("reverse bir tane argüman almalıdır");
            return;
        }

        System.out.println(StringUtil.reverse(commandInfo[1]));
    }

    private static void upperProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("upper bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].toUpperCase());

    }

    private static void lowerProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("lower bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].toLowerCase());
    }

    private static void quitProc(String [] commandInfo)
    {
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.println("Tekrar yapıyor musunuz?");
        System.exit(0);
    }

    private void changeProc(String [] commandInfo)
    {
        m_prompt = StringUtil.join(commandInfo, 1, ' ');
    }

    private void doWorkForCommand(String [] commandInfo)
    {
        switch (commandInfo[0]) {
            case "length":
                lengthProc(commandInfo);
                break;
            case "reverse":
                reverseProc(commandInfo);
                break;
            case "upper":
                upperProc(commandInfo);
                break;
            case "lower":
                lowerProc(commandInfo);
                break;
            case "change":
                changeProc(commandInfo);
                break;
            default:
                quitProc(commandInfo);
                break;
        }
    }

    private void parseCommand(String [] commandsInfo)
    {
        String cmdStr = getCommandByText(commandsInfo[0]);

        if (!cmdStr.isEmpty()) {
            commandsInfo[0] = cmdStr;
            doWorkForCommand(commandsInfo);
        }
        else {
            System.out.println("Geçersiz komut");
        }
    }

    public CommandPrompt(String prompt)
    {
        m_prompt = prompt;
    }

    public void run()
    {
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.println("Homework-013 çalışma sorusuna ilişkin bir iskelet");
        System.out.println("Geri kalanları lütfen yapınız");

        for (;;) {
            System.out.print(m_prompt + ">");
            String cmd = m_kb.nextLine().trim();
            parseCommand(cmd.split("[ \t]"));
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;
import static java.lang.Character.isWhitespace;
import static java.lang.Character.toLowerCase;
import static java.lang.Character.toUpperCase;
import static java.lang.Character.isLetter;

public class StringUtil {
    private static final String ALPHABET_LOWER_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
    private static final String ALPHABET_LOWER_EN = "abcdefghijklmnopqrstuvwxyz";
    private static final String ALPHABET_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ" + ALPHABET_LOWER_TR;
    private static final String ALPHABET_EN = "ABCDEFGHIJKLMNOPQRSTUWXVYZ" + ALPHABET_LOWER_EN;

    private StringUtil()
    {
    }

    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static String changeCase(String s)
    {
        char [] c = new char[s.length()];

        for (int i = 0; i < c.length; ++i) {
            char ch = s.charAt(i);

            c[i] = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);
        }

        return String.valueOf(c);
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        int length = sourceText.length();
        char [] c = new char[n];

        for (int i = 0; i < n; ++i)
            c[i] = sourceText.charAt(r.nextInt(length));

        return String.valueOf(c);
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, ALPHABET_TR);
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String [] getRandomTextsTR(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextTR(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, ALPHABET_EN);
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static String [] getRandomTextsEN(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextEN(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), ALPHABET_LOWER_EN);
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), ALPHABET_LOWER_TR);
    }

    public static String join(String [] str, char sep)
    {
        return join(str, 0, sep);
    }

    public static String join(String [] str, int startIndex, char sep)
    {
        return join(str, startIndex, sep + "");
    }

    public static String join(String [] str, int startIndex, String sep)
    {
        String result = "";

        int length = str.length;

        for (int i = startIndex; i < length; ++i) {
            if (!result.isEmpty())
                result += sep;

            result += str[i];
        }

        return result;
    }

    public static String join(String [] str, String sep)
    {
       return join(str, 0, sep);
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        char [] c = s.toCharArray();

        ArrayUtil.reverse(c);

        return String.valueOf(c);
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Soru:Öyle bir immutable sınıf yazınız ki, sınıf içerisinde int türden bir değer tutulabilsin. Bu sınıf için
    [-127, 128] aralğındaki değerlere ilişkin nesneler ilk kez istendiğinde yaratılsın. Sonraki isteklerde ilgili
    değer ilişkin daha önce yaratılmış olan nesnenin referansı verilsin (flyweight). Bu kavrama genel olarak
    ön bellek (cache) denir.
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.IntValue;

class App {
    public static void main(String[] args)
    {
        IntValue ival1 = IntValue.of(10);
        IntValue ival2 = IntValue.of(10);

        System.out.println(ival1 == ival2);

        IntValue ival3 = IntValue.of(1000);
        IntValue ival4 = IntValue.of(1000);

        System.out.println(ival3 == ival4);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.IntValue;

class App {
    public static void main(String[] args)
    {
        IntValue intValue = IntValue.ONE.add(3).multiply(7).subtract(27);

        System.out.println(intValue.toString());
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.IntValue;

class App {
    public static void main(String[] args)
    {
        IntValue ten = IntValue.TEN;

        for (IntValue i = IntValue.ZERO; i.compareTo(ten) < 0; i = i.increment())
            System.out.printf("%d ", i.getVal());

        System.out.println();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public class IntValue {
    private static final IntValue [] CACHE = new IntValue[256];
    private final int m_val;

    private IntValue(int val)
    {
        m_val = val;
    }

    public static final IntValue ONE = of(1);
    public static final IntValue ZERO = of(0);
    public static final IntValue TEN = of(10);

    public static IntValue of(int val)
    {
        if (val < -128 || val > 127)
            return new IntValue(val);

        if (CACHE[val + 128] == null)
            CACHE[val + 128] = new IntValue(val);

        return CACHE[val + 128];
    }

    public int getVal()
    {
        return m_val;
    }

    public int compareTo(IntValue other)
    {
        return m_val - other.m_val;
    }

    public IntValue add(int val)
    {
        return of(m_val + val);
    }

    public IntValue add(IntValue other)
    {
        return add(other.m_val);
    }

    public IntValue subtract(int val)
    {
        return add(-val);
    }

    public IntValue subtract(IntValue other)
    {
        return subtract(other.m_val);
    }

    public IntValue multiply(int val)
    {
        return of(m_val * val);
    }

    public IntValue multiply(IntValue other)
    {
        return multiply(other.m_val);
    }

    public IntValue increment()
    {
        return add(1);
    }

    public IntValue decrement()
    {
        return subtract(1);
    }

    public String toString()
    {
        return m_val + "";
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    21.03.2021
    Time sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Time;

class App {
    public static void main(String[] args)
    {
        Time time = new Time(12, 5, 34, 1000);

        System.out.println(time.toString());
    }
}
/*--------------------------------------------------------------------------------------------------------------------
    Time sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Time;

class App {
    public static void main(String[] args)
    {
        Time time = new Time(12, 5, 34, 78);

        System.out.println(time.toString());

        time.setHour(24);

        System.out.println(time.toString());
    }
}



/*--------------------------------------------------------------------------------------------------------------------
    Time sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Time;

class App {
    public static void main(String[] args)
    {
        Time time = new Time(12, 5, 34, 78);

        System.out.println(time.toString());

        time.setSecond(-7);

        System.out.println(time.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Time sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Time;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Saat?");
        int hour = Integer.parseInt(kb.nextLine());

        System.out.print("Dakika?");
        int minute = Integer.parseInt(kb.nextLine());

        Time time = new Time(hour, minute, 0, 0);

        System.out.println(time.toString());

        System.out.print("Saat?");
        hour = Integer.parseInt(kb.nextLine());

        System.out.print("Dakika?");
        minute = Integer.parseInt(kb.nextLine());

        time.setHour(hour);
        time.setMinute(minute);

        System.out.println(time.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Time sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Time;

class App {
    public static void main(String[] args)
    {
        for (;;) {
            Time now = new Time();

            System.out.printf("%s\r", now.toString());
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Time sınıfı ve test kodu
    (Test kodu etkin olarak yazılmamıştır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Time;

class App {
    public static void main(String[] args)
    {
        for (;;) {
            Time now = new Time();

            System.out.printf("%s\r", now.toString());
        }
    }
}
/*--------------------------------------------------------------------------------------------------------------------
    Time sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Time;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Random r = new Random();

        for (int i = 0; i < 10; ++i) {
            Time time = Time.of(r);

            System.out.println(time.toLongTimeString());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Time sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Time {
    private int m_hour;
    private int m_minute;
    private int m_second;
    private int m_millisecond;

    private static void doWorkForException(String message)
    {
        System.out.println(message);
        System.exit(-1); //exception konusuna kadar sabredin
    }

    private static boolean isValidForBound(int val, int max)
    {
        return 0 <= val && val <= max;
    }

    private static boolean isValidForHour(int val)
    {
        return isValidForBound(val, 23);
    }

    private static boolean isValidForMinute(int val)
    {
        return isValidForBound(val, 59);
    }

    private static boolean isValidForSecond(int val)
    {
        return isValidForBound(val, 59);
    }

    private static boolean isValidForMillisecond(int val)
    {
        return isValidForBound(val, 999);
    }

    private static boolean isValidForTime(int hour, int minute, int second, int millisecond)
    {
        return isValidForHour(hour) && isValidForMinute(minute) &&
                isValidForSecond(second) && isValidForMillisecond(millisecond);
    }

    private static void checkForHour(int val)
    {
        if (!isValidForHour(val))
            doWorkForException("Invalid hour value:" + val);
    }

    private static void checkForMinute(int val)
    {
        if (!isValidForMinute(val))
            doWorkForException("Invalid minute value:" + val);
    }

    private static void checkForSecond(int val)
    {
        if (!isValidForSecond(val))
            doWorkForException("Invalid second value:" + val);
    }

    private static void checkForMillisecond(int val)
    {
        if (!isValidForMillisecond(val))
            doWorkForException("Invalid millisecond value value:" + val);
    }

    private static void checkForTime(int hour, int minute, int second, int millisecond)
    {
        if (!isValidForTime(hour, minute, second, millisecond))
            doWorkForException(String.format("Invalid time values:all values -> %d, %d, %d, %d", hour, minute, second, millisecond));
    }

    public static Time of()
    {
        return of(new Random());
    }

    public static Time of(Random r)
    {
        return new Time(r.nextInt(24), r.nextInt(60), r.nextInt(60), r.nextInt(1000));
    }

    public Time() //Burada yazılanların bilinmesi gerekmez. Sadece default ctor'un anlamı olarak yazılmıştır
    {
        Calendar now = Calendar.getInstance();

        m_hour = now.get(Calendar.HOUR_OF_DAY);
        m_minute = now.get(Calendar.MINUTE);
        m_second = now.get(Calendar.SECOND);
        m_millisecond = now.get(Calendar.MILLISECOND);
    }

    //...

    public Time(int hour, int minute, int second, int millisecond)
    {
        checkForTime(hour, minute, second, millisecond);
        m_hour = hour;
        m_minute = minute;
        m_second = second;
        m_millisecond = millisecond;
    }

    public int getHour()
    {
        return m_hour;
    }

    public void setHour(int hour)
    {
        if (hour == m_hour)
            return;

        checkForHour(hour);
        m_hour = hour;
    }

    public int getMinute()
    {
        return m_minute;
    }

    public void setMinute(int minute)
    {
        if (minute == m_minute)
            return;

        checkForMinute(minute);
        m_minute = minute;
    }

    public int getSecond()
    {
        return m_second;
    }

    public void setSecond(int second)
    {
        if (second == m_second)
            return;

        checkForSecond(second);
        m_second = second;
    }

    public int getMillisecond()
    {
        return m_millisecond;
    }

    public void setMillisecond(int millisecond)
    {
        if (millisecond == m_millisecond)
            return;

        checkForMillisecond(millisecond);
        m_millisecond = millisecond;
    }

    public String toLongTimeString()
    {
        return String.format("%s.%03d", toString(), m_millisecond);
    }

    public String toString()
    {
        return String.format("%s:%02d", toShortTimeString(), m_second);
    }

    public String toShortTimeString()
    {
        return String.format("%02d:%02d", m_hour, m_minute);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

class App {
    public static void main(String[] args)
    {
        Date date = new Date(21, 3, 2021);

        System.out.println(date.toString('-'));
        System.out.println(date.toString());
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

class App {
    public static void main(String[] args)
    {
        Date date = new Date(25, 3, 2020);

        System.out.println(date.toString('-'));
        System.out.println(date.getDayOfWeekTR());
        System.out.println(date.getDayOfWeekEN());
        System.out.println(date.isLeapYear() ? "Artık yıl" : "Artık yıl değil");
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

class App {
    public static void main(String[] args)
    {
        Date date = new Date(21, 3, 2021);

        System.out.println(date.toStringTR());
        System.out.println(date.toStringEN());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

class App {
    public static void main(String[] args)
    {
        Date date = new Date(10, 3, 2021);

        System.out.println(date.toLongDateStringTR());
        System.out.println(date.toLongDateStringEN());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

class App {
    public static void main(String[] args)
    {
        Date date = new Date(10, 3, 2021);

        System.out.println(date.toLongDateStringTR());
        System.out.println(date.toLongDateStringEN());
        System.out.println(date.isWeekend() ? "Hafta sonu" : "Hafta içi");
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

class App {
    public static void main(String[] args)
    {
        Date date = new Date();

        System.out.println(date.toLongDateStringTR());
        System.out.println(date.toLongDateStringEN());
        System.out.println(date.isWeekend() ? "Hafta sonu" : "Hafta içi");
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Random r = new Random();

        for (int i = 0; i < 10; ++i) {
            Date date = Date.of(r, 1900, 2100);
            System.out.println(date.toLongDateStringEN());
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Random r = new Random();

        for (int i = 0; i < 10; ++i) {
            Date date = Date.of(r);
            System.out.println(date.toLongDateStringEN());
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Klavyeden aşağıdaki formatta girilen bilgiyi ayrıştırarak ekrana sonuçları yazdıran programı yazınız.
    Not: Format geçerlilik kontrolü yapılmayacaktır
    <isim>:<gg/aa/yyyy>:<ders adı>:<vize>:<final>
    Oğuz Karan:10/09/1976:Programlamaya Giriş:76:89
    Oğuz Karan:10/09/1976:Elektronik:55:40
    Bu formatta kişimin vize ve final notlarına göre vize * 0.4 + final * 0.6 formülüne göre geçme notunu hesaplayan ve
    doğum tarihinin hangi güne geldiğini de ekrana yazdıran programı yazınız
    ****** Örnekte Date sınıfının kullanıldığına dikkat ediniz ******
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.studentinfoparser.StudentInfoParserConsoleApp;

class App {
    public static void main(String[] args)
    {
        StudentInfoParserConsoleApp.run();
    }
}

package org.csystem.app.samples.studentinfoparser;

import java.util.Scanner;

public class StudentInfoParserConsoleApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Formatlı yazıyı giriniz:");
            String str = kb.nextLine();

            if ("quit".equals(str))
                break;
            StudentInfoParser parser = new StudentInfoParser(str);
            StudentInfo studentInfo = parser.getStudentInfo();

            System.out.println(studentInfo.toString());
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

package org.csystem.app.samples.studentinfoparser;

import org.csystem.util.datetime.Date;

public class StudentInfo {
    private String m_name;
    private Date m_birthDate;
    private String m_lectureName;
    private int m_midtermGrade;
    private int m_finalGrade;

    public StudentInfo(String name, String birthDateStr, String lectureName, int midtermGrade, int finalGrade)
    {
        m_name = name;
        m_lectureName = lectureName;
        m_midtermGrade = midtermGrade;
        m_finalGrade = finalGrade;
        setBirthDate(birthDateStr);
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        m_name = name;
    }

    public String getLectureName()
    {
        return m_lectureName;
    }

    public void setLectureName(String lectureName)
    {
        m_lectureName = lectureName;
    }

    public int getMidtermGrade()
    {
        return m_midtermGrade;
    }

    public void setMidtermGrade(int midtermGrade)
    {
        m_midtermGrade = midtermGrade;
    }

    public int getFinalGrade()
    {
        return m_finalGrade;
    }

    public void setFinalGrade(int finalGrade)
    {
        m_finalGrade = finalGrade;
    }

    public double getGrade()
    {
        return m_midtermGrade * 0.3 + m_finalGrade * 0.6;
    }

    public void setBirthDate(String birthDateStr)
    {
        String [] birthDateInfo = birthDateStr.split("[/]");
        int day = Integer.parseInt(birthDateInfo[0]);
        int month = Integer.parseInt(birthDateInfo[1]);
        int year = Integer.parseInt(birthDateInfo[2]);

        m_birthDate = new Date(day, month, year);
    }

    public String toString()
    {
        double grade = getGrade();
        String fmt = "{name: %s, birthDate: %s, lectureName: %s, midtermGrade: %d, finalGrade: %d, grade: %f, status:%s}";

        return String.format(fmt, m_name, m_birthDate.toLongDateStringEN(), m_lectureName, m_midtermGrade, m_finalGrade, grade,  grade >= 50 ? "Geçti" : "Kaldı");
    }
}

package org.csystem.app.samples.studentinfoparser;

public class StudentInfoParser {
    private final StudentInfo m_studentInfo;

    //...
    public StudentInfoParser(String str)
    {
        /*
            <isim>:<gg/aa/yyyy>:<ders adı>:<vize>:<final>
            Oğuz Karan:10/09/1976:Programlamaya Giriş:76:89
        */
        String [] studentInfoStr = str.split("[:]+");

        //...

        m_studentInfo = new StudentInfo(studentInfoStr[0], studentInfoStr[1], studentInfoStr[2],
                Integer.parseInt(studentInfoStr[3]), Integer.parseInt(studentInfoStr[4]));
    }

    public StudentInfo getStudentInfo()
    {
        return m_studentInfo;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Date sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Date {
    private static final int [] DAYS_OF_MONTH = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    private static final String [] MONTHS_TR = {
            "", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz",
            "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};
    private static final String [] MONTHS_EN = {
            "", "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    private static final String [] DAYS_OF_WEEK_TR = {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
    private static final String [] DAYS_OF_WEEK_EN = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

    private int m_day;
    private int m_month;
    private int m_year;
    private int m_dayOfWeek;

    private static boolean isLeapYear(int year)
    {
        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    }

    private static boolean isValidDate(int day, int month, int year)
    {
        if (day < 1 || day > 31 || month < 1 || month > 12)
            return false;

        return day <= (month == 2 && isLeapYear(year) ? 29 : DAYS_OF_MONTH[month]);
    }

    private static int getTotalDaysByMonth(int month, int year)
    {
        int totalDays = 0;

        for (int m  = month - 1; m >= 1; --m)
            totalDays += DAYS_OF_MONTH[m];

        return month > 2 && isLeapYear(year) ? totalDays + 1 : totalDays;
    }

    private static int getDayOfYear(int day, int month, int year)
    {
        return day + getTotalDaysByMonth(month, year);
    }

    private static int getDayOfWeek(int day, int month, int year)
    {
        int totalDays = getDayOfYear(day, month, year);

        for (int y = 1900; y < year; ++y)
            totalDays += isLeapYear(y) ? 366 : 365;

        return totalDays % 7;
    }

    private static String getDaySuffix(int day)
    {
        String suffix = "th";

        switch (day) {
            case 1:
            case 21:
            case 31:
                suffix = "st";
                break;
            case 2:
            case 22:
                suffix = "nd";
                break;
            case 3:
            case 23:
                suffix = "rd";
                break;
        }

        return suffix;
    }

    private static void doWorkForException(String message)
    {
        System.out.println(message);
        System.exit(-1); //exception işlemleri konusuna kadar sabredin
    }

    private static void checkForDate(int day, int month, int year, String errMessage)
    {
        if (!isValidDate(day, month, year))
            doWorkForException(errMessage);
    }

    private void checkForDay(int val)
    {
        checkForDate(val, m_month, m_year, "Invalid day value:" + val);
    }

    private void checkForMonth(int val)
    {
        checkForDate(m_day, val, m_year, "Invalid month value:" + val);
    }

    private void checkForYear(int val)
    {
        checkForDate(m_day, m_month, val, "Invalid year value:" + val);
    }

    private void set(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    public static Date of()
    {
        return of(new Random());
    }

    public static Date of(Random r)
    {
        return of(r, new Date().m_year);
    }

    public static Date of(int year)
    {
        return of(new Random(), year);
    }

    public static Date of(Random r, int year)
    {
        return of(r, year, year);
    }

    public static Date of(int minYear, int maxYear)
    {
        return of(new Random(), minYear, maxYear);
    }

    public static Date of(Random r, int minYear, int maxYear)
    {
        int year = r.nextInt(maxYear - minYear + 1) + minYear;
        int month = r.nextInt(12) + 1;
        int day = r.nextInt(month == 2 && isLeapYear(year) ? 29 : DAYS_OF_MONTH[month]) + 1;

        return new Date(day, month, year);
    }

    public Date() //Burada yazılanların bilinmesi gerekmez. Sadece default ctor'un anlamı olarak yazılmıştır
    {
        Calendar now = Calendar.getInstance();

        m_day = now.get(Calendar.DAY_OF_MONTH);
        m_month = now.get(Calendar.MONTH) + 1;
        m_year = now.get(Calendar.YEAR);
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    //...
    public Date(int day, int month, int year)
    {
        checkForDate(day, month, year, String.format("Invalid date values: all valuees -> %d, %d, %d", day, month, year));
        set(day, month, year);
    }

    public int getDay()
    {
        return m_day;
    }

    public void setDay(int day)
    {
        if (day == m_day)
            return;

        checkForDay(day);
        set(day, m_month, m_year);
    }

    public int getMonthValue()
    {
        return m_month;
    }

    public void setMonthValue(int month)
    {
        if (month == m_month)
            return;
        checkForMonth(month);
        set(m_day, month, m_year);
    }

    public int getYear()
    {
        return m_year;
    }

    public void setYear(int year)
    {
        if (year == m_year)
            return;

        checkForYear(year);
        set(m_day, m_month, year);
    }

    public int getDayOfWeek()
    {
        return m_dayOfWeek;
    }

    public String getDayOfWeekTR()
    {
        return DAYS_OF_WEEK_TR[m_dayOfWeek];
    }

    public String getDayOfWeekEN()
    {
        return DAYS_OF_WEEK_EN[m_dayOfWeek];
    }

    public boolean isLeapYear()
    {
        return isLeapYear(m_year);
    }

    public boolean isWeekend()
    {
        return m_dayOfWeek == 0 || m_dayOfWeek == 6;
    }

    public boolean isWeekday()
    {
        return !isWeekend();
    }

    public String toString()
    {
        return toString('/');
    }

    public String toString(char delimiter)
    {
        return String.format("%02d%c%02d%c%04d", m_day, delimiter, m_month, delimiter, m_year);
    }

    public String toStringTR()
    {
        return String.format("%d %s %d", m_day, MONTHS_TR[m_month], m_year);
    }

    public String toStringEN()
    {
        return String.format("%d%s %s %d", m_day, getDaySuffix(m_day), MONTHS_EN[m_month], m_year);
    }

    public String toLongDateStringTR()
    {
        return String.format("%s %s", toStringTR(), DAYS_OF_WEEK_TR[m_dayOfWeek]);
    }

    public String toLongDateStringEN()
    {
        return String.format("%s %s", toStringEN(), DAYS_OF_WEEK_EN[m_dayOfWeek]);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Payı giriniz:");
        int a = Integer.parseInt(kb.nextLine());

        System.out.print("Paydayı giriniz:");
        int b = Integer.parseInt(kb.nextLine());

        Fraction fraction = new Fraction(a, b);

        System.out.println(fraction.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Payı giriniz:");
        int a = Integer.parseInt(kb.nextLine());

        System.out.print("Paydayı giriniz:");
        int b = Integer.parseInt(kb.nextLine());

        Fraction fraction = new Fraction(a, b);

        System.out.println(fraction.toString());

        fraction.setNumerator(0);
        System.out.println(fraction.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Payı giriniz:");
        int a = Integer.parseInt(kb.nextLine());

        System.out.print("Paydayı giriniz:");
        int b = Integer.parseInt(kb.nextLine());

        Fraction fraction = new Fraction(a, b);

        System.out.println(fraction.toString());

        fraction.setDenominator(0);
        System.out.println(fraction.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Payı giriniz:");
        int a = Integer.parseInt(kb.nextLine());

        System.out.print("Paydayı giriniz:");
        int b = Integer.parseInt(kb.nextLine());

        Fraction fraction = new Fraction(a, b);

        System.out.println(fraction.toString());

        fraction.setDenominator(9);
        System.out.println(fraction.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

class App {
    public static void main(String[] args)
    {
        Fraction fraction = new Fraction(3);

        System.out.println(fraction.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

class App {
    public static void main(String[] args)
    {
       Fraction fraction = new Fraction();

        System.out.println(fraction.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

class App {
    public static void main(String[] args)
    {
        Fraction f1 = new Fraction(3, 4);
        Fraction f2 = new Fraction(6, 7);
        Fraction f;

        f = f1.add(f2);

        System.out.println(f.toString());

        f = f1.add(9);

        System.out.println(f.toString());

        f = Fraction.add(9, f1);

        System.out.println(f.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

class App {
    public static void main(String[] args)
    {
        Fraction f1 = new Fraction(3, 4);
        Fraction f2 = new Fraction(8, 7);
        Fraction f;

        f = f1.subtract(f2);

        System.out.println(f.toString());

        f = f1.subtract(9);

        System.out.println(f.toString());

        f = Fraction.subtract(9, f1);

        System.out.println(f.toString());
    }
}
/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

class App {
    public static void main(String[] args)
    {
        Fraction f1 = new Fraction(3, 4);
        Fraction f2 = new Fraction(8, 7);
        Fraction f;

        f = f1.multiply(f2);

        System.out.println(f.toString());

        f = f1.multiply(9);

        System.out.println(f.toString());

        f = Fraction.multiply(9, f1);

        System.out.println(f.toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

class App {
    public static void main(String[] args)
    {
        Fraction f1 = new Fraction(3, 4);
        Fraction f2 = new Fraction(8, 7);
        Fraction f;

        f = f1.divide(f2);

        System.out.println(f.toString());

        f = f1.divide(9);

        System.out.println(f.toString());

        f = Fraction.divide(9, f1);

        System.out.println(f.toString());
    }
}



/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

class App {
    public static void main(String[] args)
    {
        Fraction f = new Fraction(3, 4);

        f.increment(2);
        System.out.println(f.toString());
        f.decrement(2);
        System.out.println(f.toString());

    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

class App {
    public static void main(String[] args)
    {
        Fraction f = new Fraction(3, 4);

        f.increment();
        System.out.println(f.toString());
        f.decrement();
        System.out.println(f.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Fraction sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math;

public class Fraction {
    private int m_a;
    private int m_b;

    private static Fraction add(int a1, int b1, int a2, int b2)
    {
        return new Fraction(a1 * b2 + a2 * b1, b1 * b2);
    }

    private static Fraction subtract(int a1, int b1, int a2, int b2)
    {
        return add(a1, b1, -a2, b2);
    }

    private static Fraction multiply(int a1, int b1, int a2, int b2)
    {
        return new Fraction(a1 * a2, b1 * b2);
    }

    private static Fraction divide(int a1, int b1, int a2, int b2)
    {
        return multiply(a1, b1, b2, a2);
    }

    private static void check(int a, int b)
    {
        if (b == 0) {
            if (a == 0)
                System.out.println("Belirsiz");
            else
                System.out.println("Tanımsız");

            System.exit(-1); // Exception konusuna kadar sabredin
        }
    }

    private void simplify()
    {
        int min = Math.min(Math.abs(m_a), m_b);

        for (int i = min; i >= 2; --i)
            if (m_a % i == 0 && m_b % i == 0) {
                m_a /= i;
                m_b /= i;
                break;
            }
    }

    private void setSign()
    {
        if (m_b < 0) {
            m_a = -m_a;
            m_b = -m_b;
        }
    }

    private void set(int a, int b)
    {
        if (a == 0) {
            m_a = 0;
            m_b = 1;
            return;
        }
        m_a = a;
        m_b = b;
        setSign();
        simplify();
    }

    public Fraction()
    {
        m_b = 1;
    }

    public Fraction(int a)
    {
        m_a = a;
        m_b = 1;
    }

    public Fraction(int a, int b)
    {
        check(a, b);
        set(a, b);
    }

    public int getNumerator()
    {
        return m_a;
    }

    public void setNumerator(int val)
    {
        if (val == m_a)
            return;

        set(val, m_b);
    }

    public int getDenominator()
    {
        return m_b;
    }

    public void setDenominator(int val)
    {
        if (val == m_b)
            return;

        check(m_a, val);
        set(m_a, val);
    }

    public double getRealValue()
    {
        return (double) m_a / m_b;
    }


    //add methods
    public static Fraction add(int val, Fraction f)
    {
        return add(val, 1, f.m_a, f.m_b);
    }

    public Fraction add(Fraction other)
    {
        return add(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction add(int val)
    {
        return add(m_a, m_b, val, 1);
    }

    //subtract methods
    public static Fraction subtract(int val, Fraction f)
    {
        return subtract(val, 1, f.m_a, f.m_b);
    }

    public Fraction subtract(Fraction other)
    {
        return subtract(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction subtract(int val)
    {
        return subtract(m_a, m_b, val, 1);
    }

    //multiply methods
    public static Fraction multiply(int val, Fraction f)
    {
        return multiply(val, 1, f.m_a, f.m_b);
    }

    public Fraction multiply(Fraction other)
    {
        return multiply(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction multiply(int val)
    {
        return multiply(m_a, m_b, val, 1);
    }

    //divide methods
    public static Fraction divide(int val, Fraction f)
    {
        return divide(val, 1, f.m_a, f.m_b);
    }

    public Fraction divide(Fraction other)
    {
        return divide(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction divide(int val)
    {
        return divide(m_a, m_b, val, 1);
    }

    //increment
    public void increment(int val)
    {
        m_a += m_b * val;
    }

    public void increment()
    {
        increment(1);
    }

    //decrement
    public void decrement(int val)
    {
        increment(-val);
    }

    public void decrement()
    {
        decrement(1);
    }

    public String toString()
    {
        return String.format("%d%s", m_a, m_b == 1 ? "" : String.format(" / %s = %f", m_b, getRealValue()));
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    27.03.2021
    Aşağıdaki örnekte move metodunun parametresi int türünden olduğundan parametre değişken ismi ne olduğu
    hakkında bilgi verse de ona geçilebilecek argümanlar anlaşılamamaktadır. Ayrıca çağırma sırasında geçilen argümanlar
    da ne anlama geldikleri hakkında bilgi vermemektedir. Yani bu yaklaşım okunabilir değildir. Şüphesiz move doğru
    yazılsa da çağırma sırasında geçersiz değerler argüman olarak geçilebileceğinden hata yapma olasılığı da fazlalaşır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        SampleGame sampleGame = new SampleGame();

        sampleGame.run();
    }
}

class SampleGame {
    //...
    public void run()
    {
        GameObject gameObject = new GameObject();
        //...
        gameObject.move(1); //top
        gameObject.move(0); //right
        gameObject.move(2); //left
        gameObject.move(3); //bottom
        gameObject.move(1); //top
    }
}


class GameObject {
    //...
    public void move(int direction)
    {
        //...
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte move metodunun parametresi yine bir fikir vermemektedir. Argümanlar açısından okunabilirlik
    artırılmıştır. Ancak programcının çağırma sırasında argümanı yanlış yazma olasılığı yine vardır. Üstelik String
    karşılaştırması göreceli olarak tamsayı karşılaştırmasına göre yavaştır. Dolayısıyla bu yakşlaşımda çok iyi değildir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        SampleGame sampleGame = new SampleGame();

        sampleGame.run();
    }
}

class SampleGame {
    //...
    public void run()
    {
        GameObject gameObject = new GameObject();
        //...
        gameObject.move("top");
        gameObject.move("right");
        gameObject.move("left");
        gameObject.move("bottom");
        gameObject.move("top");
    }
}


class GameObject {
    //...
    public void move(String direction)
    {
        //...
    }
}



/*--------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problemler aşağıdaki gibi bir tasarımla çözülebilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        SampleGame sampleGame = new SampleGame();

        sampleGame.run();
    }
}


class Direction {
    private Direction()
    {
    }

    public static final Direction RIGHT = new Direction();
    public static final Direction TOP = new Direction();
    public static final Direction LEFT = new Direction();
    public static final Direction BOTTOM = new Direction();
}

class SampleGame {

    //...
    public void run()
    {
        GameObject gameObject = new GameObject();
        //...
        gameObject.move(Direction.TOP);
        gameObject.move(Direction.RIGHT);
        gameObject.move(Direction.LEFT);
        gameObject.move(Direction.BOTTOM);
        gameObject.move(Direction.TOP);
    }
}


class GameObject {
    //...
    public void move(Direction direction)
    {
        //...
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Direction sınıfı daha yetenekli hale getirilmiştir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Arrays;

class App {
    public static void main(String[] args)
    {
        Direction direction = Direction.LEFT;

        System.out.printf("Ordinal:%d%n", direction.ordinal());

        int ordinal = 3;

        direction = Direction.values()[ordinal];

        System.out.println(direction.toString());
        System.out.println("/////////////////////////");

        for (Direction d : Direction.values())
            System.out.println(d.toString());
    }
}


class Direction {
    private static final Direction [] DIRECTIONS = {
            new Direction(0, "RIGHT"),
            new Direction(1, "TOP"),
            new Direction(2, "LEFT"),
            new Direction(3, "BOTTOM")};
    private final int m_ordinal;
    private final String m_str;

    private Direction(int ordinal, String str)
    {
        m_ordinal = ordinal;
        m_str = str;
    }

    public static final Direction RIGHT = DIRECTIONS[0];
    public static final Direction TOP = DIRECTIONS[1];
    public static final Direction LEFT = DIRECTIONS[2];
    public static final Direction BOTTOM = DIRECTIONS[3];

    public static Direction[] values()
    {
        return Arrays.copyOf(DIRECTIONS, DIRECTIONS.length);
    }

    public int ordinal()
    {
        return m_ordinal;
    }

    public String toString()
    {
        return m_str;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Yukarıdaki Direction sınıfın Java 5 ile eklenen ve detayları aşağıdaki örneklerde açıklanan enum sınıflar
    kullanılarak daha yalın hale getirilebilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Direction direction = Direction.LEFT;

        System.out.printf("Ordinal:%d%n", direction.ordinal());

        int ordinal = 3;

        direction = Direction.values()[ordinal];

        System.out.println(direction.toString());
        System.out.println("/////////////////////////");

        for (Direction d : Direction.values())
            System.out.println(d.toString());
    }
}

enum Direction {
    RIGHT, TOP, LEFT, BOTTOM
}



/*--------------------------------------------------------------------------------------------------------------------
    enum anahtar sözcüğü ile bir enum türü (enum class) bildirilebilir. enum türü içerisinde ilk noktalı virgülden
    önce (noktalı virgül zorunlu olmadıkça konmaz) bildirilen isimlere enum sabitleri denir. Bu isimler public static
    ve final olarak bildirilmiş o sınıf türünden referanslardır. Bu referansların erbiri ilgili enum türünden yaratılmış
    olan bir nesnenin adresini tutarlar. enum sabitleri için publici, static, final ve tür bilgisi yazılması error
    oluşturur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

enum DayOfWeek {
    SUN, MON, TUE, WED, THU, FRI, SAT
}

enum Color {
    RED, GREEN, BLUE;
}
enum Direction {
    RIGHT, TOP, LEFT, BOTTOM
}


/*--------------------------------------------------------------------------------------------------------------------
    enum türünün ordinal isimli non-static metodu referansa ilişkin nesneyi tutan enum sabitinin sıra numarasını
    döndürür. Ordinal numarası sıfırdan başlar. enum türünün toString metodu vardır ve sabitin yazı karşılığını
    döndürür. enum türünün values() static metodu ile enum sabitlerine ilişkin dizinin bir kopyası elde edilebilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Direction direction = Direction.LEFT;

        System.out.printf("Ordinal:%d%n", direction.ordinal());

        int ordinal = 3;

        direction = Direction.values()[ordinal];

        System.out.println(direction.toString());
        System.out.println("/////////////////////////");

        for (Direction d : Direction.values())
            System.out.println(d.toString());
    }
}

enum Direction {
    RIGHT, TOP, LEFT, BOTTOM
}


/*--------------------------------------------------------------------------------------------------------------------
    enum türünün static valueOf metodu ile enum sabitinin yazı karşılığından tuttuğu referans elde edilebilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Direction direction = Direction.valueOf("LEFT");

        System.out.println(direction.toString());
    }
}

enum Direction {
    RIGHT, TOP, LEFT, BOTTOM
}

/*--------------------------------------------------------------------------------------------------------------------
    enum türünden nesne new operatörü ile hiçbir yerde (sınıf içinde bile) yaratılamaz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Direction direction = new Direction(); //error
    }
}

enum Direction {
    RIGHT, TOP, LEFT, BOTTOM
}


/*--------------------------------------------------------------------------------------------------------------------
    enum sınıfına sabitler dışında metot, veri elemanı ve ctor eklenbilir. Bunun için son bildirilen sabitten sıonra
    noktalı virgül kullanılması gerekir. Eğer enum sınıfının hiçbir sabit yoksa bile (bu durum enum hedefine aykırıdır)
    eklenecek diğer elemanlardan önce yine noktalı virgül konmalıdır. ctor elemanı ayrıca incelenecektir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

enum Sample {
    ;
    private int m_a;
    public void foo()
    {

    }

    public static void bar()
    {

    }
}

enum Color {
    RED, GREEN, BLUE, BLACK, WHITE;
    private int m_a;
    public void foo()
    {

    }

    public static void bar()
    {

    }

}


/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki enum türünde içi boş ()'ler geçerlidir. Hiç parantez konmaması ile aynı anlamdadır. Aslında aşağıdaki
    kullanım ya da parantez koymadan kullanım, sabitlere ilişkin nesneler yaratılırken "default ctor" çağrılsın
    anlamına gelmektedir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

enum Color {
    RED(), GREEN(), BLUE(), BLACK(), WHITE()
}


/*--------------------------------------------------------------------------------------------------------------------
    enum türüne ctor yazılabilir. Ancak bu ctor ya private ya da hiçbir erişim belirleyicisi koymadan bildirilmelidir.
    Aksi durumda error oluşur. Erişim belirleyici yazılmaması enum sınıflarının ctor'ları için private anlamındadır.
    Bu durum yalnızca enum sınıfının ctor'ları için geçerlidir. enum sınıfının ctor'ları public ya da protected olarak
    bildirilemez enum sınıfın türünden nesne enum sınıf içerisinde da yaratılamaz. Ya enum sınıfının ctor'larının
    private olmanından ötesindedir.
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;0

enum Color {
   RED(), GREEN(), BLUE, BLACK, WHITE;
   Color()
   {}

   public void foo()
   {
       Color c = new Color(); //error
   }
}

/*--------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir sınıfın bir elemanı ilk kez kullanıldığında sınıfın tüm static veri elemanları yaratılır ve
    bir daha program sonuna kadar yaşarlar. Aşağıdaki örnekte 5 tane "Color.Color" yazısı ekrana basılacaktır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Color.foo();
        System.out.println("////////////////////");
        Color.foo();
    }
}

enum Color {
   RED(), GREEN(), BLUE, BLACK, WHITE;
   Color()
   {
       System.out.println("Color.Color");
   }

   public static void foo()
   {
   }
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Color enum sınıfına eklenen ctor ile herbir sabite ilişkin nesneye bilgi iliştirilmiştir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        RandomColorFactory colorFactory = new RandomColorFactory();

        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            Color c = colorFactory.getColor();

            System.out.printf("%s:{r : %d, g : %d, b : %d}%n", c.toString(), c.r, c.g, c.b);
        }
    }
}

class RandomColorFactory {
    private final Random m_random;

    public RandomColorFactory()
    {
        m_random = new Random();
    }

    public RandomColorFactory(Random random)
    {
        m_random = random;
    }

    public Color getColor()
    {
        Color [] colors = Color.values();

        return colors[m_random.nextInt(colors.length)];
    }
}

enum Color {
   RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), BLACK(0, 0, 0), WHITE(255, 255, 255);
   public final int r, g, b;
   Color(int x, int y, int z)
   {
       r = x;
       g = y;
       b = z;
   }
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Color enum sınıfına eklenen ctor ile herbir sabite ilişkin nesneye bilgi iliştirilmiştir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        RandomColorFactory colorFactory = new RandomColorFactory();

        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            Color c = colorFactory.getColor();

            System.out.printf("%s:{r : %d, g : %d, b : %d}%n", c.toString(), c.r, c.g, c.b);
        }
    }
}

class RandomColorFactory {
    private final Random m_random;

    public RandomColorFactory()
    {
        m_random = new Random();
    }

    public RandomColorFactory(Random random)
    {
        m_random = random;
    }

    public Color getColor()
    {
        Color [] colors = Color.values();

        return colors[m_random.nextInt(colors.length)];
    }
}

enum Color {
    RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), BLACK(0, 0, 0), WHITE(255, 255, 255),
    R(RED), G(GREEN), B(BLUE);
    public final int r, g, b;
    Color(int x, int y, int z)
    {
        r = x;
        g = y;
        b = z;
    }

    Color(Color c)
    {
        r = c.r;
        g = c.g;
        b = c.b;

    }
}

/*--------------------------------------------------------------------------------------------------------------------
    enum class ile Singleton sınıf bildirimi. Lazy implementation gerekmedikçe veya başka bir gerekçe yoksa singleton
    için en iyi implementasyon aşağıdaki gibidir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Singleton s1 = Singleton.INSTANCE;
        Singleton s2 = Singleton.INSTANCE;

        System.out.println(s1 == s2);

        s1.setX(20);

        System.out.println(s2.getX());
    }
}

enum Singleton {
    INSTANCE;
    private int m_x;

    public int getX()
    {
        return m_x;
    }

    public void setX(int x)
    {
        //...
        m_x = x;
    }

    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    enum türlerinde eşitlik karşılaştırması yani aynı enıum sabitine ilişkin referansın tutulup tutulmadığı == veya !=
    operatörleri ile test edilebilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        RandomColorFactory colorFactory = new RandomColorFactory();

        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            Color c1 = colorFactory.getColor();
            Color c2 = colorFactory.getColor();

            System.out.printf("%s, %s%n", c1.toString(), c2.toString());
            System.out.println(c1 == c2 ? "Aynı nesne" : "Farklı nesneler");
            System.out.println(c1 != c2 ? "Farklı nesneler" : "Aynı nesne");
        }
    }
}

class RandomColorFactory {
    private final Random m_random;

    public RandomColorFactory()
    {
        m_random = new Random();
    }

    public RandomColorFactory(Random random)
    {
        m_random = random;
    }

    public Color getColor()
    {
        Color [] colors = Color.values();

        return colors[m_random.nextInt(colors.length)];
    }
}

enum Color {
    RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), BLACK(0, 0, 0), WHITE(255, 255, 255);
    public final int r, g, b;
    Color(int x, int y, int z)
    {
        r = x;
        g = y;
        b = z;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Eşitlik karşılaştırması equals metodu ile de yapılabilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        RandomColorFactory colorFactory = new RandomColorFactory();

        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            Color c1 = colorFactory.getColor();
            Color c2 = colorFactory.getColor();

            System.out.printf("%s, %s%n", c1.toString(), c2.toString());
            System.out.println(c1.equals(c2) ? "Aynı nesne" : "Farklı nesneler");
        }
    }
}

class RandomColorFactory {
    private final Random m_random;

    public RandomColorFactory()
    {
        m_random = new Random();
    }

    public RandomColorFactory(Random random)
    {
        m_random = random;
    }

    public Color getColor()
    {
        Color [] colors = Color.values();

        return colors[m_random.nextInt(colors.length)];
    }
}

enum Color {
    RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), BLACK(0, 0, 0), WHITE(255, 255, 255);
    public final int r, g, b;
    Color(int x, int y, int z)
    {
        r = x;
        g = y;
        b = z;
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    enum türlerinin compareTo metodu
        a.compareTo(b);
    çağrısı için
        a.ordinal() - b.ordinal()
    sonucunu döndürür
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        RandomDayOfWeeksFactory dayOfWeekFactory = new RandomDayOfWeeksFactory();

        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            DayOfWeek c1 = dayOfWeekFactory.getColor();
            DayOfWeek c2 = dayOfWeekFactory.getColor();

            int diff = c1.compareTo(c2);

            if (diff < 0)
                System.out.printf("%s ile %s arasında %d gün var%n", c1.toString(), c2.toString(), -diff);
            else
                System.out.printf("%s ile %s arasında %d gün var%n", c2.toString(), c1.toString(), diff);
        }
    }
}

class RandomDayOfWeeksFactory {
    private final Random m_random;

    public RandomDayOfWeeksFactory()
    {
        m_random = new Random();
    }

    public RandomDayOfWeeksFactory(Random random)
    {
        m_random = random;
    }

    public DayOfWeek getColor()
    {
        DayOfWeek [] colors = DayOfWeek.values();

        return colors[m_random.nextInt(colors.length)];
    }
}

enum DayOfWeek {
    SUN, MON, TUE, WED, THU, FRI, SAT
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte enum sınıflarının values metodunun döndürdüğü dizinin yeniden yaratıldığı gösterilmektedir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        DayOfWeek [] dayOfWeeks1 = DayOfWeek.values();
        DayOfWeek [] dayOfWeeks2 = DayOfWeek.values();

        System.out.println(dayOfWeeks1 == dayOfWeeks2);
    }
}

enum DayOfWeek {
    SUN, MON, TUE, WED, THU, FRI, SAT
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte enum sınıflarının values metodunun döndürdüğü dizinin yeniden yaratıldığı gösterilmektedir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        DayOfWeek [] dayOfWeeks1 = DayOfWeek.values();

        dayOfWeeks1[0] = DayOfWeek.TUE;
        for (DayOfWeek dayOfWeek : dayOfWeeks1)
            System.out.printf("%s ", dayOfWeek.toString());

        System.out.println();

        for (DayOfWeek dayOfWeek : DayOfWeek.values())
            System.out.printf("%s ", dayOfWeek.toString());

        System.out.println();
    }
}

enum DayOfWeek {
    SUN, MON, TUE, WED, THU, FRI, SAT
}

/*--------------------------------------------------------------------------------------------------------------------
    enum türleri switch deyimi ile de kullanılabilmektedir.  Bu durumda case bölümlerine ilişkin sabitler şüphesiz
    ilgili enum türünden sabitler olmalıdır. Karşılaştırma işlemi == operatörü ile yapılır. case bölümlerine yazılan
    sabitlerde enum ismi kullanımı geçersizdir. Sabit isimleri doğrudan kullanılmalıdır. Zaten switch deyimine ilişkin
    ifadenin enum türü bildiği için case bölümlerinde enum ismi kullanılmasına gerek yoktur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Input marital status (single, married, divorced):");
        String maritalStatusStr = kb.nextLine();
        MaritalStatus maritalStatus = MaritalStatus.valueOf(maritalStatusStr.toUpperCase());

        switch (maritalStatus) {
            case MARRIED:
                System.out.println("Married person");
                break;
            case SINGLE:
                System.out.println("Single person");
                break;
            default:
                System.out.println("Divorced person");
                break;
        }
    }
}

enum MaritalStatus {
    SINGLE, MARRIED, DIVORCED
}

/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

class App {
    public static void main(String[] args)
    {
        Date date = new Date();

        System.out.println(date.getDayOfWeek().toString());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Date sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Month;

class App {
    public static void main(String[] args)
    {
        Date d = new Date(27, Month.MAR, 2021);

        System.out.println(d.toLongDateStringTR());

        d.setMonth(Month.APR);
        System.out.println(d.toLongDateStringTR());
    }
}

package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.IntValue;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;


public class RandomObjectArrayGeneratorApp {
    private RandomObjectArrayGeneratorApp()
    {
    }

    public static void run()
    {
        RandomObjectArrayGenerator rag = new RandomObjectArrayGenerator(5);

        rag.run();

        for (Object object : rag.getObjects()) {
            String typeName = object.getClass().getName();
            System.out.printf("Dinamik tür ismi:%s%n", typeName);

            if (typeName.equals("java.lang.String")) {
                String s = (String)object;

                System.out.printf("Yazı:%s%n", s);
                System.out.printf("Yazı:%s%n", s.toUpperCase());
            }
            else if (typeName.equals("org.csystem.util.datetime.Date")) {
                Date date = (Date)object;

                System.out.println(date.toLongDateStringTR());
            }
            else if (typeName.equals("org.csystem.util.datetime.Time")) {
                Time time = (Time) object;

                System.out.println(time.toLongTimeString());
            }
            else if (typeName.equals("org.csystem.util.IntValue")) {
                IntValue ival = (IntValue)object;

                System.out.printf("ival = %d%n", ival.getVal());
                ival = ival.add(20);
                System.out.printf("ival = %d%n", ival.getVal());
            }
            else {
                int [] a = (int[])object;

                ArrayUtil.display(2, a);
            }
        }
    }
}

package org.csystem.util.datetime;

public enum Month {
    JAN(31), FEB(28), MAR(31), APR(30), MAY(31), JUN(30),
    JUL(31), AUG(31), SEP(30), OCT(31), NOV(30), DEC(31);
    private final int m_days;

    Month(int days)
    {
        m_days = days;
    }

    int getDays(int year)
    {
        return ordinal() == 1 && isLeapYear(year) ? 29 : m_days;
    }

    static boolean isLeapYear(int year)
    {
        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    }
}

package org.csystem.util.datetime;

public enum DayOfWeek {
    SUN, MON, TUE, WED, THU, FRI, SAT
}


/*--------------------------------------------------------------------------------------------------------------------
    Homework-016 için bir ipucu. Detaylar görmezden gelindi
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Card[] deck;

        deck = Card.getShuffledDeck();

        for (Card c : deck)
            System.out.println(c.toString());

    }
}

class Card
{
    private CardValue m_value;
    private CardType m_type;

    public Card(CardValue value, CardType type)
    {
        m_value = value;
        m_type = type;
    }

    //...

    public String toString()
    {
        return String.format("%s-%s", m_type.toString(), m_value.toString());
    }

    //...
    public static Card[] getShuffledDeck()
    {
        Card[] deck = new Card[52];

        int i = 0;

        for (CardType type : CardType.values())
            for (CardValue value : CardValue.values())
                deck[i++] = new Card(value, type);

        //...
        return deck;
    }

    //...
}

enum CardType
{
    SPADE, CLUB, DIAMOND, HEART
}

enum CardValue
{
    TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, KNAVE, QUEEN, KING, ACE
}

/*--------------------------------------------------------------------------------------------------------------------
    28.03.2021
    Aşağıdaki örnekte split metodu göreceli daha kolay kullanılır hale getirilmiştir. İlgili metot için detaylar
    gözardı edilmiştir. Regular expression anlamında eklenecekler vardır ancak burada üzerinde durulmayacaktır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String str = "Bugün    hava    çok güzel. Bu havada [dolaşmak] lazım";

        String [] words = Util.split(str, " .[]", StringSplitOptions.REMOVE_EMPTY_ENTRIES);

        for (String s : words)
            System.out.println(s);
    }
}

enum StringSplitOptions {NONE, REMOVE_EMPTY_ENTRIES}

class Util {
    public static String [] split(String str, String delimiters, StringSplitOptions stringSplitOptions)
    {
        String regex = "[";

        int length = delimiters.length();

        for (int i = 0; i < length; ++i) {
            char delimiter = delimiters.charAt(i);

            regex += delimiter == '[' || delimiter == ']' ? "\\" + delimiter : delimiter;
        }

        regex += stringSplitOptions == StringSplitOptions.REMOVE_EMPTY_ENTRIES ? "]+" : "]";

        return str.split(regex);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıflararası İlişkiler: Sınıflararası ilişkiler aslında nesneler arasındaki ilişkiyi temsil eder. Örneğin,
    araba ile motoru arasında bir ilişki vardır. Ya da, insan ile böbreği arasında da bir ilişki vardır. Örneklerdeki
    ilişkiler aslında nesneler arasındadır. Ancak nesnelerin bu ilişkilerini belirtmek için sınıfların buna uygun yazılması
    gerekir.
    Nesne yönelimli programlama tekniği kullanılarak geliştirilecek bir projenin kodlama aşamasında önce sınıflar ve
    aralarındaki ilişkiler belirlenir. Sonra kodlamaya geçilir. İlişkiler belirlenirken sınıfların ve nesnelerin gerçek
    durumları düşünülür.

    Anahtar Notlar: Bir projenin müşteri ile görüşülmesinden müşterite teslimine (deployment) kadar geçen sürecin çeşitli
    şemalarla anlatılmasını sağlayana UML (Unified Modeling Language) denilen bir araç bazı durumlarda kullanılmaktadır.
    Bu aracın en önemli şeması "sınıf şemaları (class diagras)"'dır. Bu şema kodlamaya yöneliktir. Sınıf şemlarında sınıfın
    özelliklerinin yanında başka sınıfla olan ilişkileri de varsa bellidir. UML her zaman kullanılmalı mıdır? Bunun için
    verilecek cevap nettir: Gerektiğinde kullanılmalıdır.

    Anahtar Notlar: Kavram ya da kavramlar modellenirken o kavramın genel durumu düşünülür. İstisna niteliğinde olacak
    durumlar modelleme yapılırken gözönünde bulundurulmaz. Aksi taktirde hiçbir şey modellenemez. Örneğin araba ile motoru
    arasındaki ilişki için genel durumda şunlar söyleniyor olsun:
        1. Araba nesnesine ait motor nesnesi başka bir araba tarafından kullanılamaz.
        2. Araba nesnesine ait motor nesnesi araba ile hemen hemen ömrüne başlar ve hemen hemen araba ile ömrü son bulur
    Burada örneğin ikinci madde bazı durumlarda gerçekleşmeyebilir. Ama bu ilişkinin genel durumunu değiştirmez.

    Bir sınıfın derlenebilmesi için başka bir sınıfın var olması gerektiği duruma "bağımlılık (dependency)" denir.

    İki sınıf arasında aşağıdaki ilişkilerden ya hiçbiri yoktur ya da aşağıdakilerden bir tanesi vardır:
    1. İçerme (composition) (has a): A ve B arasındaki "A has a B" ilişkisi için aşağıdaki koşulların ikisinin de
    sağlanması gerekir. Ya da bu koşullar sağlanıyorsa bu ilişki vardır:
        - A nesnesine ait B nesnesi başka bir nesne tarafından kullanılamayacak.
        - A nesnesine ait B nesnesi ömrüne hemen hemen A nesnesi ile başlayacak ve hemen hemen A nesnesi ile ömrü
        sonlanacak
    Bu ilişkide A nesnesi kendisine ait B nesnesini istediği durumda (hemen her durumda) kullanabilmektedir. Buna
    bütünsel (whole) kullanım denir.

    2. Birleşme (aggregation) (holds a): A ve B arasındaki "A holds a B" ilişkisi composition kurallarının en az bir
    tanesinin gerçeklenmediği bütünsel kullanım ilişkisidir

    3. Çağrışım (association): A nesnesinin B nesnesini ihtiyacı olduğunda kullanması, saklamaması ilişkisidir. Yani
    bütünsel bir kullanım yoktur. Bu kullanıma parçalı (partial) kullanım da denir

    4. Türetme/Kalıtım (inheritace) (is a): Biyoloji'den programlamaya alınmıştır. Biyoloji'de ebeveynin (parent)
    özelliklerinin çocuğuna (child) aktarılamasıdır. Detaylar ileride ele alınacaktır.

    Anahtar Notlar: Yukarıdaki ilişkilerden "inheritance" dışında kalan ilişkiler için Java'da doğrudan bir sentaks ya da
    semantik kurallar yoktur. Dilin kuralları ile implemente edilir. Ancak "inheritance" için dilin sentaks ve semantik
    kuralları vardır.

    Anahtar Notlar: Bazı sınıfların arasında implementasyonları gereği yukarıdaki ilişkilerden hiçbirisi olmayabilir.
    Ama ortada yine bir bağımlılık (dependency) söz konusudur. Bu da yine genel durumu bozmaz.
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    A ile B arasındaki "composition" ilişkisinin genel biçimi
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A x = new A(/*...*/);

        x.doWork1();
        x.doWork2();
    }
}

class A {
    private B m_b;

    public A(/*...*/)
    {
        m_b = new B(/*...*/);
    }

    public void doWork1()
    {
        //...
        m_b.doSomething();
    }

    public void doWork2()
    {
        //...
        m_b.doSomething();
    }

    //...
}

class B {
    //...
    public void doSomething()
    {
        //...
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Car, Engine ve Plane sınıfları ve aralarındaki ilişkiler
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Car car = new Car(/*...*/);

        car.run();

        System.out.println("///////////////");
        Plane plane = new Plane(4/*...*/);

        plane.fly();
    }
}

class Plane {
    private final Engine [] m_engines;

    private void startEngines()
    {
        //...
        for (Engine engine : m_engines)
            engine.startEngine();
    }

    private void accelerateEngines()
    {
        //...
        for (Engine engine : m_engines)
            engine.accelerateEngine();
    }

    private void slowEngines()
    {
        //...
        for (Engine engine : m_engines)
            engine.slowEngine();
    }


    private void stopEngines()
    {
        //...
        for (Engine engine : m_engines)
            engine.stopEngine();
    }

    public Plane(int n/*...*/)
    {
        m_engines = new Engine[n];

        for (int i = 0; i < n; ++i)
            m_engines[i] = new Engine(/*...*/);
    }

    public void fly()
    {
        startEngines();
        accelerateEngines();
        //...
        System.out.println("flying");

        slowEngines();
        //...
        stopEngines();
    }


}

class Car {
    //...
    private final Engine m_engine;
    public Car(/*...*/)
    {
        m_engine = new Engine(/*...*/);
    }

    public void brake()
    {
        m_engine.slowEngine();
        //...
    }

    public void run()
    {
        m_engine.startEngine();
        m_engine.accelerateEngine();
        //...

        System.out.println("running");

        brake();
        m_engine.stopEngine();
    }
}

class Engine {
    //...
    public void startEngine()
    {
        System.out.println("start engine");
    }

    public void accelerateEngine()
    {
        System.out.println("accelerate engine");
    }

    public void slowEngine()
    {
        System.out.println("slow engine");
    }

    public void stopEngine()
    {
        System.out.println("stop  engine");
    }

    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    A ile B arasındaki "agregation" ilişkisinin genel biçimi
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B x = new B(/*...*/);
        B y = new B(/*...*/);
        A z = new A(x/*...*/);

        z.doWork1();
        z.doWork2();

        z.setB(y);

        z.doWork1();
        z.doWork2();
    }
}

class A {
    private B m_b;

    public A(B b/*...*/)
    {
        //...
        setB(b);
    }

    public void setB(B b)
    {
        //...
        m_b = b;
    }

    public B getB()
    {
        return m_b;
    }

    public void doWork1()
    {
        //...
        m_b.doSomething();
    }

    public void doWork2()
    {
        //...
        m_b.doSomething();
    }

    //...
}

class B {
    //...
    public void doSomething()
    {
        //...
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Command ve Connection sınıfları arasındaki ilişki
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String url = "postgresql:jdbc://192.167.2.34:5432/devicesdb";
        String username = "postgres";
        String password = "csd1993";

        Connection connection= new Connection(url, username,password);

        Command cmdSelect = new Command("select * from devices", connection);
        Command cmdInsert = new Command("insert into devices (name, port) values ('test', 23000)", connection);

        cmdSelect.executeQuery();
        cmdInsert.executeNonQuery();
    }
}

class Command {
    private String m_cmd;
    private Connection m_connection;

    public Command(String cmd, Connection connection)
    {
        //...
        m_cmd = cmd;
        m_connection = connection;
    }

    //...

    public void executeNonQuery()
    {
        System.out.println("executeNonQuery");
        m_connection.connect();
        System.out.printf("Command:%s%n", m_cmd);
    }

    public void executeQuery()
    {
        System.out.println("executeQuery");
        m_connection.connect();
        System.out.printf("Command:%s%n", m_cmd);
    }
}

class Connection {
    private String m_url;
    private String m_username;
    private String m_password;

    public Connection(String url, String username, String password)
    {
        //...
        m_url = url;
        m_username = username;
        m_password = password;
    }

    public String getUrl()
    {
        return m_url;
    }

    public void setUrl(String url)
    {
        //...
        m_url = url;
    }

    public String getUsername()
    {
        return m_username;
    }

    public void setUsername(String username)
    {
        //...
        m_username = username;
    }

    public String getPassword()
    {
        return m_password;
    }

    public void setPassword(String password)
    {
        //...
        m_password = password;
    }

    //...

    public void connect()
    {
        System.out.printf("URL:%s%n", m_url);
        System.out.printf("Username:%s%n", m_username);
        System.out.printf("Password:%s%n", m_password);
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    A ile B arasındaki "association" ilişkisinin genel biçimi
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B x = new B(/*...*/);
        B y = new B(/*...*/);
        A z = new A(/*...*/);

        z.doWork(x);
        //...
        z.doWork(y);

        //...
        z.doWork(x);
    }
}

class A {
    public void doWork(B b)
    {
        //...
        b.doSomething();
        //...
    }
}

class B {
    //...
    public void doSomething()
    {
        //...
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Taxi, Driver ve Client sınıfları ve aralarındaki ilişkiler
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Client client1 = new Client(/*...*/);
        Client client2 = new Client(/*...*/);
        Driver driver = new Driver(/*...*/);
        Taxi taxi = new Taxi(driver/*...*/);

        taxi.take(client1);

        //...
        taxi.take(client2);
        //...
    }
}


class Taxi {
    //...
    private Driver m_driver;
    public Taxi(Driver driver/*...*/)
    {
        //...
        m_driver = driver;
    }

    public Driver getDriver()
    {
        return m_driver;
    }

    public void setDriver(Driver driver)
    {
        //...
        m_driver = driver;
    }

    public void take(Client client)
    {
        //...
    }
}

class Driver {
    //...
}

class Client {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki durumda nesnenin diğer referanslar tarafından değiştirildiğinde, aggratetion işle onu kullanan nesnenin de
    bundan haberi olduğu gösterilmiştir. Çünkü nesne aynı nesnedir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B b = new B();

        b.x = 10;
        A a = new A(b);

        a.display();

        b.x *= 2;

        a.display();
    }
}

class A {
    private B m_b;

    public A(B b)
    {
        m_b = b;
    }

    public void display()
    {
        System.out.printf("x = %d%n", m_b.x);
    }
}

class B {
    public int x;
}

/*--------------------------------------------------------------------------------------------------------------------
    String sınıfı immutable olduğundan aşağıdaki ilişki ne aggregation, ne de composition'dır. İkisine de belirli
    ölçüde yakın olmasına karşın tam olarak uymamaktadır. Bu durum özeldir ve ilişkileri etkilemez. Aynı zamanda
    isim de vermek gerekmez
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        String name = "Ali";
        int no = 1;

        Student student = new Student(name, no);

        System.out.printf("%d, %s%n", student.getNo(), student.getName());

        name = name.toUpperCase();

        System.out.printf("%d, %s%n", student.getNo(), student.getName());
    }
}

class Student {
    private String m_name;
    private int m_no;

    public Student(String name, int no)
    {
        m_name = name;
        m_no = no;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        m_name = name;
    }

    public int getNo()
    {
        return m_no;
    }

    public void setNo(int no)
    {
        m_no = no;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    03.04.2021
    Türetme (inheritance) kavramı programlamada bir sınıfı genişletmek (extension) için kullanılır. Bu genişletme var olan
    özellikler üzerine ekleme olarak düşünülebilir. Bu ilişkide B sınıfı A sınıfından türetilmişse "B is a A" cümlesi
    geçerlidir.

    B sınıfı A sınıfından türetilmiş olsun. B sınıfına A sınıfının bir türemiş sınıfı (derived class) denir. A sınıfına da
    B sınıfının taban sınıfı (base class) denir. Bu iki terim nesne yönelimli programlama paradigmasına yönelik genel
    terimlerdir. Java'da "base class" yerine "super-class, "derived class" yerine ise "sub-class" terimleri daha çok
    kullanılır.

    Anahtar Notlar: Nesne yönelimli programlamada "base class" yerine Biyoloji'den gelen terim olan "parent class" da
    kullanılmaktadır. Benzer şekilde "derived class" yerine de "child class" kullanılmaktadır. Bu terimler az kullanılsa da
    bazı kaynaklarda tercih edilmektedir.

    Bir dizi türetme söz konusu olabilir. Örneğin, C sınıfı, B sınıfından, B sınıfı da A sınıfından türetilmiş olsun.
    Bu durumda C'nin taban sınıfı (super class) dendiğinde doğrudan taban sınıf (direct super class) olan B sınıfı
    anlaşılır. Bu hiyerarşide A sınıfı C'nın dolaylı taban sınıfıdır (indirect super class.) Örneğimizde,
    "C'nin taban sınıfları B ve A'dır." cümlesi teknik olarak doğru değildir. Doğrusu, "C'nin taban sınıf B'dir. Dolaylı
    taban sınıflarından bir A'dır." cümlesidir.

    Java'da bir sınıf birden fazla (doğrudan) taban sınıfa sahip olamaz. Yani Java'da çoklu türetme (multiple inheritance)
    yoktur. Java'da bir sınıf tek bir sınıftan türetilebilir.

    Anahtar Notlar: Java'da çoklu türetmenin gerektiği yerlerde kısmi (partaial) olarak desteklenmesini sağlayan "interface"
    denilen bir tür bulunmaktadır. Bu konu ileride ele alınacaktır. Çoklu türetmenin de pratikte gerektiği durumlar "interface"
    ile çözülebilmektedir.

    Türetme kavramı programlamada "bir sınıfın kodlarına dokunmadan o sınıfı genişletmek" anlamına gelir.
---------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    Java'da türetme extends anahtar sözcüğü ile aşağıdaki gibi yapılır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class C extends B {
    //...
}

class B extends A {
    //..
}

class A {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Taban sınfın metotları türemiş sınıfa da aktarılır. Aşağıdaki örnekte foo ve bar metotları B sınıfında da vardır.
    Bu kavrama "davranışsal genişletme (behavioral extension)" de denir. "extension dendiğinde ilk akla gelen bu olmasa da
    bu da sınıfın genişletilmesidir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B x = new B();

        x.foo();
        x.bar();
        x.tar();
    }
}

class B extends A {
    //...
    public void tar()
    {
        System.out.println("B.tar");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }

    public void bar()
    {
        System.out.println("A.bar");
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Bir dizi türetme durumu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        C x = new C();

        x.foo();
        x.bar();
        x.tar();
        x.zar();
    }
}

class C extends B {
    public void zar()
    {
        System.out.println("C.zar");
    }
}

class B extends A {
    //...
    public void tar()
    {
        System.out.println("B.tar");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }

    public void bar()
    {
        System.out.println("A.bar");
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf türünden referanslar ile taban sınıfının non-static bir veri elemanına erişilebilir. Yani taban sınıfın
    non-static veri elemanları türemiş sınıfa aktarılmış olur. Türemiş sınıf nesnesi içerisinde taban sınıf kadarlık
    bir bölüm bulunmaktadır. Burada nesnesel bir kapsama söz konusudur. Buna göre, türemiş sınıf nesnesinin bellekte
    kapladığı alan "en az taban sınıf nesnesinin bellekte kapladığı alan + türemiş sınıfa eklenen non-static veri elamanlarının
    toplam uzunluğu" kadardır.
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B x = new B();

        x.a = 10;
        x.b = 20;

        System.out.printf("x.a = %d%n", x.a);
        System.out.printf("x.b = %d%n", x.b);
    }
}

class B extends A {
    public int b;
    //...
}

class A {
    public int a;
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Bir dizi türetme durumu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        C x = new C();

        x.a = 10;
        x.b = 20;
        x.c = 3.4;

        System.out.printf("x.a = %d%n", x.a);
        System.out.printf("x.b = %d%n", x.b);
        System.out.printf("x.c = %f%n", x.c);
    }
}

class C extends B {
    public double c;
    //...
}

class B extends A {
    public int b;
    //...
}

class A {
    public int a;
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf nesnesinin yaratılması aşamasında ctor .çağrısından önce taban sınıfın ctor'u çağrılır. Herhangi bir
    belirtme yapılmamışsa taban sınıfın default ctor'u çağrılır. Yani derleyici ctor'un başına gizlice default
    ctor çağrısını yerleştirir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B x = new B();
        System.out.println("//////////////////");
        B y = new B(10);
        System.out.println("//////////////////");
        B z = new B();
    }
}

class B extends A {
    public B()
    {
        System.out.println("B.B()");
    }

    public B(int a)
    {
        System.out.println("B.B(int)");
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }
}
/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte A'nın default ctor'u private olduğundan B sınıfının bildiriminde error oluşur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
    public B() //error
    {
        System.out.println("B.B()");
    }

    public B(int a) //error
    {
        System.out.println("B.B(int)");
    }
}

class A {
    private A()
    {
        System.out.println("A.A()");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte A'nın default ctor'u olmadığından B sınıfının bildiriminde error oluşur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
    public B() //error
    {
        System.out.println("B.B()");
    }

    public B(int a) //error
    {
        System.out.println("B.B(int)");
    }
}

class A {
    public A(int a)
    {
        System.out.println("A.A(int)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Türemiş sınıfı yazan programcı super ctor sentaksı ile türemiş sınıfın istenilen ctor'unun çağrılmasını
    sağlayabilir. super ctor sentaksında hangi ctor'un çağrılacağının belirlenmesi süreci metot çağrıları için
    anlattığımız "method overload resolution" kuralları ile aynıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B x = new B();
        System.out.println("//////////////////");
        B y = new B(10);
    }
}

class B extends A {
    public B()
    {
        super(0);
        System.out.println("B.B()");
    }

    public B(int a)
    {
        super(a);
        System.out.println("B.B(int)");
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Türemiş sınıfı yazan programcı super ctor sentaksı ile türemiş sınıfın istenilen ctor'unun çağrılmasını
    sağlayabilir. super ctor sentaksında hangi ctor'un çağrılacağının belirlenmesi süreci metot çağrıları için
    anlattığımız "method overload resolution" kuralları ile aynıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B x = new B();
        System.out.println("//////////////////");
        B y = new B(10);
    }
}

class B extends A {
    public B()
    {
        System.out.println("B.B()");
    }

    public B(int a)
    {
        super(a);
        System.out.println("B.B(int)");
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Bir dizi türetme durumu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        C x = new C();
        System.out.println("//////////////////");
        C y = new C(10);
    }
}


class C extends B {
    public C()
    {
        System.out.println("C.C()");
    }

    public C(int a)
    {
        super(a);
        System.out.println("C.C(int)");
    }
}

class B extends A {
    public B()
    {
        System.out.println("B.B()");
    }

    public B(int a)
    {
        super(a);
        System.out.println("B.B(int)");
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
    //...
}


/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte * ve ** satırlarındaki super ctor sentaksı yazılmasa da aynı anlamdadır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        C x = new C();
        System.out.println("//////////////////");
        C y = new C(10);
    }
}


class C extends B {
    public C()
    {
        super(); //*
        System.out.println("C.C()");
    }

    public C(int a)
    {
        super(a);
        System.out.println("C.C(int)");
    }
}

class B extends A {
    public B()
    {
        super(); //**
        System.out.println("B.B()");
    }

    public B(int a)
    {
        super(a);
        System.out.println("B.B(int)");
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    super ctor sentaksı ctor'un ilk deyimi olmalıdır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
    public B()
    {
        System.out.println("B.B()");
    }

    public B(int a)
    {
        System.out.println("B.B(int)");
        super(a); //error
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    super ctor sentaksı adından da anlaşılacağı gibi yalnızca ctor'lar içerisinde kullanılabilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
    public B()
    {
        System.out.println("B.B()");
    }

    public B(int a)
    {
        super(a);
        System.out.println("B.B(int)");
    }

    public void foo(int a)
    {
        super(a); //error
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Bazı durumlarda bir sınıfın ctor'u içerisinde sınıfın başka bir ctor'unun çağrılması istenebilir. Bu durumda this
    ctor sentaksı kullanılır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A x = new A();
        System.out.println("////////////////");
        A y = new A(3.4);
        System.out.println("////////////////");
        A z = new A(10);
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        this("istanbul");
        System.out.println("A.A(double)");
    }

    public A(double a)
    {
        this();
        System.out.println("A.A(double)");
    }

    public A(String  a)
    {
        System.out.println("A.A(String)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    this ctor sentaksı da ctor'un ilk deyimi olmak zorundadır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A x = new A();
        System.out.println("////////////////");
        A y = new A(3.4);
        System.out.println("////////////////");
        A z = new A(10);
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {

        System.out.println("A.A(double)");
        this("istanbul"); //error
    }

    public A(double a)
    {
        this();
        System.out.println("A.A(double)");
    }

    public A(String  a)
    {
        System.out.println("A.A(String)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    this ve super ctor sentaksları aynı anda bulunamazlar. Böyle bir durumla karşılaşan programcı yazdığı koda bakmalıdır.
    Çünkü doğru bir yaklaşım ve kodlama programcıyı bu şekilde bir kullanıma zaten getirmez
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
    public B()
    {
        System.out.println("B.B()");
    }

    public B(int a)
    {
        this();
        super(a); //error

        System.out.println("B.B(int)");
    }
}

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    this ctor sentaksında döngüsel durum geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A {
    public A() //error
    {
        this(0);
        System.out.println("A.A()");
    }

    public A(int a) //error
    {
        this();
        System.out.println("A.A(int)");
    }
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    this ctor sentaksında döngüsel durum geçersizdir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A {
    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a) //error
    {
        this(10);
        System.out.println("A.A(int)");
    }
    //...
}


/*--------------------------------------------------------------------------------------------------------------------
    Java'da bir sınıf herhangi bir sınıftan extends anahtar sözcüğü ile türetilmese bile java.lang paketi içerisindeki
    Object isimli bir sınıftan türetilmiş kabul edilir. Yani tüm sınıflar doğrudan ya da dolaylı olarak Object
    sınıfından türetilmiştir. Başka bir deyişle Object sınıfı doğrudan ya da dolaylı olarak tüm sınıfların taban sınıfıdır.
    Bir sınıf herhangibir sınıftan türetilmemişse Object extends anahtar sözcüğü ile yazılabilir. Yazılmasa da bu durum
    için aynı anlamlıdır. Bu durumda yazmamayı tercih edeceğiz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class C extends A {
    //...
}

class A {
    //...
}

class B extends Object {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Genel nitelikli ve niteliksiz isim arama kurallarına göre bir isim ilgili sınıfta bulunamazsa taban sınıfa ve
    dolaylı taban sınıflara da sırasıyla bulununcaya ya da bulunamayıncaya kadar bakılır
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B b = new B();

        b.bar(10);

        System.out.printf("b.x = %d%n", b.x);
    }
}


class B extends A {
    public void bar(int a)
    {
        foo();
        x = a;
    }
}

class A {
    public int x;

    public void foo()
    {
        System.out.println("A.foo");
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    protected bölüme türemiş sınıflar da aşağıdaki gibi erişemezler
---------------------------------------------------------------------------------------------------------------------*/
package mest;

import test.A;

public class B extends A {
    public void bar()
    {
        A a = new A();

        a.x = 10;

        a.foo();
    }
}

package test;

public class A {
    protected int x;
    protected A(/*...*/)
    {

    }

    protected void foo()
    {

    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf içerisinde kendisine ait olan taban sınıf bölümünün protected elemanlarına erişilebilir. Yani türemiş
    sınıf nesnesinin taban sınıf nesnesine ilişkin protected bölüme erişim geçelidir
---------------------------------------------------------------------------------------------------------------------*/
package mest;

import test.A;

public class B extends A {
    public B()
    {

    }

    public void bar()
    {
        x = 10;

        foo();
    }
}

package test;

public class A {
    protected int x;
    protected A(/*...*/)
    {
        System.out.println("A.A(/*...*/)");
    }

    protected void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Date sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Date {
    private static final String [] MONTHS_TR = {
            "", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz",
            "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};
    private static final String [] MONTHS_EN = {
            "", "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    private static final String [] DAYS_OF_WEEK_TR = {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
    private static final String [] DAYS_OF_WEEK_EN = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    private static final Month [] MONTHS = Month.values();

    private int m_day;
    private int m_month;
    private int m_year;
    private int m_dayOfWeek;

    private static boolean isValidDate(int day, int month, int year)
    {
        if (day < 1 || day > 31 || month < 1 || month > 12)
            return false;

        return day <= MONTHS[month - 1].getDays(year);
    }

    private static int getTotalDaysByMonth(int month, int year)
    {
        int totalDays = 0;

        for (int m  = month - 1; m >= 1; --m)
            totalDays += MONTHS[m - 1].getDays(year);

        return month > 2 && Month.isLeapYear(year) ? totalDays + 1 : totalDays;
    }

    private static int getDayOfYear(int day, int month, int year)
    {
        return day + getTotalDaysByMonth(month, year);
    }

    private static int getDayOfWeek(int day, int month, int year)
    {
        int totalDays = getDayOfYear(day, month, year);

        for (int y = 1900; y < year; ++y)
            totalDays += Month.isLeapYear(y) ? 366 : 365;

        return totalDays % 7;
    }

    private static String getDaySuffix(int day)
    {
        String suffix = "th";

        switch (day) {
            case 1:
            case 21:
            case 31:
                suffix = "st";
                break;
            case 2:
            case 22:
                suffix = "nd";
                break;
            case 3:
            case 23:
                suffix = "rd";
                break;
        }

        return suffix;
    }

    private static void doWorkForException(String message)
    {
        System.out.println(message);
        System.exit(-1); //exception işlemleri konusuna kadar sabredin
    }

    private static void checkForDate(int day, int month, int year, String errMessage)
    {
        if (!isValidDate(day, month, year))
            doWorkForException(errMessage);
    }

    private void checkForDay(int val)
    {
        checkForDate(val, m_month, m_year, "Invalid day value:" + val);
    }

    private void checkForMonth(int val)
    {
        checkForDate(m_day, val, m_year, "Invalid month value:" + val);
    }

    private void checkForYear(int val)
    {
        checkForDate(m_day, m_month, val, "Invalid year value:" + val);
    }

    private void set(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    public static Date of()
    {
        return of(new Random());
    }

    public static Date of(Random r)
    {
        return of(r, new Date().m_year);
    }

    public static Date of(int year)
    {
        return of(new Random(), year);
    }

    public static Date of(Random r, int year)
    {
        return of(r, year, year);
    }

    public static Date of(int minYear, int maxYear)
    {
        return of(new Random(), minYear, maxYear);
    }

    public static Date of(Random r, int minYear, int maxYear)
    {
        int year = r.nextInt(maxYear - minYear + 1) + minYear;
        int month = r.nextInt(12) + 1;
        int day = r.nextInt(MONTHS[month].getDays(year)) + 1;

        return new Date(day, month, year);
    }

    public Date() //Burada yazılanların bilinmesi gerekmez. Sadece default ctor'un anlamı olarak yazılmıştır
    {
        Calendar now = Calendar.getInstance();

        m_day = now.get(Calendar.DAY_OF_MONTH);
        m_month = now.get(Calendar.MONTH) + 1;
        m_year = now.get(Calendar.YEAR);
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    public Date(int day, Month month, int year)
    {
        this(day, month.ordinal() + 1, year);
    }

    public Date(int day, int month, int year)
    {
        checkForDate(day, month, year, String.format("Invalid date values: all values -> %d, %d, %d", day, month, year));
        set(day, month, year);
    }

    public int getDay()
    {
        return m_day;
    }

    public void setDay(int day)
    {
        if (day == m_day)
            return;

        checkForDay(day);
        set(day, m_month, m_year);
    }

    public Month getMonth()
    {
        return MONTHS[m_month - 1];
    }

    public void setMonth(Month month)
    {
        setMonthValue(month.ordinal() + 1);
    }
    public int getMonthValue()
    {
        return m_month;
    }

    public void setMonthValue(int month)
    {
        if (month == m_month)
            return;

        checkForMonth(month);
        set(m_day, month, m_year);
    }

    public int getYear()
    {
        return m_year;
    }

    public void setYear(int year)
    {
        if (year == m_year)
            return;

        checkForYear(year);
        set(m_day, m_month, year);
    }

    public DayOfWeek getDayOfWeek()
    {
        return DayOfWeek.values()[m_dayOfWeek];
    }

    public String getDayOfWeekTR()
    {
        return DAYS_OF_WEEK_TR[m_dayOfWeek];
    }

    public String getDayOfWeekEN()
    {
        return DAYS_OF_WEEK_EN[m_dayOfWeek];
    }

    public boolean isLeapYear()
    {
        return Month.isLeapYear(m_year);
    }

    public boolean isWeekend()
    {
        return m_dayOfWeek == 0 || m_dayOfWeek == 6;
    }

    public boolean isWeekday()
    {
        return !isWeekend();
    }

    public String toString()
    {
        return toString('/');
    }

    public String toString(char delimiter)
    {
        return String.format("%02d%c%02d%c%04d", m_day, delimiter, m_month, delimiter, m_year);
    }

    public String toStringTR()
    {
        return String.format("%d %s %d", m_day, MONTHS_TR[m_month], m_year);
    }

    public String toStringEN()
    {
        return String.format("%d%s %s %d", m_day, getDaySuffix(m_day), MONTHS_EN[m_month], m_year);
    }

    public String toLongDateStringTR()
    {
        return String.format("%s %s", toStringTR(), DAYS_OF_WEEK_TR[m_dayOfWeek]);
    }

    public String toLongDateStringEN()
    {
        return String.format("%s %s", toStringEN(), DAYS_OF_WEEK_EN[m_dayOfWeek]);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Time sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Time {
    private int m_hour;
    private int m_minute;
    private int m_second;
    private int m_millisecond;

    private static void doWorkForException(String message)
    {
        System.out.println(message);
        System.exit(-1); //exception konusuna kadar sabredin
    }

    private static boolean isValidForBound(int val, int max)
    {
        return 0 <= val && val <= max;
    }

    private static boolean isValidForHour(int val)
    {
        return isValidForBound(val, 23);
    }

    private static boolean isValidForMinute(int val)
    {
        return isValidForBound(val, 59);
    }

    private static boolean isValidForSecond(int val)
    {
        return isValidForBound(val, 59);
    }

    private static boolean isValidForMillisecond(int val)
    {
        return isValidForBound(val, 999);
    }

    private static boolean isValidForTime(int hour, int minute, int second, int millisecond)
    {
        return isValidForHour(hour) && isValidForMinute(minute) &&
                isValidForSecond(second) && isValidForMillisecond(millisecond);
    }

    private static void checkForHour(int val)
    {
        if (!isValidForHour(val))
            doWorkForException("Invalid hour value:" + val);
    }

    private static void checkForMinute(int val)
    {
        if (!isValidForMinute(val))
            doWorkForException("Invalid minute value:" + val);
    }

    private static void checkForSecond(int val)
    {
        if (!isValidForSecond(val))
            doWorkForException("Invalid second value:" + val);
    }

    private static void checkForMillisecond(int val)
    {
        if (!isValidForMillisecond(val))
            doWorkForException("Invalid millisecond value value:" + val);
    }

    private static void checkForTime(int hour, int minute, int second, int millisecond)
    {
        if (!isValidForTime(hour, minute, second, millisecond))
            doWorkForException(String.format("Invalid time values:all values -> %d, %d, %d, %d", hour, minute, second, millisecond));
    }

    public static Time of()
    {
        return of(new Random());
    }

    public static Time of(Random r)
    {
        return new Time(r.nextInt(24), r.nextInt(60), r.nextInt(60), r.nextInt(1000));
    }

    public Time() //Burada yazılanların bilinmesi gerekmez. Sadece default ctor'un anlamı olarak yazılmıştır
    {
        Calendar now = Calendar.getInstance();

        m_hour = now.get(Calendar.HOUR_OF_DAY);
        m_minute = now.get(Calendar.MINUTE);
        m_second = now.get(Calendar.SECOND);
        m_millisecond = now.get(Calendar.MILLISECOND);
    }

    public Time(int hour, int minute)
    {
        this(hour, minute, 0);
    }

    public Time(int hour, int minute, int second)
    {
        this(hour, minute, second, 0);
    }

    public Time(int hour, int minute, int second, int millisecond)
    {
        checkForTime(hour, minute, second, millisecond);
        m_hour = hour;
        m_minute = minute;
        m_second = second;
        m_millisecond = millisecond;
    }

    public int getHour()
    {
        return m_hour;
    }

    public void setHour(int hour)
    {
        if (hour == m_hour)
            return;

        checkForHour(hour);
        m_hour = hour;
    }

    public int getMinute()
    {
        return m_minute;
    }

    public void setMinute(int minute)
    {
        if (minute == m_minute)
            return;

        checkForMinute(minute);
        m_minute = minute;
    }

    public int getSecond()
    {
        return m_second;
    }

    public void setSecond(int second)
    {
        if (second == m_second)
            return;

        checkForSecond(second);
        m_second = second;
    }

    public int getMillisecond()
    {
        return m_millisecond;
    }

    public void setMillisecond(int millisecond)
    {
        if (millisecond == m_millisecond)
            return;

        checkForMillisecond(millisecond);
        m_millisecond = millisecond;
    }

    public String toLongTimeString()
    {
        return String.format("%s.%03d", toString(), m_millisecond);
    }

    public String toString()
    {
        return String.format("%s:%02d", toShortTimeString(), m_second);
    }

    public String toShortTimeString()
    {
        return String.format("%02d:%02d", m_hour, m_minute);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.AnalyticalCircle;

class App {
    public static void main(String[] args)
    {
        AnalyticalCircle ac = new AnalyticalCircle(-3.4, 100, 67);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.AnalyticalCircle;

class App {
    public static void main(String[] args)
    {
        AnalyticalCircle ac = new AnalyticalCircle();

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.AnalyticalCircle;

class App {
    public static void main(String[] args)
    {
        AnalyticalCircle ac = new AnalyticalCircle(-3.5);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.AnalyticalCircle;

class App {
    public static void main(String[] args)
    {
        AnalyticalCircle ac = new AnalyticalCircle(100, 100);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.AnalyticalCircle;

class App {
    public static void main(String[] args)
    {
        AnalyticalCircle ac = new AnalyticalCircle(100, 100);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());

        ac.setRadius(3.6);
        ac.setX(200);
        ac.setY(300);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı ve test kodu
    Aşağıdaki kodu double ve Point parametreli ctor'u aşağıdaki gibi yazarak test edip problemi inceleyiniz:
    public AnalyticalCircle(double r, Point center)
    {
        super(r);
        m_center = center;
    }
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.AnalyticalCircle;
import org.csystem.util.math.geometry.Point;

class App {
    public static void main(String[] args)
    {
        Point center = new Point(100, 100);
        AnalyticalCircle ac = new AnalyticalCircle(-4.5, center);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());

        center.offset(-20);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı ve test kodu:
    Bir sınıfın içerisinde veri elemanı olarak tuttuğu referansa ilişkin bir metodun aynı isimde ve genel olarak
    aynı parametrik yapıda yazılan bir versiyonuna "delegate method" denir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.AnalyticalCircle;
import org.csystem.util.math.geometry.Point;

class App {
    public static void main(String[] args)
    {
        Point center = new Point(100, 100);
        AnalyticalCircle ac = new AnalyticalCircle(-4.5, center);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());

        ac.offset(-20);

        System.out.printf("Radius:%f%n", ac.getRadius());
        System.out.printf("Area:%f%n", ac.getArea());
        System.out.printf("Circumference:%f%n", ac.getCircumference());
        System.out.printf("{x : %d, y : %d}%n", ac.getX(), ac.getY());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı ve test kodu
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.geometry.AnalyticalCircle;

class App {
    public static void main(String[] args)
    {
        AnalyticalCircle ac1 = new AnalyticalCircle(3, 100, 100);
        AnalyticalCircle ac2 = new AnalyticalCircle(3, 50, 50);

        System.out.println(ac1.centerDistance(ac2));
    }
}



/*----------------------------------------------------------------------------------------------------------------------
	AnalyticalCircle sınıfı
	- AnalyticalCircle is a Circle, has a Point
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

public class AnalyticalCircle extends Circle {
    private final Point m_center;

    public AnalyticalCircle()
    {
        this(0);
    }

    public AnalyticalCircle(Point center)
    {
        this(0, center);
    }

    public AnalyticalCircle(double r, Point center)
    {
        this(r, center.x, center.y);
    }

    public AnalyticalCircle(double r)
    {
        this(r, 0, 0);
    }

    public AnalyticalCircle(int x, int y)
    {
        this(0, x, y);
    }

    public AnalyticalCircle(double r, int x, int y) //primary ctor
    {
        super(r);
        m_center = new Point(x, y);
    }

    public int getX() {return m_center.x;}
    public int getY() {return m_center.y;}

    public Point getCenter()
    {
        return new Point(m_center.x, m_center.y);
    }

    public void setX(int x)
    {
        m_center.x = x;
    }

    public void setY(int y)
    {
        m_center.y = y;
    }

    public void set(int x, int y)
    {
        setX(x);
        setY(y);
    }

    public void set(Point center)
    {
        set(center.x, center.y);
    }

    public void offset(int dxy)
    {
        offset(dxy, dxy);
    }

    public void offset(int dx, int dy)
    {
        m_center.offset(dx, dy);
    }

    public double centerDistance(AnalyticalCircle analyticalCircle)
    {
        return m_center.distance(analyticalCircle.m_center);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.*;

public class Point {
	public int x;
	public int y;

	public Point()
	{
	}

	public Point(int a)
	{
		x = a;
	}

	public Point(int a, int b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(int a, int b)
	{
		return sqrt((x - a) * (x - a) + (y - b) * (y - b));
	}

	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("{x : %d, y : %d}", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Circle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.PI;

public class Circle {
    private double m_r;

    public Circle()
    {
    }

    public Circle(double r)
    {
        setRadius(r);
    }

    public double getRadius()
    {
        return m_r;
    }

    public void setRadius(double r)
    {
        m_r = Math.abs(r);
    }

    public double getArea()
    {
        return PI * m_r * m_r;
    }

    public double getCircumference()
    {
        return 2 * PI * m_r;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    04.04.2021
    Homework-008-1. sorunun bir çözümü
    Dikkat: IntelliJ consolu'u ile test ederken yazıyı değiştirmek genellikle hatalı yazı yazılmasına yol açar. Bunun
    için aşağıdaki örnek yazılarla kopyala-yapştır yaparak test edebilirsiniz.
    Örnek yazılar:
    - Bu örnekten {daha {zor {örnekler de yapacağız} değil}} mi
    - Bu örnekten daha {zor örnekler de yapacağız değil}} mi
    - Bu örnekten {daha zor
    - Bu örnekten daha zor } örnekler
    - {test}
    - {{test}}
    - {{test}}
    - {}


    (İleride daha iyileri yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.findtextincurly.FindTextInCurlyApp;

class App {
    public static void main(String[] args)
    {
        FindTextInCurlyApp.run();
    }
}

package org.csystem.app.samples.findtextincurly;

import java.util.Scanner;

public class FindTextInCurlyApp {
    private FindTextInCurlyApp()
    {
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        FindTextInCurly findTextInCurly = new FindTextInCurly();

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String str = kb.nextLine();

            if ("elma".equals(str))
                break;

            findTextInCurly.setText(str);

            findTextInCurly.findText();

            System.out.println(findTextInCurly.isValid()?  findTextInCurly.getResult() : "Geçersiz");
        }
    }
}

package org.csystem.app.samples.findtextincurly;

public class FindTextInCurly {
    private String m_text;
    private String m_result;
    private boolean m_valid = true;

    public FindTextInCurly()
    {
        this("");
    }

    public FindTextInCurly(String text)
    {
        setText(text);
    }

    public String getText()
    {
        return m_text;
    }

    public String getResult()
    {
        return m_result;
    }

    public void setText(String text)
    {
        //...
        m_text = text;
        m_result = text;
        m_valid = true;
    }

    public boolean isValid()
    {
        return m_valid;
    }

    public void setValid(boolean valid)
    {
        m_valid = valid;
    }

    public void findText()
    {
        for (;;) {
            int begin = m_result.indexOf("{");
            int end = m_result.lastIndexOf("}");

            if (begin == -1 && end != -1 || begin > end) {
                m_valid = false;
                break;
            }

            if (end == -1)
                break;

            m_result = m_result.substring(begin + 1, end);
        }
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Homework-008-2. sorunun bir çözümü
    (İleride daha iyileri yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        DisplayTextApp.run();
    }
}

class DisplayTextApp {
    public static void displayText(String str)
    {
        int length = str.length();

        for (int i = 0; i < length; ++i) {
            for (int k = 0; k <= i; ++k)
                System.out.print(str.charAt(k));

            System.out.println();
        }
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String str = kb.nextLine();

            if ("elma".equals(str))
                break;

            displayText(str);
        }
    }
}



/*--------------------------------------------------------------------------------------------------------------------
    Homework-008-2. sorunun bir çözümü
    (İleride daha iyileri yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        DisplayTextApp.run();
    }
}

class DisplayTextApp {
    public static void displayText(String str)
    {
        int length = str.length();

        for (int i = 0; i < length; ++i)
            System.out.println(str.substring(0, i + 1));
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String str = kb.nextLine();

            if ("elma".equals(str))
                break;

            displayText(str);
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Homework-008-3. sorunun bir çözümü
    (İleride daha iyileri yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        WrapWithBracesApp.run();
    }
}

class WrapWithBracesApp {
    public static String getText(String str)
    {
        return String.format("(%s)", str.trim());
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String str = kb.nextLine();

            if ("elma".equals(str))
                break;

            System.out.println(getText(str));
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Homework-008-4. sorunun bir çözümü
    (İleride daha iyileri yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        SqueezeTest.run();
    }
}

class SqueezeTest {
    private SqueezeTest()
    {
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Birinci yazıyı giriniz:");
            String s1 = kb.nextLine();

            System.out.print("İkinci yazıyı giriniz:");
            String s2 = kb.nextLine();

            System.out.println(StringUtil.squeeze(s1, s2));

            if ("elma".equals(s1))
                break;
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Homework-008-6. sorunun bir çözümü
    (İleride daha iyileri yazılacaktır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        IsValidVariableTest.run();
    }
}

class IsValidVariableTest {
    private IsValidVariableTest()
    {
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String s = kb.nextLine();

            System.out.println(Util.isValidVariable(s) ? "Geçerli" : "Geçersiz");

            if ("elma".equals(s))
                break;
        }
    }
}


class Util {
    public static boolean isValidVariable(String s)
    {
        if (s.equals("_"))
            return false; //Java 9 ve sonrası için değişken kontrolü

        if (s.isBlank())
            return false;

        char ch = s.charAt(0);

        if (!Character.isLetter(ch) && ch != '_' && ch != '$')
            return false;

        int length = s.length();

        for (int i = 1; i < length; ++i) {
            ch = s.charAt(i);

            if (!Character.isLetter(ch) && !Character.isDigit(ch) && ch != '_' && ch != '$')
                return false;
        }

        return true;
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Homework-008-6. sorunun bir çözümü
    (Character sınıfının isJavaIdentifierPart ve isJavaIdentifierStart metotları ile yapılmıştır)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        IsJavaIdentifierTest.run();
    }
}

class IsJavaIdentifierTest {
    private IsJavaIdentifierTest()
    {
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String s = kb.nextLine();

            System.out.println(StringUtil.isJavaIdentifier(s) ? "Geçerli" : "Geçersiz");

            if ("elma".equals(s))
                break;
        }
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    Aralarında türetme ilişkisi olmayan iki sınıf türünden referans birbirine tür dönüştürme operartörü
    kullanılarak bile atanamaz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B b = new B();
        A a;

        a = (A)b; //error

        //...
    }
}

class B {
    public int y;
    //...
}

class A {
    public int x;
}

/*--------------------------------------------------------------------------------------------------------------------
    Taban sınıf türünden bir referans türemiş sınıf türünden bir referansa doğrudan atanamaz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A a = new A();
        B b;

        b = a; //error
    }
}


class B extends A {
    public int y;
    //...
}

class A {
    public int x;
}

/*--------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf türünden bir referans taban sınıf türünden bir referansa doğrudan atanabilir. Bu kavrama
    "yukarıya doğru dönüşüm (upcasting)"
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B b = new B();
        A a;

        a = b; //upcasting

        //...
    }
}

class B extends A {
    public int y;
    //...
}

class A {
    public int x;
}

/*--------------------------------------------------------------------------------------------------------------------
    "upcasting" işleminde taban sınıf referansına, ona atanan türemiş sınıf referansının gösterdiği nesnenin taban sınıf
    bölümünün adresi atanmış olur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B x = new B();
        A y;

        x.a = 10;
        x.b = 34;

        y = x;

        System.out.printf("y.a = %d%n", y.a);
        System.out.printf("x.a = %d%n", x.a);

        y.a *= 2;
        System.out.printf("y.a = %d%n", y.a);
        System.out.printf("x.a = %d%n", x.a);
    }
}

class B extends A {
    public int b;
    //...
}

class A {
    public int a;
}

/*--------------------------------------------------------------------------------------------------------------------
    10.04.2021
    Aşağıdaki örnekte doWork metodu yalnızca A sınıfına bağlı (dependency) olarak yazılmıştır. Bu metot A sınıfından
    doğrudan ya da dolaylı olarak türetilen her sınıf türden referans ile çağrılabilir. Yani doWork metodu derleme
    zamanında yalnızca A ismini bilir. Hatta daha sonra A'dan doğrudan ya da dolaylı olarak türetilmiş sınıflar
    eklendiğinde doWork metodunun değiştirilmesi gerekmez
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A x = new A();
        B y = new B();
        C z = new C();
        D t = new D();

        Sample.doWork(x); //upcasting
        Sample.doWork(y); //upcasting
        Sample.doWork(z); //upcasting
        Sample.doWork(t); //upcasting
    }
}

class Sample {
    public static void doWork(A a)
    {
        ++a.a;
    }
}

class D extends A {
    //...
}

class C extends B {
    //...
}

class B extends A {
    public int b;
    //...
}

class A {
    public int a;
}

/*--------------------------------------------------------------------------------------------------------------------
    CompanyApp uygulaması
    (Detaylar gözardı edilmiştir)
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.company.CompanyApp;

class App {
    public static void main(String[] args)
    {
        CompanyApp.run();
    }
}

package org.csystem.app.samples.company;

public class CompanyApp {
    private CompanyApp()
    {
    }

    public static void run()
    {
        HumanResources hr = new HumanResources();
        Manager m = new Manager();

        m.setName("Ali");
        m.setAddress("Mecidiyeköy");
        m.setCitizenId("12345678912");
        m.setSalary(20000);
        m.setDepartment("Yazılım");

        Worker w = new Worker();

        w.setName("Veli");
        w.setAddress("Şişli");
        w.setCitizenId("12345677912");
        w.setFeePerHour(100);
        w.setHourPerDay(8);

        SalesManager sm = new SalesManager();

        sm.setName("Ayşe");
        sm.setAddress("Beylikdüzü");
        sm.setCitizenId("12345678916");
        sm.setSalary(20000);
        sm.setDepartment("Yazılım");
        sm.setExtra(1200.34);

        ProjectWorker pw = new ProjectWorker();

        pw.setName("Zeynep");
        pw.setAddress("Fatih");
        pw.setCitizenId("12345577912");
        pw.setFeePerHour(89.78);
        pw.setHourPerDay(8);
        pw.setProjectName("network system");
        pw.setRatio(20.5);

        hr.payInsurance(m);
        hr.payInsurance(w);
        hr.payInsurance(sm);
        hr.payInsurance(pw);
    }
}
package org.csystem.app.samples.company;

public class Employee {
    private String m_name;
    private String m_citizenId;
    private String m_address;

    //...

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        //...
        m_citizenId = citizenId;
    }

    public String getAddress()
    {
        return m_address;
    }

    public void setAddress(String address)
    {
        //...
        m_address = address;
    }
    //...
}

package org.csystem.app.samples.company;

public class HumanResources {
    //...
    public void payInsurance(Employee employee)
    {
        System.out.println("---------------------");
        System.out.printf("Name:%s%n", employee.getName());
        System.out.printf("Citizen Id:%s%n", employee.getCitizenId());
        //...
        System.out.println("---------------------");
    }
}

package org.csystem.app.samples.company;

public class Worker extends Employee {
    private int m_hourPerDay;
    private double m_feePerHour;

    //...

    public int getHourPerDay()
    {
        return m_hourPerDay;
    }

    public void setHourPerDay(int hourPerDay)
    {
        //...
        m_hourPerDay = hourPerDay;
    }

    public double getFeePerHour()
    {
        return m_feePerHour;
    }

    public void setFeePerHour(double feePerHour)
    {
        //...
        m_feePerHour = feePerHour;
    }
}

package org.csystem.app.samples.company;

public class ProjectWorker  extends Worker {
    private String m_projectName;
    private double m_ratio;
    //...

    public String getProjectName()
    {
        return m_projectName;
    }

    public void setProjectName(String projectName)
    {
        //...
        m_projectName = projectName;
    }

    public double getRatio()
    {
        return m_ratio;
    }

    public void setRatio(double ratio)
    {
        //...
        m_ratio = ratio;
    }

    //...
}

package org.csystem.app.samples.company;

public class SalesManager extends Manager {
    private double m_extra;

    //...

    public double getExtra()
    {
        return m_extra;
    }

    public void setExtra(double extra)
    {
        //...
        m_extra = extra;
    }

    //...
}

package org.csystem.app.samples.company;

public class Manager extends Employee {
    private double m_salary;
    private String m_department;

    //...

    public double getSalary()
    {
        return m_salary;
    }

    public void setSalary(double salary)
    {
        //...
        m_salary = salary;
    }

    public String getDepartment()
    {
        return m_department;
    }

    public void setDepartment(String department)
    {
        //...
        m_department = department;
    }

    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Bir referansın iki tane türü vardır: statik türü, dinamik türü
    - statik tür (static type): Bir referansın statik türü o referansın bildirildiği türdür. "Referansın türü"
    dendiğinde statik tür anlaşılır. Derleme zamanına ilişkin bir bilgidir ve değişmez

    - dinamik tür (dynamic type): Bir referansın dinamik türü o referansın gösterdiği nesnenin gerçek türüdür. Çalışma
    zamanına ilişkin bir bilgidir ve değişebilir

    Anahtar Notlar: Bir referansın dinamik türü String olarak aşağıdaki genel biçimde elde edilebilir:
        <referans>.getClass().getName();
    Buna göre x bir referans olmak üzere x referansının dinamik türü ekrana şu şekilde yazdırılabilir:
        System.out.println(x.getClass().getName());
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A x;
        B y;

        x = new A(); //x'in static A, dinamik türü A
        y = new B(); //y'in static B, dinamik türü B

        System.out.println(x.getClass().getName());
        System.out.println(y.getClass().getName());

        x = y; //x'in static türü A, dinamik türü B

        System.out.println(x.getClass().getName());
        System.out.println(y.getClass().getName());
    }
}

class B extends A {
    //...
}

class A {
    //...
}


/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte x'in dinamik türünün değişimi gösterilmiştir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);

        A x;

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int val = Integer.parseInt(kb.nextLine());
            if (val == 0)
                break;

            x = val > 0 ? new B() : new A();

            System.out.println(x.getClass().getName());
        }
    }
}

class B extends A {
    //...
}

class A {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte x'in dinamik türünün değişimi gösterilmiştir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);

        A x;
        Sample s = new Sample();
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i) {
            x = s.getAInstance();

            System.out.println(x.getClass().getName());
        }
    }
}

class Sample {
    private final Random m_random = new Random();
    //...
    public A getAInstance()
    {
        int val = m_random.nextInt(4);
        A x;

        switch (val) {
            case 0:
                x = new B();
                break;
            case 1:
                x = new C();
                break;
            case 2:
                x = new D();
                break;
            default:
                x = new A();
        }

        return x;
    }
}

class D extends A {

}
class C extends B {
    //...
}

class B extends A {
    //...
}

class A {
    //...
}


/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte z'nin dinamik türü C olur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        C x = new C();
        B y;
        A z;

        y = x;
        System.out.println(y.getClass().getName());
        z = y;
        System.out.println(z.getClass().getName());
    }
}

class C extends B {
    //...
}

class B extends A {
    //...
}

class A {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Anahtar notlar: Bir dizi referansının dinamik türüne ilişkin isim JNI (Java Native Interface) tür ismi olarak
    elde edilir. Bu isim arakoda eklenen isimdir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        int [] a = new int[5];
        double [] b = new double[3];
        boolean [] c = new boolean[10];
        char [] d = new char[20];
        String [] e = new String[10];

        System.out.println(a.getClass().getName());
        System.out.println(b.getClass().getName());
        System.out.println(c.getClass().getName());
        System.out.println(d.getClass().getName());
        System.out.println(e.getClass().getName());
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Taban sınıf türünden bir referans türemiş sınıf türündenbir referansa doğrudan atanamaz. Bu işlem tür dönüştürme
    operatörü ile (explicit) atanabilir. Burada tür dönüştürme operatörü derlemeden geçmek için kullanılır. Çalışma
    zamanı sırasında kaynak referansın dinamik türünün tür dönüştürme operatörüne yazılan türü kapsayıp kapsamadığına
    bakılır (Buradaki kapsamanın nesnesel olduğunu anımsayınız.) Kapsıyorsa "haklı dönüşümdür" ve akış yoluna devam eder.
    Kapsamıyorsa "haksız dönüşümdür" ve exception oluşur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());
        A x;
        B y;

        x = val > 0 ? new A() : new B();
        System.out.println(x.getClass().getName());
        y = (B)x; //downcasting

        System.out.println("Tekrar yapıyor musunuz?");
        y.a = 10;
        y.b = 30;
    }
}

class B extends A {
    public int b;
}

class A {
    public int a;
}


/*--------------------------------------------------------------------------------------------------------------------
    Taban sınıf türünden bir referans türemiş sınıf türündenbir referansa doğrudan atanamaz. Bu işlem tür dönüştürme
    operatörü ile (explicit) atanabilir. Burada tür dönüştürme operatörü derlemeden geçmek için kullanılır. Çalışma
    zamanı sırasında kaynak referansın dinamik türünün tür dönüştürme operatörüne yazılan türü kapsayıp kapsamadığına
    bakılır (Buradaki kapsamanın nesnesel olduğunu anımsayınız.) Kapsıyorsa "haklı dönüşümdür" ve akış yoluna devam eder.
    Kapsamıyorsa "haksız dönüşümdür" ve exception oluşur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());
        A x;
        B y;

        if (val > 0)
            x = new C();
        else if (val == 0)
            x = new B();
        else
            x = new A();

        System.out.println(x.getClass().getName());
        y = (B)x; //downcasting

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class C extends B {
    //...
}

class B extends A {
    //...
}

class A {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Object sınıfı her sınıfın doğrudan ya da dolaylı olarak taban sınıfı olduğundan her türden referans Object
    referansına atanabilir. Aşağıdaki örnekte çeşitli referans türleri için Object referansları kullanılarak
    upcasting yapılmış ve downcasting ile dinamik türlere ilişkin referanslara atama yapılmıştır. Şüphesiz downcasting
    işleminin dinamik tür bilinmeden yapılması exception fırlatılmasına yol açabilir. Bilinmiyorsa ne yapılacaktır?
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.Fraction;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Object os = "ankara";
        Object or = new Random();
        Object of = new Fraction(3, 4);
        Object ob = new B();
        Object oc = new C();
        Object oa = new int[10];

        System.out.println(os.getClass().getName());
        System.out.println(or.getClass().getName());
        System.out.println(of.getClass().getName());
        System.out.println(ob.getClass().getName());
        System.out.println(oc.getClass().getName());
        System.out.println(oa.getClass().getName());

        String s = (String)os;
        Random r = (Random)or;
        Fraction f = (Fraction)of;
        B b = (B)ob;
        C c = (C)oc;
        int [] a = (int[])oa;

        System.out.println(s);
        System.out.println(r.nextInt(100));
        System.out.println(f.toString());
        System.out.println(a[0]);
    }
}

class C extends B {
    //...
}

class B extends A {
    //...
}

class A {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Object dizisinin referanslarının dinamik türlerine göre downcasting yapılmıştır. Dinamik tür bir
    bilgisi tür isminden elde edilmiştir. Programcının tür ismini yanlış yazma olasılığı vardır. Ayrıca yazı karşılaştırması
    göreceli yavaştır.
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.randomgenerator.RandomObjectArrayGeneratorApp;

class App {
    public static void main(String[] args)
    {
        RandomObjectArrayGeneratorApp.run();
    }
}

package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.IntValue;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;


public class RandomObjectArrayGeneratorApp {
    private RandomObjectArrayGeneratorApp()
    {
    }

    public static void run()
    {
        RandomObjectArrayGenerator rag = new RandomObjectArrayGenerator(5);

        rag.run();

        for (Object object : rag.getObjects()) {
            String typeName = object.getClass().getName();
            System.out.printf("Dinamik tür ismi:%s%n", typeName);

            if (typeName.equals("java.lang.String")) {
                String s = (String)object;

                System.out.printf("Yazı:%s%n", s);
                System.out.printf("Yazı:%s%n", s.toUpperCase());
            }
            else if (typeName.equals("org.csystem.util.datetime.Date")) {
                Date date = (Date)object;

                System.out.println(date.toLongDateStringTR());
            }
            else if (typeName.equals("org.csystem.util.datetime.Time")) {
                Time time = (Time) object;

                System.out.println(time.toLongTimeString());
            }
            else if (typeName.equals("org.csystem.util.IntValue")) {
                IntValue ival = (IntValue)object;

                System.out.printf("ival = %d%n", ival.getVal());
                ival = ival.add(20);
                System.out.printf("ival = %d%n", ival.getVal());
            }
            else {
                int [] a = (int[])object;

                ArrayUtil.display(2, a);
            }
        }
    }
}
package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.IntValue;
import org.csystem.util.StringUtil;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;

import java.util.Random;

public class RandomObjectArrayGenerator {
    private final Random m_random;
    private final Object [] m_objects;

    private Object getRandomObject()
    {
        int n = m_random.nextInt(5);

        Object object;

        switch (n) {
            case 0:
                object = StringUtil.getRandomTextTR(m_random, m_random.nextInt(20) + 1);
                break;
            case 1:
                object = Date.of(m_random);
                break;
            case 2:
                object = Time.of(m_random);
                break;
            case 3:
                object = IntValue.of(m_random.nextInt(255) - 128);
                break;
            default:
                object = ArrayUtil.generateRandomArray(m_random, 10, 0, 100);

        }
        return object;
    }

    public RandomObjectArrayGenerator(int n)
    {
        m_random = new Random();
        m_objects = new Object[n];
    }

    public Object [] getObjects()
    {
        return m_objects;
    }

    public void run()
    {
        for (int i = 0; i < m_objects.length; ++i)
            m_objects[i] = getRandomObject();
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    11.04.2021
    instanceof operatörü iki operandlı araek özel amaçlı bir operatördür. instanceof operatörünün birinci operandı bir
    referans olmalıdır. İkinci operandı ise bir referans ismi olmalıdır. Bu operatörün ürettiği değer boolean türdendir.
    Operatör birinci operandına ilişkin referansın dinamik türü, ikinci operandına ilişkin türü kapsıyorsa true, kapsamıyorsa
    false değerini üretir. Özellike "downcasting" işleminin güvenli yapılması için (haklı dönüşüm) kullanılır
---------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte instanceof operatörü kullanılarak hem okunabilirlik artırılmıi, hem yazı içerisinde hata
    yapma ortadan kaldırılmış hem de karşılaştırma işlemi göreceli daha etkin hale getirilmiştir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.randomgenerator.RandomObjectArrayGeneratorApp;

class App {
    public static void main(String[] args)
    {
        RandomObjectArrayGeneratorApp.run();
    }
}

package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.IntValue;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;


public class RandomObjectArrayGeneratorApp {
    private RandomObjectArrayGeneratorApp()
    {
    }

    public static void run()
    {
        RandomObjectArrayGenerator rag = new RandomObjectArrayGenerator(5);

        rag.run();

        for (Object object : rag.getObjects()) {
            String typeName = object.getClass().getName();
            System.out.printf("Dinamik tür ismi:%s%n", typeName);

            if (object instanceof String) {
                String s = (String)object;

                System.out.printf("Yazı:%s%n", s);
                System.out.printf("Yazı:%s%n", s.toUpperCase());
            }
            else if (object instanceof Date) {
                Date date = (Date)object;

                System.out.println(date.toLongDateStringTR());
            }
            else if (object instanceof Time) {
                Time time = (Time) object;

                System.out.println(time.toLongTimeString());
            }
            else if (object instanceof IntValue) {
                IntValue ival = (IntValue)object;

                System.out.printf("ival = %d%n", ival.getVal());
                ival = ival.add(20);
                System.out.printf("ival = %d%n", ival.getVal());
            }
            else if (object instanceof int[]){
                int [] a = (int[])object;

                ArrayUtil.display(2, a);
            }
        }
    }
}

package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.IntValue;
import org.csystem.util.StringUtil;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;

import java.util.Random;

public class RandomObjectArrayGenerator {
    private final Random m_random;
    private final Object [] m_objects;

    private Object getRandomObject()
    {
        int n = m_random.nextInt(5);

        Object object;

        switch (n) {
            case 0:
                object = StringUtil.getRandomTextTR(m_random, m_random.nextInt(20) + 1);
                break;
            case 1:
                object = Date.of(m_random);
                break;
            case 2:
                object = Time.of(m_random);
                break;
            case 3:
                object = IntValue.of(m_random.nextInt(255) - 128);
                break;
            default:
                object = ArrayUtil.generateRandomArray(m_random, 10, 0, 100);

        }
        return object;
    }

    public RandomObjectArrayGenerator(int n)
    {
        m_random = new Random();
        m_objects = new Object[n];
    }

    public Object [] getObjects()
    {
        return m_objects;
    }

    public void run()
    {
        for (int i = 0; i < m_objects.length; ++i)
            m_objects[i] = getRandomObject();
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    instanceof operatörü birinci operandına ilişkin referansın dinamik türünün, ikinci operandına ilişkin türü kapsayıp
    kapsamadığına bakar
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());
        A x;

        x = Sample.getAInstanceByValue(val);

        System.out.println(x.getClass().getName());

        if (x instanceof B) {
            B b = (B)x;

            b.foo(20);
            System.out.println(b.getX());
        }
        else
            System.out.println("foo metodu çağrılamaz");
    }
}

class Sample {
    //...
    public static A getAInstanceByValue(int val)
    {
        A x;

        if (val > 0)
            x = new C();
        else if (val == 0)
            x = new B();
        else
            x = new A();

        return x;
    }
}


class C extends B {
    //...
}

class B extends A {
    //...
    private int m_x;
    public void foo(int x)
    {
        m_x = x;
        System.out.println("B.foo");
    }

    public int getX()
    {
        return m_x;
    }
}

class A {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    instanceof operatörü birinci operandına ilişkin referansın dinamik türünün, ikinci operandına ilişkin türü kapsayıp
    kapsamadığına bakar
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());
        A x;

        x = Sample.getAInstanceByValue(val);

        System.out.println(x.getClass().getName());

        if (x instanceof B) {
            B b = (B)x;

            b.foo(20);
            System.out.println(b.getX());
        }
        else
            System.out.println("foo metodu çağrılamaz");
    }
}

class Sample {
    //...
    public static A getAInstanceByValue(int val)
    {
        A x;

        if (val > 0)
            x = new C();
        else if (val == 0)
            x = new B();
        else
            x = new A();

        return x;
    }
}


class C extends A {
    //...
}

class B extends A {
    //...
    private int m_x;
    public void foo(int x)
    {
        m_x = x;
        System.out.println("B.foo");
    }

    public int getX()
    {
        return m_x;
    }
}

class A {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Sarmalayan Sınıflar (wrapper classes): Java'da her temel (built-in, primitive) türe karşılık bir sınıf getirilmiştir. Bunun
	nedeni bu sınıfları tanıdıkça anlaşılacaktır. Bu sınıflar sarmalamanın dışında ilgili türe ilişkin yardımcı
	elemanları da barındırırlar. Örneğin Integer sınıfının parseInt metodu bir yazıdan (String) int türden bir değer
	elde etmek için kullanılır.

	Temel türlere ilişkin sarmalayan sınıflar aşağıdaki gibidir:

	Temel Tür				Sarmalayan Sınıf İsmi
	----------------------------------------------
	short						Short
	int							Integer
	long						Long
	byte						Byte
	double						Double
	float						Float
	char						Character
	boolean						Boolean

	Bu türlerden tamsayı ve gerçek sayı türlerine ilişkin sınıflara nümerik sarmalayan sınıf denebilir.
	Sarmalayan sınıflara ilişkin temel özellikler şunlardır:
	- Tamsayı ve gerçek sayı türlerine ilişkin sınıflar (Short, Integer, Long, Byte, Float, Double) Number isimli bir sınıftan
	türetilmiştir. Number sınıfı java.lang paketi içerisindedir. Number sınıfının metotları ileride ele alınacaktır.

	- Sarmalayan sınıflar immutable'dır.

	- Bu sınıflar temel türden değerin heap de tutulması için kullanılır. Bu kavrama kutulama (boxing) denir. Bu konu
	ileride ele alınacaktır.

	- Java 9 ile birlikte sarmalayan sınıfların ctor'ları depracated olmuştur. Java 5 den itibaren zaten kullanılmayan
	bu ctor'lar artık hiç kullanılmamalıdır. Bunun nedeni ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı, gerçek sayı ve char türlerine ilişkin sarmalayan sınıfların MIN_VALUE ve MAX_VALUE isimli final static
	veri elemanları vardır. Bu elemanlar ilişkin oldukları temel türdendir. Double ve Float sınıflarının MIN_VALUE
	değerlerinin pozitif olduğuna dikkat ediniz. Bu durum IEEE 754 formatına ilişkindir. double ve float türleri
	için sınırlar aşağıdaki gibi -+ biçimindedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		System.out.printf("short:[%d, %d]%n", Short.MIN_VALUE, Short.MAX_VALUE);
		System.out.printf("int:[%d, %d]%n", Integer.MIN_VALUE, Integer.MAX_VALUE);
		System.out.printf("long:[%d, %d]%n", Long.MIN_VALUE, Long.MAX_VALUE);
		System.out.printf("byte:[%d, %d]%n", Byte.MIN_VALUE, Byte.MAX_VALUE);
		System.out.printf("char:[%d, %d]%n", (int)Character.MIN_VALUE, (int)Character.MAX_VALUE);
		System.out.printf("double:[-+%.325f, -+%f]%n", Double.MIN_VALUE, Double.MAX_VALUE);
		System.out.printf("float:[-+%.325f, -+%f]%n", Float.MIN_VALUE, Float.MAX_VALUE);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Boolean sınıfı haricindeki tüm sarmalayan sınıfların SIZE isimli final ve static veri elemanları ilgili
	temel türün bit cinsinden uzunluk bilgisini tutar. Bu eleman okunabilirliği artırmak için ilgili türün
	uzunluğu gerektiğinde kullanılabilir. Java' da temel türlerin uzunluğu sistemden sisteme değişmeyeceğinden
	doğrudan sayısal değerleri de kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		System.out.printf("sizeof(short)=%d bits%n", Short.SIZE);
		System.out.printf("sizeof(int)=%d bits%n", Integer.SIZE);
		System.out.printf("sizeof(long)=%d bits%n", Long.SIZE);
		System.out.printf("sizeof(byte)=%d bits%n", Byte.SIZE);
		System.out.printf("sizeof(char)=%d bits%n", Character.SIZE);
		System.out.printf("sizeof(double)=%d bits%n", Double.SIZE);
		System.out.printf("sizeof(float)=%d bits%n", Float.SIZE);
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Boolean sınıfı haricindeki tüm sarmalayan sınıfların BYTES isimli final ve static veri elemanları ilgili
	temel türün byte cinsinden uzunluk bilgisini tutar. Bu eleman okunabilirliği artırmak için ilgili türün
	uzunluğu gerektiğinde kullanılabilir. Java' da temel türlerin uzunluğu sistemden sisteme değişmeyeceğinden
	doğrudan sayısal değerleri de kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		System.out.printf("sizeof(short)=%d Bytes%n", Short.BYTES);
		System.out.printf("sizeof(int)=%d Bytes%n", Integer.BYTES);
		System.out.printf("sizeof(long)=%d Bytes%n", Long.BYTES);
		System.out.printf("sizeof(byte)=%d Bytes%n", Byte.BYTES);
		System.out.printf("sizeof(char)=%d Bytes%n", Character.BYTES);
		System.out.printf("sizeof(double)=%d Bytes%n", Double.BYTES);
		System.out.printf("sizeof(float)=%d Bytes%n", Float.BYTES);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bilindiği gibi nümeric türlerin parseXXX metotları ile bir yazıdan ilgili türe ilişkin değer elde edilebilir.
	Character sınıfı dışında tüm sarmalayan sınıfların parseXXX metotları vardır. Boolean sınıfı dışındaki tüm
	sarmalayan sınıfların pareXXX metotları yazıyı ilgili türe çeviremezse exception fırlatır. Boolean sınıfının
	parseBoolean metodu çeviremediği bir yazı için false değerini döndürür. Yani kısaca parseBoolean metodu büyük-küçük
	harf duyarsız bir biçimde yazının true olması durumunda true değerini, diğer tüm yazılar için false değerini
	döndürür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("true veya false giriniz:");
        boolean flag = Boolean.parseBoolean(kb.nextLine());

        System.out.printf("flag=%b%n", flag);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Integer sınıfının radix (sayı sistemi) parametreli parseInt metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Sayı sistemini giriniz:");
		int radix = Integer.parseInt(kb.nextLine());

		System.out.printf("%d sayı sistemine uygun bir sayı giriniz:", radix);
		int val = Integer.parseInt(kb.nextLine(), radix);

		System.out.printf("val=%d%n", val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte substring ve parseInt metotları kullanılarak yazı içeeisindeki not bilgisi elde edilmiştir.
    Format geçerlilik kontrolü yapılmamıştır. Bir sonraki örnek dolayısıyla split metodu kullanılmamıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        String [] devicesInfo = {
                "Weather sensor\0:23000:\0:192.168.2.123",
                "Humudity Sensor\0:55000:\0:192.168.1.45",
                "Test Sensor\0:1025:\0:127.0.0.1",
        };

        DeviceFactory sf = new DeviceFactory(devicesInfo);

        for (Device device : sf.getDevices())
            System.out.println(device.toString());
    }
}

class DeviceFactory {
    private final String [] m_devicessStr;

    public DeviceFactory(String [] devicessStr)
    {
        m_devicessStr = devicessStr;
    }

    public Device[] getDevices()
    {
        //Yazı geçerlilik kontrolü yapılmalı. Burada gözardı edildi
        Device [] devices = new Device[m_devicessStr.length];

        //"Weather sensor\023000\0192.168.2.123",
        for (int i = 0; i < m_devicessStr.length; ++i) {
            String deviceStr = m_devicessStr[i];
            int firstNullCharIndex = deviceStr.indexOf('\0');
            //...

            int secondNullCharIndex = deviceStr.lastIndexOf('\0');
            //...


            String portStr = deviceStr.substring(firstNullCharIndex + 2, secondNullCharIndex - 1);

            int port = Integer.parseInt(portStr);

            devices[i] = new Device(deviceStr.substring(0, firstNullCharIndex), deviceStr.substring(secondNullCharIndex + 2), port);
        }

        return devices;
    }
}

class Device {
    private String m_name;
    private String m_host;
    private int m_port;

    public Device(String name, String host, int port)
    {
        //...
        m_name = name;
        m_host = host;
        m_port = port;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getHost()
    {
        return m_host;
    }

    public void setHost(String host)
    {
        //...
        m_host = host;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }

    public String toString()
    {
        return String.format("[%s]%s:%d", m_name, m_host, m_port);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte indeksler bulunduktan sonra sayıyı çevirme işlemi Java 9 ile eklenen parseInt metodu ile çok daha
    kolay bir biçimde yapılabilir. Format geçerlilik kontrolü yapılmamıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        String [] devicesInfo = {
                "Weather sensor\0:23000:\0:192.168.2.123",
                "Humudity Sensor\0:55000:\0:192.168.1.45",
                "Test Sensor\0:1025:\0:127.0.0.1",
        };

        DeviceFactory sf = new DeviceFactory(devicesInfo);

        for (Device device : sf.getDevices())
            System.out.println(device.toString());
    }
}

class DeviceFactory {
    private final String [] m_devicessStr;

    public DeviceFactory(String [] devicessStr)
    {
        m_devicessStr = devicessStr;
    }

    public Device[] getDevices()
    {
        //Yazı geçerlilik kontrolü yapılmalı. Burada gözardı edildi
        Device [] devices = new Device[m_devicessStr.length];

        //"Weather sensor\023000\0192.168.2.123",
        for (int i = 0; i < m_devicessStr.length; ++i) {
            String deviceStr = m_devicessStr[i];
            int firstNullCharIndex = deviceStr.indexOf('\0');
            //...

            int secondNullCharIndex = deviceStr.lastIndexOf('\0');
            //...

            int port = Integer.parseInt(deviceStr, firstNullCharIndex + 2, secondNullCharIndex - 1, 10); //Since Java 9

            devices[i] = new Device(deviceStr.substring(0, firstNullCharIndex), deviceStr.substring(secondNullCharIndex + 2), port);
        }

        return devices;
    }
}

class Device {
    private String m_name;
    private String m_host;
    private int m_port;

    public Device(String name, String host, int port)
    {
        //...
        m_name = name;
        m_host = host;
        m_port = port;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getHost()
    {
        return m_host;
    }

    public void setHost(String host)
    {
        //...
        m_host = host;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }

    public String toString()
    {
        return String.format("[%s]%s:%d", m_name, m_host, m_port);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sarmalayan sınıfların ctor'ları Java 9 ile birlikte deprecated olmuştur. Yani kutulama (boxing) için ctor'lar
    kullanılmamalıdır. Zaten Java 5 ile birlikte ctor kullanımı da tavsiye edilmez. Nedeni ileride anlatılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Integer iVal = new Integer(10); //Deprecated since Java 9
        Double dVal = new Double(2.3); //Deprecated since Java 9
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Kutulama için sarmalayan sınıfların valueOf metotları ctor yerine kullanılmalıdır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Integer iVal = Integer.valueOf(10); // Since Java 5
        Double dVal = Double.valueOf(2.3); // Java Java 5
        //...
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Integer sınıfının (aslında tüm tamsayı türlerine ilişkin sarmalayan sınıfların) ilişkin  olduğu temel tür parametreli
    valueOf metotları [-128, 127] aralağındaki değerleri bir önbellekte (cache) tutar. Böylelikle daha efektif bir çalışma
    sağlanır. Bunlar dışındaki değerler için önbellek kullanımı garanti değildir
    Dikkat: IntValue sınıfının kodlarını tekrar inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Integer ival1 = Integer.valueOf(10);
        Integer ival2 = Integer.valueOf(10);

        System.out.println(ival1 == ival2);

        Integer ival3 = Integer.valueOf(1000);
        Integer ival4 = Integer.valueOf(1000);

        System.out.println(ival3 == ival4);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Character sınıfının char parametreli valueOf metodu [0, 127] aralığındaki sıra numrarasına karakterleri önbellekte
    tutar. Bu karakterler aslında standart ASCII karakterleridir. Bunlar dışındaki değerler için önbellek kullanımı
    garanti değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Character cVal1 = Character.valueOf('C');
        Character cVal2 = Character.valueOf('C');

        System.out.println(cVal1 == cVal2);

        Character cVal3 = Character.valueOf('Ş');
        Character cVal4 = Character.valueOf('Ş');

        System.out.println(cVal3 == cVal4);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Boolean sınıfının boolean parametreli valueOf metodu true ve false değerlerinin sarmalandığı nesneleri yine bir
    önbellekte tutar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Boolean bVal1 = Boolean.valueOf(true);
        Boolean bVal2 = Boolean.valueOf(true);

        System.out.println(bVal1 == bVal2);

        Boolean bVal3 = Boolean.valueOf(false);
        Boolean bVal4 = Boolean.valueOf(false);

        System.out.println(bVal3 == bVal4);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Yöntemi nasıl olursa olsun tüm sarmalayan sınıflar valueOf metodu kullanılarak referans elde edilmesi
    "better space and time performence" açısından önemlidir. Bu sebeple Java 5'den itibaren ctor kullanımı
    tavsiye edilmemektedir.
---------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Number sınıfının xxxValue metotları nümerik sarmalayan sınıflar için ilişkin olduğu temel türe göre tür dönüştürme
    kurallarına uygun olarak çalışırlar. Yani örneğin int türden bir değerin short türüne explicit dönüştürülmesi
    durumunda elde edilen değer ile aynı değerin Integer sınıfı ile sarmalanmış nesnesine ilişkin shortValue metodunun
    döndürdüğü değerler aynıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int val = 100000;
        Integer iVal = Integer.valueOf(val);
        short a = (short)val;
        short b = iVal.shortValue();

        System.out.printf("a = %d%n", a);
        System.out.printf("b = %d%n", b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Number sınıfının xxxValue metotları nümerik sarmalayan sınıflar için ilişkin olduğu temel türe göre tür dönüştürme
    kurallarına uygun olarak çalışırlar. Yani örneğin int türden bir değerin short türüne explicit dönüştürülmesi
    durumunda elde edilen değer ile aynı değerin Integer sınıfı ile sarmalanmış nesnesine ilişkin shortValue metodunun
    döndürdüğü değerler aynıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Object obj = Integer.valueOf(10); // Kutulama (boxing)

        System.out.println(obj.getClass().getName());

        int val = ((Integer)obj).intValue(); //Kutuyu açma (unboxing)

        System.out.printf("val = %d%n", val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    RandomObjectGenerator uygulaması
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.randomgenerator.RandomObjectArrayGeneratorApp;

class App {
    public static void main(String [] args)
    {
        RandomObjectArrayGeneratorApp.run();
    }
}


package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;


public class RandomObjectArrayGeneratorApp {
    private RandomObjectArrayGeneratorApp()
    {
    }

    public static void run()
    {
        RandomObjectArrayGenerator rag = new RandomObjectArrayGenerator(5);

        rag.run();

        for (Object object : rag.getObjects()) {
            String typeName = object.getClass().getName();
            System.out.printf("Dinamik tür ismi:%s%n", typeName);

            if (object instanceof String) {
                String s = (String)object;

                System.out.printf("Yazı:%s%n", s);
                System.out.printf("Yazı:%s%n", s.toUpperCase());
            }
            else if (object instanceof Date) {
                Date date = (Date)object;

                System.out.println(date.toLongDateStringTR());
            }
            else if (object instanceof Time) {
                Time time = (Time) object;

                System.out.println(time.toLongTimeString());
            }
            else if (object instanceof Integer) {
                Integer ival = (Integer)object;

                int val = ival.intValue();
                System.out.printf("result = %d%n", val * val);
            }
            else if (object instanceof Character) {
                char ch = ((Character)object).charValue();

                System.out.printf("ch = %c%n", ch);
            }
            else if (object instanceof int[]){
                int [] a = (int[])object;

                ArrayUtil.display(2, a);
            }
        }
    }
}


package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.StringUtil;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;

import java.util.Random;

public class RandomObjectArrayGenerator {
    private final Random m_random;
    private final Object [] m_objects;

    private Object getRandomObject()
    {
        int n = m_random.nextInt(6);

        Object object;

        switch (n) {
            case 0:
                object = StringUtil.getRandomTextTR(m_random, m_random.nextInt(20) + 1);
                break;
            case 1:
                object = Date.of(m_random);
                break;
            case 2:
                object = Time.of(m_random);
                break;
            case 3:
                object = Integer.valueOf(m_random.nextInt(255) - 128);
                break;
            case 4:
                object = Character.valueOf((char)(m_random.nextInt(26) + 'A'));
                break;
            default:
                object = ArrayUtil.generateRandomArray(m_random, 10, 0, 100);

        }
        return object;
    }

    public RandomObjectArrayGenerator(int n)
    {
        m_random = new Random();
        m_objects = new Object[n];
    }

    public Object [] getObjects()
    {
        return m_objects;
    }

    public void run()
    {
        for (int i = 0; i < m_objects.length; ++i)
            m_objects[i] = getRandomObject();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Java 5 ile birlikte temel türlere ilişkin sarmalayan sınıf referanslarına ilgili türden bir değer doğrudan
    atanabilmektedir. Bu işlem aslında derleyici taradında aşağıdaki örnekte aıklanan kodun üretimesini sağlar. Yani
    programcı bu atamayı yaptığında derleyici uygun kodu üretir. Bu kavrama "otomatik kutulama (auto-boxing)" denir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Integer ival1 = 10; //auto-boxing: Integer.valueOf(10)
        Integer ival2 = 10; //auto-boxing: Integer.valueOf(10)

        System.out.println(ival1 == ival2);

        Double dVal = 2.3; //auto-boxing: Double.valueOf(2.3)
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Otomatik kutulma Object sınıfı için de geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Object oi = 10; //auto-boxing:Integer.valueOf(10);
        Object od = 3.4; //auto-boxing: Double.valueOf(3.4);

        System.out.println(oi.getClass().getName());
        System.out.println(od.getClass().getName());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki metot çağrılarında temel türden argümanlar için otomatik kutulama yapılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara"); //upcasting
        Sample.foo(10); //auto-boxing
        Sample.foo(true); //auto-boxing
        Sample.foo(new Random()); //upcasting
    }
}

class Sample {
    public static void foo(Object o)
    {
        System.out.println(o.getClass().getName());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Otomatik kutulama ilgili sarmalayan sınıf referansın sarmalayan sınıfa ilişkin temel türden atanmalıdır. Aksi
    durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Double dVal = 10; //error: Double dVal = Integer.valueOf(10);
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Java 5 ile birlikte sarmalayan sınıf referansı ilişkin olduğu temel türe doğrudan atanabilir. Bu durumda yine
    derleyici aşağıdaki gibi kod üretir. Bu işleme "otomatik kutu açma (auto-unboxing)" denir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Integer ival = 10; //auto-boxing: Integer.valueOf(10)
        int a = ival; //auto-unboxing: iVal.intValue();

        Double dVal = 2.3; //auto-boxing: Double.valueOf(2.3)
        double b = dVal; //auto-unboxing: dVal.doubleValue();

        System.out.printf("a = %d%n", a);
        System.out.printf("b = %f%n", b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Otomatik kutu açma tür dönüştürme operatörü kullanılarak aşağıdaki gibi Object türünden  dönüşüm yapılabilir. Yine
    derleyici aşağıdakine benzer kodlar üretir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Object oi = 10; //auto-boxing:Integer.valueOf(10);
        Object od = 3.4; //auto-boxing: Double.valueOf(3.4);
        int a = (int)oi; //auto-unboxing: ((Integer)oi).intValue();
        double b = (double)od; //auto-unboxing: ((Double)oi).doubleValue();

        System.out.println(oi.getClass().getName());
        System.out.println(od.getClass().getName());

        System.out.printf("a = %d%n", a);
        System.out.printf("b = %f%n", b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Otomatik kutu açma ugun türe yapılabilir. Aşağıdaki örnekte exception oluşur. Çünkü haksız dönüşüm vardır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int a = 10;
        Object o = a; //auto-boxing: Integer.valueOf(a);

        System.out.println(o.getClass().getName());

        double val = (double)o; //auto-unboxing: ((Double)o).doubleValue();

        System.out.printf("val = %f%n", val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problem aşağıdaki gibi çözülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int a = 10;
        Object o = a; //auto-boxing: Integer.valueOf(a);

        System.out.println(o.getClass().getName());

        double val = (int)o; //auto-unboxing: ((Integer)o).intValue();

        System.out.printf("val = %f%n", val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örtnekte int türüne otomatik kutu açılmış, elde edilen değer short türüne dönüştürülmüştür.
    Tür dönüştürme operatörünün sağdan sola öncelikli (right associative) olduğunu anımsayınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int a = 10;
        Object o = a; //auto-boxing: Integer.valueOf(a);

        System.out.println(o.getClass().getName());

        short val = (short)(int)o; //auto-unboxing: (short)(((Integer)o).intValue());

        System.out.printf("val = %d%n", val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    RandomObjectArrayGeneratorApp uygulaması artık sanki herşey Object'den türetişmiş gibi yazılmıştır. Şüphesiz
    temel türler için otomatik kutulama ve otomatik kutu açma sayesinde bu yapılabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.randomgenerator.RandomObjectArrayGeneratorApp;

class App {
    public static void main(String [] args)
    {
        RandomObjectArrayGeneratorApp.run();
    }
}

package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;

public class RandomObjectArrayGeneratorApp {
    private RandomObjectArrayGeneratorApp()
    {
    }

    public static void run()
    {
        RandomObjectArrayGenerator rag = new RandomObjectArrayGenerator(5);

        rag.run();

        for (Object object : rag.getObjects()) {
            String typeName = object.getClass().getName();
            System.out.printf("Dinamik tür ismi:%s%n", typeName);

            if (object instanceof String) {
                String s = (String)object;

                System.out.printf("Yazı:%s%n", s);
                System.out.printf("Yazı:%s%n", s.toUpperCase());
            }
            else if (object instanceof Date) {
                Date date = (Date)object;

                System.out.println(date.toLongDateStringTR());
            }
            else if (object instanceof Time) {
                Time time = (Time) object;

                System.out.println(time.toLongTimeString());
            }
            else if (object instanceof Integer) {
                int val = (int)object;

                System.out.printf("result = %d%n", val * val);
            }
            else if (object instanceof Character) {
                char ch = (char)object;

                System.out.printf("ch = %c%n", ch);
            }
            else if (object instanceof int[]){
                int [] a = (int[])object;

                ArrayUtil.display(2, a);
            }
        }
    }
}

package org.csystem.app.samples.randomgenerator;

import org.csystem.util.ArrayUtil;
import org.csystem.util.StringUtil;
import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;

import java.util.Random;

public class RandomObjectArrayGenerator {
    private final Random m_random;
    private final Object [] m_objects;

    private Object getRandomObject()
    {
        int n = m_random.nextInt(6);

        Object object;

        switch (n) {
            case 0:
                object = StringUtil.getRandomTextTR(m_random, m_random.nextInt(20) + 1);
                break;
            case 1:
                object = Date.of(m_random);
                break;
            case 2:
                object = Time.of(m_random);
                break;
            case 3:
                object = m_random.nextInt(255) - 128;
                break;
            case 4:
                object = (char)(m_random.nextInt(26) + 'A');
                break;
            default:
                object = ArrayUtil.generateRandomArray(m_random, 10, 0, 100);

        }
        return object;
    }

    public RandomObjectArrayGenerator(int n)
    {
        m_random = new Random();
        m_objects = new Object[n];
    }

    public Object [] getObjects()
    {
        return m_objects;
    }

    public void run()
    {
        for (int i = 0; i < m_objects.length; ++i)
            m_objects[i] = getRandomObject();
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    17.04.2021
    Sarmalayan sınıflar ile ilişkin oldukları türler kullanılarak yazılan kodlar benzer kodlar yazılabilmektedir.
    Aslında bu işlemler otomatik kutulama ve otomatik kutu açma işlemleri ile yapılabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        for (Integer i = 0; i < 10; ++i)
            System.out.printf("%d ", i);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sarmalayan sınflar immutable olduğundan aşağıdaki örnekte ++ operatörü aslında yeni bir nesne yaratılıp
    eski nesnenin kopartılmas biçiminde yapılmaktadır. Yani derleyici * ile belirtilen koda benzer bir kod üretir. Bu
    işlem de yine otomatik kutulama ve otomatik kutu açma ile kolayca yapılabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Integer i = 10;

        ++i; //*:i = i.intValue() + 1;

        System.out.println(i);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ++ operatörü ile nesenin içeriğinin değiştirilmediğinin bir ispatı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Integer i = 10;
        Integer temp = i;

        System.out.println(i == temp);

        ++i;

        System.out.println(i);

        System.out.println(i == temp);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    final olarak bildirilmiş bir sınıftan türetme yapılamaz. Yani bu sınıf türetmeye kapatılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A { //error
    //...
}

final class A {
    //...
}
/*----------------------------------------------------------------------------------------------------------------------
    final olarak bildirilmiş bir sınıf başka bir sınıftan türetilmiş olabilir. Zaten bir sınıf kod yazılarak hiçbir
    türetilmemişse Object sınıfından türetilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}


class B extends A { //error
    //...
}

final class A extends X {
    //...
}

class X {

}

/*----------------------------------------------------------------------------------------------------------------------
    final sınıf kavramı olmasaydı bir sınıfn türetmeye kapatmak için ctor'unun private yapılması gerekirdi. Bu durumda
    o sınıf türünden nesne yaratılması da gerekiyorsa static bir metot ile nesne edilmesi sağlanabilirdi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = A.getInstance();

        //...
    }
}

class B extends A { //error
    //...
}

class A extends X {
    private A()
    {}

    public static A getInstance()
    {
        return new A();
    }
}

class X {

}

/*----------------------------------------------------------------------------------------------------------------------
    ctor'u private olarak bildirilmiş bir sınıftan türetme yapılamayacağından bu tarz sınıfların final olarak
    bildirilmesi iyi bir tekniktir. Örneğin Math sınıfının tüm elemanları static olduğundan ctor'u private yapılmıştır.
    Yani Math sınfı türünden nesne yaratılamaz. Bu durumda Math sınıfı da final yapılmıştır
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Tüm elemanları static olan sınıflara Java'da "utility class" denir. Türkçe olarak algı kolaylığı
    açısından "mantıksal static sınıf" denebilir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	ArrayUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public final class ArrayUtil {
    private static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    private static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] > a[k])
                    swap(a, k, k + 1);
    }

    private static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }

            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    private static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] > max) {
                    max = a[k];
                    maxIndex = k;
                }

            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    private ArrayUtil()
    {
    }

    public static void bubbleSort(int [] a, boolean descending)
    {
        if (descending)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void display(int [] a)
    {
        display(1, a);
    }

    public static void display(int n, int [] a)
    {
        String fmt = String.format("%%0%dd ", n);

        for (int val : a)
            System.out.printf(fmt, val);

        System.out.println();
    }

    public static void display(int n, int [][] a)
    {
        for (int [] array : a)
            display(n, array);
    }

    public static void display(String [] str)
    {
        display('\n', str);
    }

    public static void display(char sep, String [] str)
    {
        for (String s : str)
            System.out.printf("%s%c", s, sep);
    }

    public static void drawHistogram(int [] data, int n, char ch)
    {
        int mavValue = max(data);

        for (int val : data) {
            int count = (int)Math.ceil((double)val * n / mavValue);

            while (count -- > 0)
                System.out.print(ch);

            System.out.println();
        }
    }

    public static void fillRandomArray(int [] a, int min, int max) //[min, max)
    {
        fillRandomArray(new Random(), a, min, max);
    }

    public static void fillRandomArray(Random r, int [] a, int min, int max) //[min, max)
    {
        for (int i = 0; i < a.length; ++i)
            a[i] = r.nextInt(max - min) + min;
    }

    public static int [] generateRandomArray(int n, int min, int max) //[min, max)
    {
        return generateRandomArray(new Random(), n, min, max);
    }

    public static int [] generateRandomArray(Random r, int n, int min, int max) //[min, max)
    {
        int [] a = new int[n];

        fillRandomArray(r, a, min, max);

        return a;
    }

    public static int [][] generateRandomMatrix(int row, int col, int min, int max)
    {
        return generateRandomMatrix(new Random(), row, col, min, max);
    }

    public static int [][] generateRandomMatrix(Random r, int row, int col, int min, int max)
    {
        int [][] m = new int[row][];

        for (int i = 0; i < row; ++i)
            m[i] = generateRandomArray(r, col, min, max);

        return m;
    }

    public static int [][] generateRandomSquareMatrix(int n, int min, int max)
    {
        return generateRandomSquareMatrix(new Random(), n, min, max);
    }

    public static int [][] generateRandomSquareMatrix(Random r, int n, int min, int max)
    {
        return generateRandomMatrix(r, n, n, min, max);
    }

    public static int [] getHistogramData(int [] a, int n) //[0, n]
    {
        int [] data = new int[n + 1];

        for (int val : a)
            ++data[val];

        return data;
    }

    public static boolean isMatrix(int [][] a)
    {
        for (int i = 1; i < a.length; ++i)
            if (a[i].length != a[0].length)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result < a[i])
                result = a[i];

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result > a[i])
                result = a[i];

        return result;
    }

    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void reverse(int [] a)
    {
        int halfLength = a.length / 2;

        for (int i = 0; i < halfLength; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] a)
    {
        int halfLength = a.length / 2;

        for (int i = 0; i < halfLength; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void selectionSort(int [] a, boolean descending)
    {
        if (descending)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int val : a)
            total += val;

        return total;
    }


    public static int sum(int [][] a)
    {
        int total = 0;

        for (int[] array : a)
            total += sum(array);

        return total;
    }

    public static int sumDiagonal(int [][] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i][i];

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(double [] a, int i, int k)
    {
        double temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp;

        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

    public static int [][] transpose(int [][] a)
    {
        int row = a.length;
        int col = a[0].length;
        int [][] t = new int[col][row];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                t[j][i] = a[i][j];

        return t;
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	NumberUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import static java.lang.Math.log10;
import static java.lang.Math.abs;
import static java.lang.Math.pow;

public final class NumberUtil {
    private static final String [] ONES = {"", "bir", "iki", "üç", "dört", "beş", "altı", "yedi", "sekiz", "dokuz"};
    private static final String [] TENS = {"", "on", "yirmi", "otuz", "kırk", "elli", "altmış", "yetmiş", "seksen", "doksan"};

    private static int [] getDigits(long val, int n)
    {
        int [] digits = new int[val == 0 ? 1 : (int)(log10(abs(val)) / n) + 1];
        int powOfTen = (int)Math.pow(10, n);

        for (int i = digits.length - 1; i >= 0; digits[i--] = (int)(val % powOfTen), val /= powOfTen)
            ;

        return digits;
    }

    private static String numberToText3DigitsTR(int val)
    {
        if (val == 0)
            return "sıfır";

        String str = val < 0 ? "eksi" : "";
        val = Math.abs(val);

        int a, b, c;

        a = val / 100;
        b = val / 10 % 10;
        c = val % 10;

        if (a != 0) {
            if (a != 1)
                str += ONES[a];
            str += "yüz";
        }
        if (b != 0)
            str += TENS[b];

        if (c != 0)
            str += ONES[c];

        return str;
    }

    private NumberUtil()
    {
    }

    public static int countDigits(long val)
    {
        return val == 0 ? 1 : (int)log10(abs(val)) + 1;
    }

    public static void displayCollatz(int n)
    {
        if (n <= 0) {
            System.out.println("Geçersiz değer");
            return;
        }

        for (;;) {
            System.out.println(n);

            if (n == 1)
                break;

            if (n % 2 == 0)
                n /= 2;
            else
                n = 3 * n + 1;
        }
    }

    public static long factorial(int n)
    {
        long result = 1L;

        for (int i = 2; i <= n; ++i)
            result *= i;

        return result;
    }

    public static int getDigitalRoot(int val)
    {
        int root = abs(val);

        while (root > 9)
            root = sumDigits(root);

        return root;
    }

    public static int [] getDigits(long val)
    {
        return getDigits(val, 1);
    }

    public static int [] getDigitsInThrees(long val)
    {
        return getDigits(val, 3);
    }

    public static int [] getDigitsInTwos(long val)
    {
        return getDigits(val, 2);
    }

    public static int getDigitsFactorialSum(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += factorial(val % 10);
            val /= 10;
        }

        return sum;
    }

    public static int getDigitsPowSum(int val)
    {
        int n = countDigits(val);
        int sum = 0;

        while (val != 0) {
            sum += pow(val % 10, n);
            val /= 10;
        }

        return sum;
    }

    public static int getFibonacciNumber(int n)
    {
        if (n <= 0)
            return -1;

        if (n <= 2)
            return n - 1;

        int prev1 = 1, prev2 = 0, val = 0;

        for (int i = 2; i < n; ++i) {
            val = prev1 + prev2;
            prev2 = prev1;
            prev1 = val;
        }

        return val;
    }

    public static int getIndexOfPrimeNumber(int n)
    {
        int index = 1;
        int val = 2;

        for (;;) {
            if (val == n)
                return index;

            if (isPrime(val))
                ++index;

            ++val;
        }
    }

    public static int getNextFibonacciNumber(int val)
    {
        if (val < 0)
            return 0;

        int prev1 = 1, prev2 = 0, result;

        for (;;) {
            result = prev1 + prev2;

            if (result > val)
                return result;

            prev2 = prev1;
            prev1 = result;
        }
    }

    public static int getPrime(int n)
    {
        if (n <= 0)
            return -1;

        int count = 0;
        int val = 2;

        for (;;) {
            if (isPrime(val))
                ++count;

            if (count == n)
                return val;

            ++val;
        }
    }

    public static boolean isArmstrong(int val)
    {
        return val >= 0 && getDigitsPowSum(val) == val;
    }

    public static boolean isDecimalHarshad(int val)
    {
        if (val < 0)
            return false;

        return val % sumDigits(val) == 0;
    }

    public static boolean isEven(int val)
    {
        return val % 2 == 0;
    }

    public static boolean isFactorian(int val)
    {
        if (val <= 0)
            return false;

        return getDigitsFactorialSum(val) == val;
    }

    public static boolean isHardyRamanujan(int val)
    {
        if (val <= 0)
            return false;

        int count = 0;

        for (int x = 1; x * x * x < val;) {
            for (int y = x + 1; x * x * x + y * y * y <= val; ++y)  {
                if (x * x * x + y * y * y == val) {
                    ++count;
                    ++x;
                }
            }
            ++x;
        }

        return count >= 2;
    }

    public static boolean isOdd(int val)
    {
        return !isEven(val);
    }

    public static boolean isPalindrome(int val)
    {
        return reversed(val) == val;
    }

    public static boolean isPrime(int val)
    {
        if (val <= 1)
            return false;

        if (val % 2 == 0)
            return val == 2;

        if (val % 3 == 0)
            return val == 3;

        if (val % 5 == 0)
            return val == 5;

        if (val % 7 == 0)
            return val == 7;

        int sqrtVal = (int)Math.sqrt(val);

        for (int i = 11; i <= sqrtVal; i += 2)
            if (val % i == 0)
                return false;

        return true;
    }

    public static boolean isPrimeX(int val)
    {
        do {
            if (!isPrime(val))
                return false;
            val = sumDigits(val);
        } while (val > 9);

        return isPrime(val);
    }

    public static boolean isSuperPrime(int val)
    {
        return isPrime(val) && isPrime(getIndexOfPrimeNumber(val));
    }

    public static int max(int a, int b, int c)
    {
        return Math.max(Math.max(a, b),  c);
    }

    public static int mid(int a, int b, int c)
    {
        if (a <= b && b <= c || c <= b && b <= a)
            return b;

        if (b <= a && a <= c || c <= a && a <= b)
            return a;

        return c;
    }

    public static int min(int a, int b, int c)
    {
        return Math.min(Math.min(a, b),  c);
    }

    public static String numberToText(long val)
    {
        int [] digits = getDigitsInThrees(val);

        String result = "";

        //TODO:
        for (int digit : digits)
            result += numberToText3DigitsTR(digit) + " ";

        return result;
    }

    public static int reversed(int val)
    {
        int reverse = 0;

        while (val != 0) {
            reverse = reverse * 10 + val % 10;
            val /= 10;
        }

        return reverse;
    }

    public static int sumDigits(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += val % 10;
            val /= 10;
        }

        return Math.abs(sum);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;
import static java.lang.Character.isWhitespace;
import static java.lang.Character.toLowerCase;
import static java.lang.Character.toUpperCase;
import static java.lang.Character.isLetter;

public final class StringUtil {
    private static final String ALPHABET_LOWER_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
    private static final String ALPHABET_LOWER_EN = "abcdefghijklmnopqrstuvwxyz";
    private static final String ALPHABET_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ" + ALPHABET_LOWER_TR;
    private static final String ALPHABET_EN = "ABCDEFGHIJKLMNOPQRSTUWXVYZ" + ALPHABET_LOWER_EN;

    private StringUtil()
    {
    }

    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static String changeCase(String s)
    {
        char [] c = new char[s.length()];

        for (int i = 0; i < c.length; ++i) {
            char ch = s.charAt(i);

            c[i] = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);
        }

        return String.valueOf(c);
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        int length = sourceText.length();
        char [] c = new char[n];

        for (int i = 0; i < n; ++i)
            c[i] = sourceText.charAt(r.nextInt(length));

        return String.valueOf(c);
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, ALPHABET_TR);
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String [] getRandomTextsTR(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextTR(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, ALPHABET_EN);
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static String [] getRandomTextsEN(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextEN(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static boolean isJavaIdentifier(String s)
    {
        if (s.equals("_"))
            return false; //Java 9 ve sonrası için kdeğişken kontrolü

        if (s.isBlank())
            return false;

        char ch = s.charAt(0);

        if (!Character.isJavaIdentifierStart(ch))
            return false;

        int length = s.length();

        for (int i = 1; i < length; ++i)
            if (!Character.isJavaIdentifierPart(s.charAt(i)))
                return false;

        return true;
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), ALPHABET_LOWER_EN);
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), ALPHABET_LOWER_TR);
    }

    public static String join(String [] str, char sep)
    {
        return join(str, 0, sep);
    }

    public static String join(String [] str, int startIndex, char sep)
    {
        return join(str, startIndex, sep + "");
    }

    public static String join(String [] str, int startIndex, String sep)
    {
        String result = "";

        int length = str.length;

        for (int i = startIndex; i < length; ++i) {
            if (!result.isEmpty())
                result += sep;

            result += str[i];
        }

        return result;
    }

    public static String join(String [] str, String sep)
    {
       return join(str, 0, sep);
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        char [] c = s.toCharArray();

        ArrayUtil.reverse(c);

        return String.valueOf(c);
    }

    public static String squeeze(String s1, String s2)
    {
        String str = "";
        int length = s1.length();

        for (int i = 0; i < length; ++i) {
            char ch = s1.charAt(i);
            if (!s2.contains(ch + ""))
                str += ch;
        }

        return str;
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }

    public static String wrapWith(String str, char ch)
    {
        return wrapWith(str, ch, false);
    }

    public static String wrapWith(String str, char ch, boolean trim)
    {
        return wrapWith(str, ch, ch, trim);
    }

    public static String wrapWith(String str, char chBegin, char chEnd)
    {
        return wrapWith(str, chBegin, chEnd, false);
    }

    public static String wrapWith(String str, char chBegin, char chEnd, boolean trim)
    {
        return String.format("%c%s%c", chBegin, trim ? str.trim() : str, chEnd);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Immutable sınıflardan (tabii ki her zaman değil) türetme anşamsız olabileceğinden sınıf final olabilir. Örneğin
    sarmalayan sınıflar ve String sınıfı final olarak bildirilmiştir. Burada temel nokta immutable olması değil, ilgili
    sınıfa eklenti (extension) yapılmasının anlamsız olması durumudur. Java'nın standart kütüphanesinde immutable olup
    türetmeye açık sınıflar da vardır. Tersine immutable olmayan ama türetmeye kapalı sınıflar da vardır.
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class IntValue {
    private static final IntValue [] CACHE = new IntValue[256];
    private final int m_val;

    private IntValue(int val)
    {
        m_val = val;
    }

    public static final IntValue ONE = of(1);
    public static final IntValue ZERO = of(0);
    public static final IntValue TEN = of(10);

    public static IntValue of(int val)
    {
        if (val < -128 || val > 127)
            return new IntValue(val);

        if (CACHE[val + 128] == null)
            CACHE[val + 128] = new IntValue(val);

        return CACHE[val + 128];
    }

    public int getVal()
    {
        return m_val;
    }

    public int compareTo(IntValue other)
    {
        return m_val - other.m_val;
    }

    public IntValue add(int val)
    {
        return of(m_val + val);
    }

    public IntValue add(IntValue other)
    {
        return add(other.m_val);
    }

    public IntValue subtract(int val)
    {
        return add(-val);
    }

    public IntValue subtract(IntValue other)
    {
        return subtract(other.m_val);
    }

    public IntValue multiply(int val)
    {
        return of(m_val * val);
    }

    public IntValue multiply(IntValue other)
    {
        return multiply(other.m_val);
    }

    public IntValue increment()
    {
        return add(1);
    }

    public IntValue decrement()
    {
        return subtract(1);
    }

    public String toString()
    {
        return m_val + "";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Heap'de tahsis edilen nesnelere dinamik olarak tahsis edilen (dinamik ömürlü) nesneler denir. Bu nesnelerin
	yok edilmesi çöp toplayıcı (garbage collector) denilen ve arka planda çalışan bir program tarafından yapılır.
	Çöp toplayıcı artık kullanılmayan (garbage collected, eligible) yani çöp olan nesneleri yok eder. Burada 3(üç)
	tane temel soru sorulabilir:
	1. Programcı bir nesneyi yok edebilir mi? (HAYIR)
	2. Çöp olan (garbage collected) bir nesne çöp olur olmaz yok edilir mi, yani çöp toplayıcı program hemen devreye
	girer mi? (GİRMEYEBİLİR)
	3. Çöp toplayıcı yok edilmesi gereken bir nesneyi nasıl anlar?

	Cevap 1: Java' da programcı bir nesneyi yok edemez. Yani tahsis edilmiş bir alanı geri bırakamaz (free, delete). Programcı
	kod akışı içerisinde bir nesneyi yok edilebilir (garbage collected) duruma getirebilir.

	Cevap 2: Çöp toplayıcı programın ne zaman devreye gireceği standartlarda belirtilmemiştir. Bu çöp toplayıcı programla
	beraber JVM ve JRE yazanlara bırakılmıştır (implementation dependent). Hemen devreye gireceği garanti değildir.
	Programcı bu bilinçle ve etkinliğine güvenerek kod yazar.

	Cevap 3: Bir nesnenin yok edilebilir yani çöp durumuna gelmesi o nesneyi gösteren hiçbir referansın kalmaması
	demektir. Yani nesnenin adresinin hiçbir referans tarafından tutulmuyor duruma gelmesidir. Bir nesnenin adresinin
	hangi referanslar tarafından tutulduğu ve özellikle kaç referans tarafından tutulduğunun takibi çeşitli algoritmalar
	kullanılarak yapılmaktadır. Bu algoritmanın ne olacağı da standtartlarda belirtilmemiştir (implementation dependent).
	Biz burada referans sayma (reference counting) algoritması kullanılıyor varsayımıyla açıklama yapacağız. Referans
	sayacı yönteminde her yaratılan nesne için bir sayaç tutulur (bu sayaç genelde nesne içerisinde tutulur). Bu yöntemde
	nesnenin adresi yeni bir referansa atandığında o nesne için sayaç 1(bir) artırılır. Nesne bir referanstan
	kopartıldığında sayaç 1(bir) azaltılır. Sayacı sıfır olan yani hiç bir referans tarafından gösterilmeyen bir nesne
	çöp durumuna gelmiş olur. Şüphesiz bir program sonlandığında tüm nesneler yok edilir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşğıdaki örnekte referans sayacı yöntemi kullanıldığı durumda nesneyi gösteren referansların takibi örneklenmiştir.
    rc: reference counter
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s;

        s = new Sample(); //rc1:1

        {
            Sample k;

            k = s; //rc1:2
            Mample.foo(s); //rc1:3 -> rc1:4
            //rc1:3 -> rc1:2
        } //rc1:1

        s = new Sample(); //rc1:0 (garbage collected), rc2:1
        //...
    }
}

class Mample {
    public static void foo(Sample s)
    {
        Sample k;

        //...

        k = s;
        //...
    }
}
class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Programcı isterse çöp toplayıcı programın devreye girmesini sağlayabilir. Bunun için System sınıfının gc isimli metodu
	veya Runtime sınıfının gc isimli metodu çağrılabilir. Ancak bu çoğunlukla yapılmaması gereken bir durumdur. Programcı
	çöp toplayıcı programın devre girmesi konusundaki etkin çalışmaya güvenmelidir. Çünkü çöp toplayıcı programın gereksiz
	yere arka planda çalışması da uygulamayı göreceli yavaşlatabilir
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s;

        s = new Sample(); //rc1:1

        {
            Sample k;

            k = s; //rc1:2
            Mample.foo(s); //rc1:3 -> rc1:4
            //rc1:3 -> rc1:2
        } //rc1:1

        s = new Sample(); //rc1:0 (garbage collected), rc2:1
        //...
        System.gc(); // ~ Runtime.getRuntime().gc();
        //...
    }
}

class Mample {
    public static void foo(Sample s)
    {
        Sample k;

        //...

        k = s;
        //...
    }
}
class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Arakod düzeyinde non-static metot kavramı yoktur. Aslında aşağı seviyede böyle bir kavram yoktur. Bundan dolayı
    derleyici non-static metotları adeta static metotlar biçiminde arakoda yazar. Bunu non-static metoda ait olduğu
    sınıf türünden ekstra bir referans parametresi ekleyerek yapar. Bu parametrenin ilk parametre ya da son parametre
    ya da arada bir parametre olup olmadığının önemi yoktur. non-static bir metodun çağrısı da o metot çağrılırken kullanılan
    referansın arakoddaki karşılığı olan static metoda argüman olarak geçilmesiyle yapılır. Aşağıdaki örnekte
    non-static bir metodun bildirimi ve çağrılmasının arakoddaki temsili karşılıkları gösterilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.setX(10);

        //Yukarıdaki çağrının arakoddaki temsili karşılığı
        Sample.setX(s, 10);

        //...

        s.display();

        //Yukarıdaki çağrının arakoddaki temsili karşılığı
        Sample.display(s);
    }
}

class Sample {
    private int m_x;

    public void setX(int x)
    {
        //...
        m_x = x;
    }

    //setX non-static metodunun arakoddaki temsili karşılığı
    public static void setX(Sample s, int x)
    {
        //...
        s.m_x = x;
    }

    public void display()
    {
        System.out.printf("value:%d%n", m_x);
    }

    //display non-static metodunun arakoddaki temsili karşılığı
    public static void display(Sample s)
    {
        System.out.printf("value:%d%n", s.m_x);
    }

    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    non-static metotlara gizlice geçirilen adrese metot bildiriminde "this referansı" ile erişilebilir. non-static bir
    metot içerisinde this referansı o metodu çağıran referans yani arakoddaki static metoda geçilen argümana karşılık
    gelir. this referansının türü, hangi sınıf içerisinde kullanılmışsa o türdendir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.setX(10);

        s.display();
    }
}

class Sample {
    private int m_x;

    public void setX(int x)
    {
        //...
        this.m_x = x;
    }

    public void display()
    {
        System.out.printf("value:%d%n", this.m_x);
    }

    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    this referansı sabit kabul edilir. Yani this referansına atama yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.setX(10);

        s.display();
    }
}

class Sample {
    private int m_x;

    public void setX(int x)
    {
        //...
        this.m_x = x;
    }

    public void display()
    {
        this = new Sample(); //error:
        System.out.printf("value:%d%n", this.m_x);
    }

    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    static metotlara this geçirilmez. Yani static metotlar içerisinde this referansı kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
class Sample {
    private static int ms_x;
    public static void foo(int x)
    {
        this.ms_x = x; //error
    }
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Biz programcı olarak veri elemanları için this referansını gerekmedikçe kullanmayacağız. Ancak metot çağrılarında
    okunabilirlik açısından (ifadeyi karmaşık hale getirmesi durumları hariç) kullanmayı tercih edeceğiz. Çünkü
    non-static bir metodu this ile çağırmak static metotların okunabiliğini artırır. Bu kurala uyarak yazılmış bir
    kod içerisinde this ile çağrılmamış bir metodun static olduğu kolayca anlaşılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.setX(10);

        s.display();
    }
}

class Sample {
    private int m_x;

    private static String getText()
    {
        return "display";
    }
    public void setX(int x)
    {
        //...
        m_x = x;
    }

    public void display()
    {
        System.out.println(getText());
        System.out.println(this.toString());
    }

    public String toString()
    {
        return String.format("value:%d", m_x);
    }
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Bazı programcılar sınıfların veri elemanlarının isimlendirmesinde önek ya da sonek kullanmazlar. Bilindiği gibi
    biz sınıfın private veri elemanlarını m_, static ise ms_ önekleri ile isimlendiriyoruz. Ancak sınıfın veri elemanları
    public ise biz de bir önek kullanmıyoruz. Böylesi bir durumda bir metodun parametresi ile veri elemanı aynı isimde
    yapıldığında artık veri elemanına doğrudan erişilemez. Bu şekilde tasarımda this referansı ile bu işlem yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.*;

public class Point {
	public int x;
	public int y;

	public Point()
	{
	}

	public Point(int x)
	{
		this.x = x;
	}

	public Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(int x, int y)
	{
		return sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
	}

	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("{x : %d, y : %d}", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math;

public class Complex {
	private static Complex add(double a1, double b1, double a2, double b2)
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	private static Complex subtract(double a1, double b1, double a2, double b2)
	{
		return add(a1, b1, -a2, -b2);
	}

	public double re;
	public double im;

	public Complex()
	{
	}

	public Complex(double re)
	{
		this.re = re;
	}

	public Complex(double re, double im)
	{
		this.re = re;
		this.im = im;
	}

	public double getNorm()
	{
		return Math.sqrt(re * re + im * im);
	}

	public Complex getConjugate()
	{
		return new Complex(re, -im);
	}

	//add methods
	public Complex add(Complex other)
	{
		return add(re, im, other.re, other.im);
	}

	public Complex add(double val)
	{
		return add(re, im, val, 0);
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.re, z.im);
	}

	//subtract methods
	public Complex subtract(Complex other)
	{
		return subtract(re, im, other.re, other.im);
	}

	public Complex subtract(double val)
	{
		return subtract(re, im, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.re, z.im);
	}

	public String toString()
	{
		return String.format("|%.2f + %.2f * i| = %f", re, im, getNorm());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki durumun benzeri static veri elemanları için de oluşturulabilir. Bu durumda niteliklendirmek için
    sınıf ismi kullanılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.setX(10);

        System.out.printf("Sample.x = %d%n", Sample.x);
    }
}

class Sample {
    public static int x;

    public static void setX(int x)
    {
        Sample.x = x;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın metotlarının aynı nesnenin referansı üzerinden zincir biçiminde aşağıdaki gibi çağrılabilmesi için
    implementasyonda this referansı kullanılmalıdır (fluent pattern)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.math.MutableIntValue;

class App {
    public static void main(String [] args)
    {
        MutableIntValue s = new MutableIntValue();

        int result = s.setVal(10)
                .multiply(2)
                .subtract(3)
                .multiply(3)
                .add(20)
                .getVal();

        System.out.println(result);
    }
}

package org.csystem.util.math;

public class MutableIntValue {
    private int m_val;

    public MutableIntValue()
    {
    }

    public MutableIntValue(int val)
    {
        m_val = val;
    }

    public int getVal()
    {
        return m_val;
    }

    public MutableIntValue setVal(int val)
    {
        //...
        m_val = val;

        return this;
    }

    public MutableIntValue add(int val)
    {
        m_val += val;

        return this;
    }

    public MutableIntValue subtract(int val)
    {
        this.add(-val);

        return this;
    }

    public MutableIntValue multiply(int val)
    {
        m_val *= val;

        return this;
    }

    public MutableIntValue divide(int val)
    {
        m_val /= val;

        return this;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Circle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.PI;

public class Circle {
    private double m_r;

    public Circle()
    {
    }

    public Circle(double r)
    {
        this.setRadius(r);
    }

    public double getRadius()
    {
        return m_r;
    }

    public void setRadius(double r)
    {
        m_r = Math.abs(r);
    }

    public double getArea()
    {
        return PI * m_r * m_r;
    }

    public double getCircumference()
    {
        return 2 * PI * m_r;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	AnalyticalCircle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

public class AnalyticalCircle extends Circle {
    private final Point m_center;

    public AnalyticalCircle()
    {
        this(0);
    }

    public AnalyticalCircle(Point center)
    {
        this(0, center);
    }

    public AnalyticalCircle(double r, Point center)
    {
        this(r, center.x, center.y);
    }

    public AnalyticalCircle(double r)
    {
        this(r, 0, 0);
    }

    public AnalyticalCircle(int x, int y)
    {
        this(0, x, y);
    }

    public AnalyticalCircle(double r, int x, int y) //primary ctor
    {
        super(r);
        m_center = new Point(x, y);
    }

    public int getX() {return m_center.x;}
    public int getY() {return m_center.y;}

    public Point getCenter()
    {
        return new Point(m_center.x, m_center.y);
    }

    public void setX(int x)
    {
        m_center.x = x;
    }

    public void setY(int y)
    {
        m_center.y = y;
    }

    public void set(int x, int y)
    {
        this.setX(x);
        this.setY(y);
    }

    public void set(Point center)
    {
        this.set(center.x, center.y);
    }

    public void offset(int dxy)
    {
        this.offset(dxy, dxy);
    }

    public void offset(int dx, int dy)
    {
        m_center.offset(dx, dy);
    }

    public double centerDistance(AnalyticalCircle analyticalCircle)
    {
        return m_center.distance(analyticalCircle.m_center);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.*;

public class Point {
	public int x;
	public int y;

	public Point()
	{
	}

	public Point(int x)
	{
		this.x = x;
	}

	public Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public double distance()
	{
		return this.distance(0, 0);
	}

	public double distance(Point other)
	{
		return this.distance(other.x, other.y);
	}

	public double distance(int x, int y)
	{
		return sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
	}

	public void offset(int dxy)
	{
		this.offset(dxy, dxy);
	}

	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("{x : %d, y : %d}", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Java'da kullanılmayan bir byte'lık bölgenin (hole) adresini temsil eden (null address) null isimli bir anahtar sözcük
    bulunur. null bir sabittir. null değeri bir referansa atanabilir. Bir referansa null atandığında o referansın
    içerisinde bir adres vardır. Ancak bu adres kullanılmadığı için bir nesnenin adresi olamaz.

    Anahtar Not: null adres belleğin sıfır numaralı bölgesinin adresidir. Yani kabaca adresin sayısayl değeri sıfırdır.
    Java programcısı açısından sıfır değerinin önemi yoktur. Zaten null değeri (null reference) bunun için vardır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int a = null; //error
        Sample s = null;
        Mample m;

        m = null;

        String str = null;

        //...

    }
}

class Sample {
    //...
}


enum Mample {
    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Bir referansın default değeri null'dır. Aşağıdaki Singleton kalıbının bir implementasyonunu hatırlayınız
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();

        System.out.println(s1 == s2);

        s1.setX(20);

        System.out.println(s2.getX());
    }
}

class Singleton {
    private static Singleton ms_instance;
    private int m_x;

    private Singleton()
    {
    }

    public static Singleton getInstance()
    {
        if (ms_instance == null)
            ms_instance = new Singleton();

        return ms_instance;
    }

    public int getX()
    {
        return m_x;
    }

    public void setX(int x)
    {
        //...
        m_x = x;
    }

    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    Bir referansın null olması durumunda o referansın ilişkin olduğu türün elemanlarına erişim durumunda exception
    oluşur
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample s = null;

        s.foo();
    }
}

class Sample {
    public void foo()
    {
        //...
    }
}


/*--------------------------------------------------------------------------------------------------------------------
    null referans bşr referans değişkeni nesneden kopartmak için de kullanılabilir. Bir referansa null atanması
    o referansın gösterdiği nesnenin "garbage collected" olduğu anlamına gelmez. Aşağıdaki örneği inceleyiniz
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample s, k;

        s = new Sample();
        s.x = 10;
        k = s;

        s = null;

        System.out.println(k.x);
        //...
    }
}

class Sample {
    public int x;
}

/*--------------------------------------------------------------------------------------------------------------------
    null referans aşağıdaki örnekteki gibi deleyecinin "değer atanmamış bir değişkeni kullanıyor olabilirsin"
    şeklindeki error'unu engellemek için kullanılabilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        if (val < 1 || val > 3) {
            System.out.println("Geçersiz değer");
            System.exit(-1);
        }

        IntUnit unit = null;

        switch (val) {
            case 1:
                unit = new IntUnit(67);
                break;
            case 2:
                unit = new IntUnit(37);
                break;
            case 3:
                unit = new IntUnit(34);
                break;
        }

        System.out.printf("Value:%d%n", unit.getVal());
    }
}

class IntUnit {
    private final int m_val;

    public IntUnit()
    {
        this(0);
    }
    public IntUnit(int val)
    {
        m_val = val;
    }

    public int getVal()
    {
        return m_val;
    }

    //...
}

/*--------------------------------------------------------------------------------------------------------------------
    null referans bir metodun geri değerinin referans olması durumunda kontrol amaçlı kullanılabilir
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int n = Integer.parseInt(kb.nextLine());

            if (n == 0)
                break;

            int [] a = Util.generateRandomArray(r, n, 1, 100);

            if (a == null) {
                System.out.println("Geçersiz değer");
                continue;
            }

            ArrayUtil.display(2, a);
        }
    }
}

class Util {
    public static int [] generateRandomArray(Random r, int n, int min, int max) //[min, max)
    {
        if (n <= 0 || min >= max)
            return null;

        int [] a = new int[n];

        for (int i = 0; i < n; ++i)
            a[i] = r.nextInt(max - min) + min;

        return a;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    18.04.2021
    Algoritma bir problemin çözümüne ulaştıran doğru adımlara denir.
    Algoritmaların anlatımında belli bir formal yöntem yoktur. Genel olarak sahte kodlar (pseudo codes) kullanılarak
    algoritmalar açıklanır. Algoritmalar genel olarak dilden bağımsızdır. Ancak ince noktalara gelindiğinde
    algorimalar da dile bağımlı hale gelebilir. Örneğin, bir dilde belli bir işi daha kolay yapan deyimler olabilir.
    Bu durumda algoritma o deyimlerle gerçekleştirilebilir.

    Bir algoritmanın işleyişinin masaya yatırılıp incelenmesine "algoritma" analizi denir. Bu analiz genel olarak
    matematiksel yöntemlerle yapılır. İki algoritmanın karşılaştırılabilmesi için kullanılan ölçüye "algoritmanın
    karmaşıklığı" denir. Algoritmanın karmaşıklığı için iki temel ölçüt vardır: Hız (speed), kaynak kullanımı (resource usage)
    Burada baskın ölçüt hızdır. Yani daha çok algoritmalar hızlarına göre karşılaştırılır. Ancak bazı durumlar da (bu durumlar
    hıza göre az olsa da kritik durumlardır) kaynak kullanımı da gözönüne alınabilir. Şüphesiz iki ölçütün de en iyi olduğu
    durum her zaman mümkün olmaz.
    Örneğin aşağıdaki gibi yazılmış en büyük sayıyı bulma algoritması için:
    int [] a = {...};
    int max;
    int n;

    n = a.length;
    max = a[0];
    for (int i = 1; i < n; ++i)
        if (max < a[i])
            max = a[i];

    Burada toplam işlemin sayısı max = a[i] işlemine bağlıdır. Bu algoritmada dizinin elemanları bilinmeden bu anlaşılamaz.
    İşte algoritma analizinde işlemlerin sayısını hesaplarken üç durum dikkate alınabilmektedir:

    1. Ortalama durum (average case condition)
    2. En kötü durum (worst case condition)
    3. En iyi durum (best case condition)

    En kötü durum olabileceklerin en kötüsüdür. Yukarıdaki örnekte en kötü durumda max = a[i] işlemi "n - 1" kez yapılır.
    Ortalama durum tüm olasılıkların ortalamasını temsil eder. Yukarıdaki örnekte ortalama max = a[i] işlemi "(n - 1) / 2"
    kez yapılmaktadır. En iyi durum olabileceklerin en iyisini temsil eder. Yani max = a[i] işlemi hiç yapılmaz.
    Algoritma analizinde en iyi durumun çok yararı yoktur. Çünkü aşırı iyimserlik programlamada çok değerli değildir.
    En kötü durum senaryosu önemlidir. Çünkü bazı durumlarda en kötü duruma hazırlıklı olmak gerekebilir. En önemli durum
    ortalama durumdur. Ortalama durum algoritmanın karakterini en iyi belirten durumdur. Genellikle algoritma ele alınırken
    hem ortalama durum hem de en kütü durum analizi yapılır.

    Algoritmalarda işlem sayısına ilişkin analizler çok kolay değildir. Özellikle ortalama durumu hesaplamak bazen çok karmaşık
    olabilmektedir. Algoritmaları pratik bakımdan kıyaslamak için asimtotik notasyonlardan yararlanılmaktadır. Bu notasyonların
    en yaygın kullanılanı "Big O" notasyondur. Bu notasyonda belli karakterdeki algoritmalar aynı kategoride kabul edilir.
    Eğer algoritma birden fazla kategoriye sahipse en kötü duruma ilişkin kategori gerçek kategorisini belirtir.

    Algoritmanın karmaşıklığının Big O notasyonu ile iyiden kötüye doğru ketegorileri şunlardır:
    - Polinomsal (polynomial) karmaşıklıklar
    O(1)        -> sabit karmaşıklık: döngü yok. Örneğin:üçgenin alanının bulunması, dizinin bir elemanına erişim
    O(logn)     -> logaritmik karmaşıklık (2 tabanında): Tek bir döngü var. Her adımda dönme sayısı yarı yarıya azalıyor. Örnek: binary search
    O(n)        -> doğrusal karmaşıklık: Tek döngü. Örneğin: Bir dizinin elemanları toplamının bulunması.
    O(n * logn) -> nlogn karmaşıklık: İçiçe iki döngü var, birisinde her adımda dönme sayısı yarı yarıya azalıyor. Örneğin: quick sort algoritması
    O(n ^ 2)    -> karesel karmaşıklık: İçiçe iki döngü var. Örneğin: Bir matrisin elemanları toplamının bulunması
    O(n ^ 3)    -> küpsel karmaşıklık: İçiçe üç döngü var. Örneğin: Bir kübün üzerindeki noktaların toplamının bulunması, matrislerin çarpımı
    ...
    O(n ^ k)    -> k-sal karmaşıklık (k sabit): İçiçe k tane döngü var

    - Polinomsal olmayan (non-polynomial) karmaşıklıklar
    O(k ^ n)    -> Üstel karmaşıklık (k sabit): Örneğin: N elemanlı bir kümenin alt kümelerinin bulunması
    O(n!)       -> Faktöriyel karmaşıklık. Örneğin: gezgin satıcı problemi

    Bir algoritma çoğu zaman herhangi bir karmaşıklıktayken bazı zamanlar (bu az olmalıdır) üst bir karmaşıklıkta
    çalışıyorsa, bu tarz karmaşıklıklara amortize edilmiş (amortized) karmaşıklıklar denir. Örneğin, bir algoritma
    çogu zaman O(1) karmaşıklıkta iken bazı zamanlar O(n) karmaşıklıkta çalışıyor ise amortize edilmiş sabit zamanlı
    (amortized constant time) karmaşıklık denir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte a dizisinin elemanlarını da içeren 10 elemanlı yeni bir dizi elde edilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        int [] a = {1, 2, 3, 4, 5};
        int [] b;

        b = ArrayUtil.copyOf(a, 10);

        ArrayUtil.display(a);
        ArrayUtil.display(b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte a dizisinin eski diziden koparılıp yeni bir diziyi görmesi sağlandığından mantıksal olarak
	büyütülmüştür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

class App {
    public static void main(String[] args)
    {
        int [] a = {1, 2, 3, 4, 5};

        a = ArrayUtil.copyOf(a, 10);

        ArrayUtil.display(a);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Dinamik büyüyen dizi (dynamic array) veri yapıları diziyi eklenen eleman sayısı kadar büyütmez. Dizinin büyütülmesi
    gerektiği durumda büyütme işlemini biraz fazlaca yapar. İşte bu tarz veri yapılarında dizinin uzunluğuna
    capacity değeri denir. Ancak dizide mantıksal tutulan eleman sayısına size denir. size hiç bir zaman capacity
    değerinden büyük olamaz. Capacity değeri size değerinden büyük veya size değerine eşit olabilir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte yukarıda anlatılan capacity kavramı kullanılarak kod yazılmıştır. Bu durumda örnekte algoritma
    "amortize edilmiş sabit zamanlı (amortized constant time)" olarak çalışmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.devices.StoreDevicesToArrayApp;

class App {
    public static void main(String[] args)
    {
        StoreDevicesToArrayApp.run();
    }
}




package org.csystem.app.samples.devices;

import java.util.Scanner;

public final class StoreDevicesToArrayApp {
    private static Device [] enlarge(Device [] devices, int newCapacity)
    {
        Device [] result = new Device[newCapacity];

        for (int i = 0; i < devices.length; ++i)
            result[i] = devices[i];

        return result;
    }

    private StoreDevicesToArrayApp()
    {
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Başlangıç capacity değerini giriniz:");
        Device [] devices = new Device[Integer.parseInt(kb.nextLine())];
        int index = 0;

        for (;;) {
            System.out.print("Cihaz adını giriniz:");
            String name = kb.nextLine();

            if ("elma".equals(name))
                break;

            System.out.print("Cihaz Ip adresini giriniz:");
            String host = kb.nextLine();

            System.out.print("Cihaz port numarasını giriniz:");
            int port = Integer.parseInt(kb.nextLine());

            if (index == devices.length)
                devices = enlarge(devices, devices.length * 2);

            devices[index++] = new Device(name, host, port);
            System.out.printf("Size:%d%n", index);
            System.out.printf("Capacity:%d%n", devices.length);
        }

        System.out.println("------------------------");
        for (int i = 0; i < index; ++i)
            System.out.println(devices[i].toString());

        System.out.printf("Size:%d%n", index);
        System.out.printf("Capacity:%d%n", devices.length);
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

package org.csystem.app.samples.devices;

public class Device {
    private String m_name;
    private String m_host;
    private int m_port;

    public Device(String name, String host, int port)
    {
        //...
        m_name = name;
        m_host = host;
        m_port = port;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getHost()
    {
        return m_host;
    }

    public void setHost(String host)
    {
        //...
        m_host = host;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }

    public String toString()
    {
        return String.format("[%s]%s:%d", m_name, m_host, m_port);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfında capacity kullanılır ancak nasıl büyütüleceği söylenmez. Bu sebeple ArrayList sınıfının
    capacity değerini veren bir metodu yoktur. Dolayısıyla capacity bilgisi gereken kodlarda Vector sınıfı ile örnekler
    yazılacaktır. Vector sınıfı burada anlatılmayan farklılıkları ve capacity bilgisini elde edebilmemiz dışında
    ArrayList ile aynı düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının default ctor elemanı capacity değerini 10(on) alarak nesnenin yaratılmasını sağlar. Vector
    sınıfının capacity metodu capacity değerini döndürür (ArrayList sınıfının capacity metodu yoktur).
    ArrayList/Vector sınıfının size metodu tutulan eleman sayısı bilgisini döndürür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector();

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının capacity parametreli ctor elemanı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector(23);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının add metodu sona eklemek için kullanılır. Şüphesiz bu metot gerektiğinde capacity
    değerini de uygun şekilde (amortized constant time) büyütür. Vector sınıfının default capacity büyütmesi var olan
    capacity değerinin iki katı olacak şekildedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector(6);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        for (int i = 0; i < 12; ++i)
            numbers.add(i * 10);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        numbers.add(67);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının index parametreli add metodu araya ekleme yapmak için kullanılabilir. Bu metot
    O(n) karmaşıklıktadır. Bu da sürekli araya eklme yapılan algoritmalarda bu veri yapısının dikkatli kullanılması ya da
    kullanılmaması anlamına gelir. Şüphesiz bu metot gerektiğinde capacity değerini uygun şekilde büyütür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector(6);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        for (int i = 0; i < 12; ++i)
            numbers.add(0, i * 10);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        numbers.add(2, 67);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının get metodu ile bir indeksteki eleman elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList(6);

        for (int i = 0; i < 12; ++i)
            numbers.add(i * 10);

        int size = numbers.size();

        for (int i = 0; i < size; ++i) {
            int val = (int)numbers.get(i);

            System.out.printf("%d ", val);
        }

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının get metodu ile bir indeksteki eleman elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList(6);

        for (int i = 0; i < 12; ++i)
            numbers.add(0, i * 10);

        int size = numbers.size();

        for (int i = 0; i < size; ++i) {
            int val = (int)numbers.get(i);

            System.out.printf("%d ", val);
        }

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının get metoduna pozitif ya da negatif bakımdan sınırlar dışında bir indeks numarası
    verildiğinde exception oluşur. Burada indeks değerleri [0, size) aralığındadır. Capacity değeri yani dizinin
    asıl uzunluğu içsel olarak kullanılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        Random r = new Random();

        ArrayList numbers = new ArrayList(6);

        for (int i = 0; i < n; ++i)
            numbers.add(r.nextInt(100));

        int size = numbers.size();

        int val = (int)numbers.get(5);

        System.out.println(val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfı for-each döngü deyimi ile dolaşılabilir (iterable) bir sınıftır. for-each döngü deyiminin
    her adımında içeride tutulan elemanlar sırasıyla elde edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList(6);

        for (int i = 0; i < 10; ++i)
            numbers.add(i * 10);

        for (Object obj : numbers) {
            int val = (int)obj;

            System.out.printf("%d ", val);
        }

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte elma girilene kadar alınan isimler bir listeye atılmıştır. Bu işlemden sonra liste for-each
    döngü deyimi ile dolaşılarak elemanlar elde edilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        ArrayList names = new ArrayList();
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("İsim giriniz:");
            String name = kb.nextLine();

            if (name.equals("elma"))
                break;

            names.add(name);
        }

        for (Object object : names) {
            String name = (String)object;

            System.out.println(name.toUpperCase());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ArrayList kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.devices.StoreDevicesToArrayApp;

class App {
    public static void main(String[] args)
    {
        StoreDevicesToArrayApp.run();
    }
}
package org.csystem.app.samples.devices;

import java.util.ArrayList;
import java.util.Scanner;

public final class StoreDevicesToArrayApp {
    private StoreDevicesToArrayApp()
    {
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Başlangıç capacity değerini giriniz:");

        ArrayList devices = new ArrayList(Integer.parseInt(kb.nextLine()));

        for (;;) {
            System.out.print("Cihaz adını giriniz:");
            String name = kb.nextLine();

            if ("elma".equals(name))
                break;

            System.out.print("Cihaz Ip adresini giriniz:");
            String host = kb.nextLine();

            System.out.print("Cihaz port numarasını giriniz:");
            int port = Integer.parseInt(kb.nextLine());

            devices.add(new Device(name, host, port));
            System.out.printf("Size:%d%n", devices.size());
        }

        System.out.println("------------------------");
        for (Object obj : devices) {
            Device device = (Device) obj;
            System.out.println(device.toString());
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

package org.csystem.app.samples.devices;

public class Device {
    private String m_name;
    private String m_host;
    private int m_port;

    public Device(String name, String host, int port)
    {
        //...
        m_name = name;
        m_host = host;
        m_port = port;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getHost()
    {
        return m_host;
    }

    public void setHost(String host)
    {
        //...
        m_host = host;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }

    public String toString()
    {
        return String.format("[%s]%s:%d", m_name, m_host, m_port);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının isEmpty metodu ile ArrayList'in boş olup olmadığı test edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        ArrayList names = new ArrayList();
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("İsim giriniz:");
            String name = kb.nextLine();

            if (name.equals("elma"))
                break;

            names.add(name);
        }

        if (!names.isEmpty()) {
            for (Object object : names) {
                String name = (String) object;

                System.out.println(name.toUpperCase());
            }
        }
        else
            System.out.println("Hiç isim girilmedi");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    StringUtil sınıfının  ArrayList parametreli join metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.ArrayList;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        ArrayList names = new ArrayList();
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("İsim giriniz:");
            String name = kb.nextLine();

            if (name.equals("elma"))
                break;

            names.add(name);
        }

        if (!names.isEmpty())
            System.out.println(StringUtil.join(names, '-'));
        else
            System.out.println("Hiç isim girilmedi");
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının set metodu, birinci parametresi ile aldığı indeks numarasındaki elemanı ikinci parametresi ile
    aldığı eleman ile değiştirir. Metot eski elemana ilişkin referansı döndürür. Metoda pozitif ya da negatif bakımdan
    sınırlar dışında indeks numarası verildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList();


        for (int i = 0; i < 10; ++i)
            numbers.add(i * 10);

        System.out.println("Elements:");
        for (Object obj : numbers) {
            int val = (int)obj;

            System.out.printf("%d ", val);
        }

        System.out.println();

        int oldValue = (int)numbers.set(3, 67);

        System.out.println("Elements:");
        for (Object obj : numbers) {
            int val = (int)obj;

            System.out.printf("%d ", val);
        }

        System.out.printf("%nOld value:%d%n", oldValue);

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının toString metodu ile ArrayList'in elemanları [] içerisinde virgülle ayrılacak şekilde bir
    String elde edilebilir. Bu String'in oluşturulma detayları ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList();


        for (int i = 0; i < 10; ++i)
            numbers.add(i * 10);

        System.out.println(numbers.toString());

        int oldValue = (int)numbers.set(3, 67);

        System.out.println(numbers.toString());

        System.out.printf("%nOld value:%d%n", oldValue);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: ArrayList/Vector sınıflarında size değerini azaltan metotlar (genel olarak mantıksal silme yapanlar)
    capacity değerini değiştirmez
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının clear metodu tüm elemanları siler (listeyi boşaltır) ancak capacity değerini değiştirmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector();

        System.out.printf("Size:%d%n", numbers.size());
        System.out.printf("Capacity:%d%n", numbers.capacity());

        for (int i = 0; i < 17; ++i)
            numbers.add(i * 10);

        System.out.println(numbers.toString());
        System.out.printf("Size:%d%n", numbers.size());
        System.out.printf("Capacity:%d%n", numbers.capacity());

        numbers.clear();
        System.out.println(numbers.toString());
        System.out.printf("Size:%d%n", numbers.size());
        System.out.printf("Capacity:%d%n", numbers.capacity());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının remove metodu parametresi ile aldığı indeks numarasına ilişkin elemanı siler. Metot
    sildiği eleman ilişkn referansa döner. Diziden eleman silmek O(n) karmaşıklıktadır. remove metodu da capacity değerini
    değiştirmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector();

        System.out.printf("Size:%d%n", numbers.size());
        System.out.printf("Capacity:%d%n", numbers.capacity());

        for (int i = 0; i < 17; ++i)
            numbers.add(i * 10);

        System.out.println(numbers.toString());
        System.out.printf("Size:%d%n", numbers.size());
        System.out.printf("Capacity:%d%n", numbers.capacity());

        int oldValue = (int)numbers.remove(4);

        System.out.println(numbers.toString());
        System.out.printf("Old value:%d%n", oldValue);
        System.out.printf("Size:%d%n", numbers.size());
        System.out.printf("Capacity:%d%n", numbers.capacity());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının trimToSize metodu capacity değerini size değerine getirir. Bu metot da O(n)
    karmaşıklıktadır. Bu sebeple bu metodun sürekli çağrılmaması gerekir. trimToSize metodu size sıfır ise genel olarak
    capacity değerini sıfır değerine çeker
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Random;
import java.util.Scanner;
import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector passwords = new Vector();
        Random r = new Random();
        Scanner kb = new Scanner(System.in);

        System.out.print("Kaç tane şifre üretmek istiyorsunuz?");
        int n = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < n; ++i)
            passwords.add(StringUtil.getRandomTextTR(r, 10));

        System.out.println(passwords.toString());
        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.trimToSize();

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.clear();
        passwords.trimToSize();

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının ensureCapacity metodu capacity değerini aşağıdaki şekilde değiştirmekte (veya değiştirmemekte)
    kullanılabilir: (else-if biçiminde düşününüz)
    - Yeni capacity değeri var olan capacity değerinden küçük veya eşitse değişklik yapmaz
    - Yeni capacity değeri var olan capacity değerinin artması gereken değerinden küçük veya eşitse artması gereken değere
    çeker.
    - Yeni capacity değeri var olan capacity değerinin artması gereken değerinden büyükse verilen capacity değerine çeker
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Random;
import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector passwords = new Vector();
        Random r = new Random();

        for (int i = 0; i < 12; ++i)
            passwords.add(StringUtil.getRandomTextTR(r, 10));

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(15);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(30);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(90);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    24.04.2021
    Sınıf Çalışması: Aşağıdaki gibi bir komut yorumlayıcı uygulama yazınız.
    Açıklamalar:
    1. gett komutu çalıştırıldığında klavyeden elma girilene kadar alınan yazılar bir ArrayList'e eklenecektir.
    2. join komutu ile Arraylist içerisindeki yazıları, alınan ayraç kullanılarak ile birleştirilecektir. join komutuna
    hiç yazı verilmezse space karakteri ile yazıları birleştirecektir
    4. CommandPromptApp uygulamasına diğer komutlarla birlikte bu komutlar da eklenecektir
    5. İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.commandprompt.CommandPromptApp;

class App {
    public static void main(String [] args)
    {
        CommandPromptApp.run();
    }
}

package org.csystem.app.samples.commandprompt;

public final class CommandPromptApp {
    private CommandPromptApp()
    {
    }
    public static void run()
    {
        CommandPrompt commandPrompt = new CommandPrompt("CSD");

        commandPrompt.run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	CommandPrompt sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.samples.commandprompt;

import org.csystem.util.StringUtil;

import java.util.ArrayList;
import java.util.Scanner;

public class CommandPrompt {
    private static final String [] COMMANDS = {"length", "reverse", "upper", "lower", "change", "gett", "join", "cleart", "elma"};
    private final Scanner m_kb = new Scanner(System.in);
    private final ArrayList m_textList = new ArrayList();
    private String m_prompt;

    private static String getCommandByText(String text)
    {
        if (text.length() < 3)
            return "";

        for (String cmdStr : COMMANDS)
            if (cmdStr.startsWith(text))
                return cmdStr;

        return "";
    }

    private static void lengthProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("length bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].length());
    }

    private static void reverseProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("reverse bir tane argüman almalıdır");
            return;
        }

        System.out.println(StringUtil.reverse(commandInfo[1]));
    }

    private static void upperProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("upper bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].toUpperCase());

    }

    private static void lowerProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("lower bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].toLowerCase());
    }

    private void getTextsProc(String [] commandInfo)
    {
        if (commandInfo.length != 1) {
            System.out.println("gett argümansız yazılmalıdır");
            return;
        }

        for (;;) {
            System.out.println("İşlemi sonlandırmak için elma giriniz");
            System.out.print("Yazıyı giriniz:");
            String text = m_kb.nextLine();

            if ("elma".equals(text))
                break;

            m_textList.add(text);
        }
    }

    private void clearTextsProc(String [] commandInfo)
    {
        m_textList.clear();
    }

    private void joinProc(String [] commandInfo)
    {
        String sep = " ";

        if (commandInfo.length != 1)
            sep = StringUtil.join(commandInfo, 1, ' ');

        if (m_textList.isEmpty()) {
            System.out.println("Listede hiç yazı yok");
            return;
        }

        String str = StringUtil.join(m_textList, sep);

        System.out.println(str);
    }

    private void changeProc(String [] commandInfo)
    {
        m_prompt = StringUtil.join(commandInfo, 1, ' ');
    }

    private static void quitProc(String [] commandInfo)
    {
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.println("Tekrar yapıyor musunuz?");
        System.exit(0);
    }
    private void doWorkForCommand(String [] commandInfo)
    {
        switch (commandInfo[0]) {
            case "length":
                lengthProc(commandInfo);
                break;
            case "reverse":
                reverseProc(commandInfo);
                break;
            case "upper":
                upperProc(commandInfo);
                break;
            case "lower":
                lowerProc(commandInfo);
                break;
            case "change":
                changeProc(commandInfo);
                break;
            case "gett":
                getTextsProc(commandInfo);
                break;
            case "cleart":
                clearTextsProc(commandInfo);
                break;
            case "join":
                joinProc(commandInfo);
                break;
            default:
                quitProc(commandInfo);
                break;
        }
    }

    private void parseCommand(String [] commandsInfo)
    {
        String cmdStr = getCommandByText(commandsInfo[0]);

        if (!cmdStr.isEmpty()) {
            commandsInfo[0] = cmdStr;
            doWorkForCommand(commandsInfo);
        }
        else {
            System.out.println("Geçersiz komut");
        }
    }

    public CommandPrompt(String prompt)
    {
        m_prompt = prompt;
    }

    public void run()
    {
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.println("Homework-013 çalışma sorusuna ilişkin bir iskelet");
        System.out.println("Geri kalanları lütfen yapınız");

        for (;;) {
            System.out.print(m_prompt + ">");
            String cmd = m_kb.nextLine().trim();
            parseCommand(cmd.split("[ \t]"));
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.collection.CSDArrayList;

class App {
    public static void main(String [] args)
    {
        CSDArrayList list = new CSDArrayList();

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());

        for (int i = 0; i < 15; ++i)
            list.add(i * 10);

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());

        int size = list.size();
        for (int i = 0; i < size; ++i) {
            int val = (int)list.get(i);
            System.out.printf("%d ", val);
        }

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;
import org.csystem.util.collection.CSDArrayList;

import java.util.Random;

class App {
    public static void main(String [] args)
    {
        CSDArrayList passwords = new CSDArrayList();
        Random r = new Random();

        for (int i = 0; i < 12; ++i)
            passwords.add(StringUtil.getRandomTextTR(r, 10));

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(15);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(30);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(90);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;
import org.csystem.util.collection.CSDArrayList;

import java.util.Random;

class App {
    public static void main(String [] args)
    {
        CSDArrayList passwords = new CSDArrayList();
        Random r = new Random();

        for (int i = 0; i < 12; ++i)
            passwords.add(StringUtil.getRandomTextTR(r, 10));

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
        System.out.println("-----------------------------");

        passwords.trimToSize();

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
        System.out.println("-----------------------------");

        passwords.clear();

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
        System.out.println("-----------------------------");

        passwords.trimToSize();

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
        System.out.println("-----------------------------");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.collection;

public class CSDArrayList {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void doWorkForIllegalArgumentException(String message)
    {
        System.out.println(message);
        System.exit(-1);
    }

    private static void doWorkForIndexOutOfBoundsException(String message)
    {
        System.out.println(message);
        System.exit(-1);
    }

    private static void checkCapacityValue(int capacity)
    {
        if (capacity < 0)
            doWorkForIllegalArgumentException("Capacity can not be negative");
    }

    private void checkIndex(int index)
    {
        if (index < 0 || index >= m_index)
            doWorkForIndexOutOfBoundsException("Index out of bounds");
    }

    private void changeCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        System.arraycopy(m_elems, 0, temp, 0, m_index);

        m_elems = temp;
    }

    public CSDArrayList()
    {
        m_elems = new Object[DEFAULT_CAPACITY];
    }

    public CSDArrayList(int capacity)
    {
        checkCapacityValue(capacity);
        m_elems = new Object[capacity];
    }

    public boolean add(Object elem)
    {
        if (m_elems.length == m_index)
            changeCapacity(m_elems.length == 0 ? 1 : m_elems.length * 2);

        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, Object elem)
    {
        //TODO:
    }

    public int capacity()
    {
        return m_elems.length;
    }

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public void ensureCapacity(int capacity)
    {
        if (capacity < m_elems.length)
            return;

        changeCapacity(Math.max(m_elems.length * 2, capacity));
    }

    public Object get(int index)
    {
        checkIndex(index);

        return m_elems[index];
    }

    public Object set(int index, Object elem)
    {
        checkIndex(index);
        Object oldElem = m_elems[index];

        m_elems[index] = elem;

        return oldElem;
    }


    private Object remove(int index)
    {
        //TODO:
        Object oldVal = m_elems[index];

        //TODO:

        return oldVal;
    }

    public int size()
    {
        return m_index;
    }

    public void trimToSize()
    {
        if (m_index != m_elems.length)
            changeCapacity(m_index);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın içerisinde tüm metotların dışında herhangi bir yerde static anahtar sözcüğü ile tanımlanan bloklara
    sınıfın static blokları (static initializers) denir. Sınıfın herhangi bir elamanı ilk kez kullanıldığında tüm static
    bloklar yukarıdan aşağıya doğru sırayla bir kez olmak üzere çalıştırılır. İlk kez kullanılan eleman sınıfın
    sınıfın static elemanı olmak zorunda değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo();
        System.out.println("////////////////////");
        Sample.foo();
    }
}

class Sample {
    static {
        System.out.println("static initializer1");
    }
    //...

    static {
        System.out.println("static initializer2");
    }

    static {
        System.out.println("static initializer3");
    }

    public static void foo()
    {
        System.out.println("foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın içerisinde tüm metotların dışında herhangi bir yerde static anahtar sözcüğü ile tanımlanan bloklara
    sınıfın static blokları (static initializers) denir. Sınıfın herhangi bir elamanı ilk kez kullanıldığında tüm static
    bloklar yukarıdan aşağıya doğru sırayla bir kez olmak üzere çalıştırılır. İlk kez kullanılan eleman sınıfın sınıfın
    static elemanı olmak zorunda değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s;

        System.out.println("////////////////////////////////");
        s = new Sample();

        System.out.println("////////////////////////////////");
        s = new Sample();

    }
}

class Sample {
    static {
        System.out.println("static initializer1");
    }
    //...

    static {
        System.out.println("static initializer2");
    }

    static {
        System.out.println("static initializer3");
    }

    public Sample()
    {
        System.out.println("Sample.Sample()");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    static bloklar static metotlar gibidir yani bu bloklarda sınıfın yalnızca static elemanlarına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo();
        Sample.foo();
    }
}

class Sample {
    private static int ms_val;
    static {
        ms_val = 10;
        System.out.println("static initializer1");
        foo();
        bar();//error
    }

    public static void foo()
    {
        //..
    }

    public void bar()
    {
        //..
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    Sınıfın final static veri elemanlarına static bloklarda değer atanabilir. Şüphesiz burada değer atanabilmesi
    için bildirim noktasında atanmamış olması gerekir. Zaten static initilizer'ın en çok kullanıldığı durum da
    final ve static veri elemanlara değer verilmesidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.PI);
    }
}

class Sample {
    public static final double PI;

    static {
        PI = 3.14;
    }


    //...

}

/*----------------------------------------------------------------------------------------------------------------------
    static bloğun bir kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.VAL);
        System.out.println("************************");
        System.out.println(Sample.VAL);
    }
}

class Sample {
    public static final int VAL;

    static {
        Random r = new Random();

        Scanner kb = new Scanner(System.in);
        System.out.print("min?");
        int min = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(kb.nextLine());

        VAL = r.nextInt(max - min) + min;
    }
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnek static blok kullanmadan aşağıdaki gibi yapılabilir. Dikkat edilirse static blok daha yalın
    kod yazmamızı sağlar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.VAL);
        System.out.println("************************");
        System.out.println(Sample.VAL);
    }
}

class Sample {
    private static int randomVal()
    {
        Random r = new Random();

        Scanner kb = new Scanner(System.in);
        System.out.print("min?");
        int min = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(kb.nextLine());

        return r.nextInt(max - min) + min;
    }

    public static final int VAL = randomVal();
    //...
}



/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte static blok kullanılarak kod daha basit bir biçimde yazılmıştır. static blok kullanmadan
    nasıl yaparsınız? Düşünün
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.VAL);
        System.out.println(Sample.VAL2);
        System.out.println("****************");
        System.out.println(Sample.VAL);
        System.out.println(Sample.VAL2);
    }
}

class Sample {
    static {
        Random r = new Random();

        Scanner kb = new Scanner(System.in);
        System.out.print("min?");
        int min = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(kb.nextLine());

        VAL =  r.nextInt(max - min) + min;
        VAL2 =  r.nextInt(max - min) + min;
    }


    public static final int VAL;
    public static final int VAL2;
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıf içerisindeki tüm static blokların kendi faaliyet alanları vardır. Yani aslında bunlar ayrı metotlar
    gibi düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.printf("Sample.VAL1 = %d%n", Sample.VAL1);
        System.out.printf("Sample.VAL2 = %d%n", Sample.VAL2);
    }
}

class Sample {
    public static final int VAL1;
    public static final int VAL2;

    static {
        System.out.println("static initializer1");
        int a = 10;

        VAL1 = a * 2;
    }

    static {
        System.out.println("static initializer2");
        int a = 20;

        VAL2 = a * 3;
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    Bazen static blok kodun derli yoplu olarak yazılması için de kullanılabilir. Aşağıdaki sınıflarda yazılan static
    bloklara gerek olmasa da kodun okunabilirliğini artırabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Date sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Date {
    private static final String [] MONTHS_TR;
    private static final String [] MONTHS_EN;
    private static final String [] DAYS_OF_WEEK_TR;
    private static final String [] DAYS_OF_WEEK_EN;
    private static final Month [] MONTHS;

    static {
        MONTHS_TR = new String[] {"", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran",
                "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};
        MONTHS_EN = new String[] {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
        DAYS_OF_WEEK_TR = new String[] {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
        DAYS_OF_WEEK_EN = new String[] {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
        MONTHS = Month.values();
    }

    private int m_day;
    private int m_month;
    private int m_year;
    private int m_dayOfWeek;

    private static boolean isValidDate(int day, int month, int year)
    {
        if (day < 1 || day > 31 || month < 1 || month > 12)
            return false;

        return day <= MONTHS[month - 1].getDays(year);
    }

    private static int getTotalDaysByMonth(int month, int year)
    {
        int totalDays = 0;

        for (int m  = month - 1; m >= 1; --m)
            totalDays += MONTHS[m - 1].getDays(year);

        return month > 2 && Month.isLeapYear(year) ? totalDays + 1 : totalDays;
    }

    private static int getDayOfYear(int day, int month, int year)
    {
        return day + getTotalDaysByMonth(month, year);
    }

    private static int getDayOfWeek(int day, int month, int year)
    {
        int totalDays = getDayOfYear(day, month, year);

        for (int y = 1900; y < year; ++y)
            totalDays += Month.isLeapYear(y) ? 366 : 365;

        return totalDays % 7;
    }

    private static String getDaySuffix(int day)
    {
        String suffix = "th";

        switch (day) {
            case 1:
            case 21:
            case 31:
                suffix = "st";
                break;
            case 2:
            case 22:
                suffix = "nd";
                break;
            case 3:
            case 23:
                suffix = "rd";
                break;
        }

        return suffix;
    }

    private static void doWorkForException(String message)
    {
        System.out.println(message);
        System.exit(-1); //exception işlemleri konusuna kadar sabredin
    }

    private static void checkForDate(int day, int month, int year, String errMessage)
    {
        if (!isValidDate(day, month, year))
            doWorkForException(errMessage);
    }

    private void checkForDay(int val)
    {
        checkForDate(val, m_month, m_year, "Invalid day value:" + val);
    }

    private void checkForMonth(int val)
    {
        checkForDate(m_day, val, m_year, "Invalid month value:" + val);
    }

    private void checkForYear(int val)
    {
        checkForDate(m_day, m_month, val, "Invalid year value:" + val);
    }

    private void set(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    public static Date of()
    {
        return of(new Random());
    }

    public static Date of(Random r)
    {
        return of(r, new Date().m_year);
    }

    public static Date of(int year)
    {
        return of(new Random(), year);
    }

    public static Date of(Random r, int year)
    {
        return of(r, year, year);
    }

    public static Date of(int minYear, int maxYear)
    {
        return of(new Random(), minYear, maxYear);
    }

    public static Date of(Random r, int minYear, int maxYear)
    {
        int year = r.nextInt(maxYear - minYear + 1) + minYear;
        int month = r.nextInt(12) + 1;
        int day = r.nextInt(MONTHS[month - 1].getDays(year)) + 1;

        return new Date(day, month, year);
    }

    public Date() //Burada yazılanların bilinmesi gerekmez. Sadece default ctor'un anlamı olarak yazılmıştır
    {
        Calendar now = Calendar.getInstance();

        m_day = now.get(Calendar.DAY_OF_MONTH);
        m_month = now.get(Calendar.MONTH) + 1;
        m_year = now.get(Calendar.YEAR);
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    public Date(int day, Month month, int year)
    {
        this(day, month.ordinal() + 1, year);
    }

    public Date(int day, int month, int year)
    {
        checkForDate(day, month, year, String.format("Invalid date values: all values -> %d, %d, %d", day, month, year));
        set(day, month, year);
    }

    public int getDay()
    {
        return m_day;
    }

    public void setDay(int day)
    {
        if (day == m_day)
            return;

        checkForDay(day);
        set(day, m_month, m_year);
    }

    public Month getMonth()
    {
        return MONTHS[m_month - 1];
    }

    public void setMonth(Month month)
    {
        setMonthValue(month.ordinal() + 1);
    }
    public int getMonthValue()
    {
        return m_month;
    }

    public void setMonthValue(int month)
    {
        if (month == m_month)
            return;

        checkForMonth(month);
        set(m_day, month, m_year);
    }

    public int getYear()
    {
        return m_year;
    }

    public void setYear(int year)
    {
        if (year == m_year)
            return;

        checkForYear(year);
        set(m_day, m_month, year);
    }

    public DayOfWeek getDayOfWeek()
    {
        return DayOfWeek.values()[m_dayOfWeek];
    }

    public String getDayOfWeekTR()
    {
        return DAYS_OF_WEEK_TR[m_dayOfWeek];
    }

    public String getDayOfWeekEN()
    {
        return DAYS_OF_WEEK_EN[m_dayOfWeek];
    }

    public boolean isLeapYear()
    {
        return Month.isLeapYear(m_year);
    }

    public boolean isWeekend()
    {
        return m_dayOfWeek == 0 || m_dayOfWeek == 6;
    }

    public boolean isWeekday()
    {
        return !isWeekend();
    }

    public String toString()
    {
        return toString('/');
    }

    public String toString(char delimiter)
    {
        return String.format("%02d%c%02d%c%04d", m_day, delimiter, m_month, delimiter, m_year);
    }

    public String toStringTR()
    {
        return String.format("%d %s %d", m_day, MONTHS_TR[m_month], m_year);
    }

    public String toStringEN()
    {
        return String.format("%d%s %s %d", m_day, getDaySuffix(m_day), MONTHS_EN[m_month], m_year);
    }

    public String toLongDateStringTR()
    {
        return String.format("%s %s", toStringTR(), DAYS_OF_WEEK_TR[m_dayOfWeek]);
    }

    public String toLongDateStringEN()
    {
        return String.format("%s %s", toStringEN(), DAYS_OF_WEEK_EN[m_dayOfWeek]);
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class IntValue {
    private static final IntValue [] CACHE;
    private final int m_val;

    private IntValue(int val)
    {
        m_val = val;
    }

    public static final IntValue ONE;
    public static final IntValue ZERO;
    public static final IntValue TEN;

    static {
        CACHE = new IntValue[256];
        ONE = of(1);
        ZERO = of(0);
        TEN = of(10);
    }

    public static IntValue of(int val)
    {
        if (val < -128 || val > 127)
            return new IntValue(val);

        if (CACHE[val + 128] == null)
            CACHE[val + 128] = new IntValue(val);

        return CACHE[val + 128];
    }

    public int getVal()
    {
        return m_val;
    }

    public int compareTo(IntValue other)
    {
        return m_val - other.m_val;
    }

    public IntValue add(int val)
    {
        return of(m_val + val);
    }

    public IntValue add(IntValue other)
    {
        return add(other.m_val);
    }

    public IntValue subtract(int val)
    {
        return add(-val);
    }

    public IntValue subtract(IntValue other)
    {
        return subtract(other.m_val);
    }

    public IntValue multiply(int val)
    {
        return of(m_val * val);
    }

    public IntValue multiply(IntValue other)
    {
        return multiply(other.m_val);
    }

    public IntValue increment()
    {
        return add(1);
    }

    public IntValue decrement()
    {
        return subtract(1);
    }

    public String toString()
    {
        return m_val + "";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	NumberUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import static java.lang.Math.log10;
import static java.lang.Math.abs;
import static java.lang.Math.pow;

public final class NumberUtil {
    private static final String [] ONES;
    private static final String [] TENS;

    static {
        ONES = new String[] {"", "bir", "iki", "üç", "dört", "beş", "altı", "yedi", "sekiz", "dokuz"};
        TENS = new String[] {"", "on", "yirmi", "otuz", "kırk", "elli", "altmış", "yetmiş", "seksen", "doksan"};
    }

    private static int [] getDigits(long val, int n)
    {
        int [] digits = new int[val == 0 ? 1 : (int)(log10(abs(val)) / n) + 1];
        int powOfTen = (int)Math.pow(10, n);

        for (int i = digits.length - 1; i >= 0; digits[i--] = (int)(val % powOfTen), val /= powOfTen)
            ;

        return digits;
    }

    private static String numberToText3DigitsTR(int val)
    {
        if (val == 0)
            return "sıfır";

        String str = val < 0 ? "eksi" : "";
        val = Math.abs(val);

        int a, b, c;

        a = val / 100;
        b = val / 10 % 10;
        c = val % 10;

        if (a != 0) {
            if (a != 1)
                str += ONES[a];
            str += "yüz";
        }
        if (b != 0)
            str += TENS[b];

        if (c != 0)
            str += ONES[c];

        return str;
    }

    private NumberUtil()
    {
    }

    public static int countDigits(long val)
    {
        return val == 0 ? 1 : (int)log10(abs(val)) + 1;
    }

    public static void displayCollatz(int n)
    {
        if (n <= 0) {
            System.out.println("Geçersiz değer");
            return;
        }

        for (;;) {
            System.out.println(n);

            if (n == 1)
                break;

            if (n % 2 == 0)
                n /= 2;
            else
                n = 3 * n + 1;
        }
    }

    public static long factorial(int n)
    {
        long result = 1L;

        for (int i = 2; i <= n; ++i)
            result *= i;

        return result;
    }

    public static int getDigitalRoot(int val)
    {
        int root = abs(val);

        while (root > 9)
            root = sumDigits(root);

        return root;
    }

    public static int [] getDigits(long val)
    {
        return getDigits(val, 1);
    }

    public static int [] getDigitsInThrees(long val)
    {
        return getDigits(val, 3);
    }

    public static int [] getDigitsInTwos(long val)
    {
        return getDigits(val, 2);
    }

    public static int getDigitsFactorialSum(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += factorial(val % 10);
            val /= 10;
        }

        return sum;
    }

    public static int getDigitsPowSum(int val)
    {
        int n = countDigits(val);
        int sum = 0;

        while (val != 0) {
            sum += pow(val % 10, n);
            val /= 10;
        }

        return sum;
    }

    public static int getFibonacciNumber(int n)
    {
        if (n <= 0)
            return -1;

        if (n <= 2)
            return n - 1;

        int prev1 = 1, prev2 = 0, val = 0;

        for (int i = 2; i < n; ++i) {
            val = prev1 + prev2;
            prev2 = prev1;
            prev1 = val;
        }

        return val;
    }

    public static int getIndexOfPrimeNumber(int n)
    {
        int index = 1;
        int val = 2;

        for (;;) {
            if (val == n)
                return index;

            if (isPrime(val))
                ++index;

            ++val;
        }
    }

    public static int getNextFibonacciNumber(int val)
    {
        if (val < 0)
            return 0;

        int prev1 = 1, prev2 = 0, result;

        for (;;) {
            result = prev1 + prev2;

            if (result > val)
                return result;

            prev2 = prev1;
            prev1 = result;
        }
    }

    public static int getPrime(int n)
    {
        if (n <= 0)
            return -1;

        int count = 0;
        int val = 2;

        for (;;) {
            if (isPrime(val))
                ++count;

            if (count == n)
                return val;

            ++val;
        }
    }

    public static boolean isArmstrong(int val)
    {
        return val >= 0 && getDigitsPowSum(val) == val;
    }

    public static boolean isDecimalHarshad(int val)
    {
        if (val < 0)
            return false;

        return val % sumDigits(val) == 0;
    }

    public static boolean isEven(int val)
    {
        return val % 2 == 0;
    }

    public static boolean isFactorian(int val)
    {
        if (val <= 0)
            return false;

        return getDigitsFactorialSum(val) == val;
    }

    public static boolean isHardyRamanujan(int val)
    {
        if (val <= 0)
            return false;

        int count = 0;

        for (int x = 1; x * x * x < val;) {
            for (int y = x + 1; x * x * x + y * y * y <= val; ++y)  {
                if (x * x * x + y * y * y == val) {
                    ++count;
                    ++x;
                }
            }
            ++x;
        }

        return count >= 2;
    }

    public static boolean isOdd(int val)
    {
        return !isEven(val);
    }

    public static boolean isPalindrome(int val)
    {
        return reversed(val) == val;
    }

    public static boolean isPrime(int val)
    {
        if (val <= 1)
            return false;

        if (val % 2 == 0)
            return val == 2;

        if (val % 3 == 0)
            return val == 3;

        if (val % 5 == 0)
            return val == 5;

        if (val % 7 == 0)
            return val == 7;

        int sqrtVal = (int)Math.sqrt(val);

        for (int i = 11; i <= sqrtVal; i += 2)
            if (val % i == 0)
                return false;

        return true;
    }

    public static boolean isPrimeX(int val)
    {
        do {
            if (!isPrime(val))
                return false;
            val = sumDigits(val);
        } while (val > 9);

        return isPrime(val);
    }

    public static boolean isSuperPrime(int val)
    {
        return isPrime(val) && isPrime(getIndexOfPrimeNumber(val));
    }

    public static int max(int a, int b, int c)
    {
        return Math.max(Math.max(a, b),  c);
    }

    public static int mid(int a, int b, int c)
    {
        if (a <= b && b <= c || c <= b && b <= a)
            return b;

        if (b <= a && a <= c || c <= a && a <= b)
            return a;

        return c;
    }

    public static int min(int a, int b, int c)
    {
        return Math.min(Math.min(a, b),  c);
    }

    public static String numberToText(long val)
    {
        int [] digits = getDigitsInThrees(val);

        String result = "";

        //TODO:
        for (int digit : digits)
            result += numberToText3DigitsTR(digit) + " ";

        return result;
    }

    public static int reversed(int val)
    {
        int reverse = 0;

        while (val != 0) {
            reverse = reverse * 10 + val % 10;
            val /= 10;
        }

        return reverse;
    }

    public static int sumDigits(int val)
    {
        int sum = 0;

        while (val != 0) {
            sum += val % 10;
            val /= 10;
        }

        return Math.abs(sum);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.ArrayList;
import java.util.Random;
import static java.lang.Character.isWhitespace;
import static java.lang.Character.toLowerCase;
import static java.lang.Character.toUpperCase;
import static java.lang.Character.isLetter;

public final class StringUtil {
    private static final String ALPHABET_LOWER_TR;
    private static final String ALPHABET_LOWER_EN;
    private static final String ALPHABET_TR;
    private static final String ALPHABET_EN;

    static {
        ALPHABET_LOWER_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
        ALPHABET_LOWER_EN = "abcdefghijklmnopqrstuvwxyz";
        ALPHABET_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ" + ALPHABET_LOWER_TR;
        ALPHABET_EN = "ABCDEFGHIJKLMNOPQRSTUWXVYZ" + ALPHABET_LOWER_EN;
    }

    private StringUtil()
    {
    }

    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static String changeCase(String s)
    {
        char [] c = new char[s.length()];

        for (int i = 0; i < c.length; ++i) {
            char ch = s.charAt(i);

            c[i] = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);
        }

        return String.valueOf(c);
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        int length = sourceText.length();
        char [] c = new char[n];

        for (int i = 0; i < n; ++i)
            c[i] = sourceText.charAt(r.nextInt(length));

        return String.valueOf(c);
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, ALPHABET_TR);
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String [] getRandomTextsTR(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextTR(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, ALPHABET_EN);
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static String [] getRandomTextsEN(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextEN(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static boolean isJavaIdentifier(String s)
    {
        if (s.equals("_"))
            return false; //Java 9 ve sonrası için kdeğişken kontrolü

        if (s.isBlank())
            return false;

        char ch = s.charAt(0);

        if (!Character.isJavaIdentifierStart(ch))
            return false;

        int length = s.length();

        for (int i = 1; i < length; ++i)
            if (!Character.isJavaIdentifierPart(s.charAt(i)))
                return false;

        return true;
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), ALPHABET_LOWER_EN);
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), ALPHABET_LOWER_TR);
    }

    public static String join(ArrayList list, String sep)
    {
        return join(list, 0, sep);
    }

    public static String join(ArrayList list, char sep)
    {
        return join(list, 0, sep);
    }

    public static String join(ArrayList list, int startIndex, char sep)
    {
        return join(list, startIndex, sep + "");
    }

    public static String join(ArrayList list, int startIndex, String sep)
    {
        String result = "";

        int size = list.size();

        for (int i = 0; i < size; ++i) {
            if (!result.isEmpty())
                result += sep;

            result += list.get(i);
        }

        return result;
    }

    public static String join(String [] str, char sep)
    {
        return join(str, 0, sep);
    }

    public static String join(String [] str, int startIndex, char sep)
    {
        return join(str, startIndex, sep + "");
    }

    public static String join(String [] str, int startIndex, String sep)
    {
        String result = "";

        int length = str.length;

        for (int i = startIndex; i < length; ++i) {
            if (!result.isEmpty())
                result += sep;

            result += str[i];
        }

        return result;
    }

    public static String join(String [] str, String sep)
    {
       return join(str, 0, sep);
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        char [] c = s.toCharArray();

        ArrayUtil.reverse(c);

        return String.valueOf(c);
    }

    public static String squeeze(String s1, String s2)
    {
        String str = "";
        int length = s1.length();

        for (int i = 0; i < length; ++i) {
            char ch = s1.charAt(i);
            if (!s2.contains(ch + ""))
                str += ch;
        }

        return str;
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }

    public static String wrapWith(String str, char ch)
    {
        return wrapWith(str, ch, false);
    }

    public static String wrapWith(String str, char ch, boolean trim)
    {
        return wrapWith(str, ch, ch, trim);
    }

    public static String wrapWith(String str, char chBegin, char chEnd)
    {
        return wrapWith(str, chBegin, chEnd, false);
    }

    public static String wrapWith(String str, char chBegin, char chEnd, boolean trim)
    {
        return String.format("%c%s%c", chBegin, trim ? str.trim() : str, chEnd);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın non-static blokları (non-static initializer) olabilir. Bu bloklar ctor'ların başında çalıştırılır.
    Yani adeta bu bloklar her ctor'un başına gizlice eklenir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        System.out.println("*****************");
        Sample k = new Sample();

        //...
    }
}

class Sample {
    {
        System.out.println("non-static initializer1");
    }


    {
        System.out.println("non-static initializer2");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın non-static blokları (non-static initializer) olabilir. Bu bloklar ctor'ların başında çalıştırılır.
    Yani adeta bu bloklar her ctor'un başına gizlice eklenir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        System.out.println("*****************");
        Sample k = new Sample(10);

        //...
    }
}

class Sample {
    {
        System.out.println("non-static initializer1");
    }


    {
        System.out.println("non-static initializer2");
    }

    public Sample()
    {
        System.out.println("Sample.Sample()");
    }

    public Sample(int a)
    {
        System.out.println("Sample.Sample(int)");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın ctor'u içerisinde o sınıfın başka bir ctor'unun çağrılması kodu yazılmışsa (this ctor) bu durumda
    çağıran için non-static initializer kodu yerleştirilmez. Çünkü zaten çağrılan ctor' da ya olacaktır ya da
    o da başka bir ctor'u çağırsa da sonuçta çalıştırılacak bir non-static blok mutlaka olacaktır. Yani bir non-static
    initializer nesne başına bir kez çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s1 = new Sample();
        System.out.println("**********************");
        Sample s2 = new Sample(10);
        System.out.println("**********************");
        Sample s3 = new Sample(3.4);

        //...
    }
}

class Sample {
    {
        System.out.println("non-static initializer");
    }

    public Sample(double a)
    {
        System.out.println("Sample.Sample(double)");
    }

    public Sample()
    {
        this(Math.PI);
        System.out.println("Sample.Sample()");
    }

    public Sample(int a)
    {
        this();
        System.out.println("Sample.Sample(int)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    super ctor sentaksı kullanıldığında non-static blokların çalıştırılma sırası
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B x = new B();
        System.out.println("*****************");
        B y = new B(20);

        //...
    }
}

class A {
    {
        System.out.println("non-static initializer of A");
    }

    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
}

class B extends A {
    {
        System.out.println("non-static initializer of B");
    }

    public B()
    {
        System.out.println("B.B()");
    }

    public B(int a)
    {
        super(a);
        System.out.println("B.B(int)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    non-static bloklar non-static metotlar gibidir. Yani non-static elemanlara doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new A();
        System.out.println("*************************");
        A y = new A();
    }
}

class A {
    {
        System.out.println("non-static initializer of A");
        bar();
    }

    public void bar()
    {
        System.out.println("bar");
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıfın non-static final veri elemanlarına non-static blok içerisinde değer atanabilir. Şüphesiz daha önce
    değerin atanmamış olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        System.out.printf("s.val=%d%n", s.val);

        Sample k = new Sample();

        System.out.printf("k.val=%d%n", k.val);
    }
}

class Sample {
    private static final Random RAND = new Random();
    private static final Scanner KB = new Scanner(System.in);
    public final int val;

    {
        System.out.print("min?");
        int min = Integer.parseInt(KB.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(KB.nextLine());

        val = RAND.nextInt(max - min) + min;
    }
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnek aşağıdaki gibi de yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();

		System.out.printf("s.val=%d%n", s.val);

		Sample k = new Sample();

		System.out.printf("k.val=%d%n", k.val);
	}
}

class Sample {
	private static final Random RAND;
	private static final Scanner KB;
	public final int val;

	static {
		RAND = new Random();
		KB = new Scanner(System.in);
	}

	{
		System.out.print("min?");
		int min = Integer.parseInt(KB.nextLine());

		System.out.print("max?");
		int max = Integer.parseInt(KB.nextLine());

		val = RAND.nextInt(max - min) + min;
	}
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki sınıfta public bölümde hiç static eleman olmadığından müşteri kodlar nesne yaratmadan bu sınıfı
    kullanamazlar. İlk nesne yaratılırken sınıfın static bloğu çalıştırılacağından diğer nesneler aynı MIN ve MAX
    değerlerini kullanacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        System.out.printf("s.val=%d%n", s.val);

        Sample k = new Sample();

        System.out.printf("k.val=%d%n", k.val);
    }
}

class Sample {
    private static final Random RAND;
    private static final int MIN;
    private static final int MAX;
    public final int val;

    static {
        RAND = new Random();
        Scanner kb = new Scanner(System.in);
        System.out.print("min?");
        MIN = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        MAX = Integer.parseInt(kb.nextLine());
    }

    {
        val = RAND.nextInt(MAX - MIN) + MIN;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf içerisinde taban sınıfta bulunan non-static bir veri elemanı ile aynı isimde veri elemanı bildirilebilir.
    Bu durumda türemiş sınıf içerisindeki veri elemanı taban sınıf veri elemanı ismini maskeler (shadowing, masking).
    Aşağıdaki örnekte b referansı ile B içerisinde bildirilen x veri elemanına, a referansı ile a'nın gösterdiği
    B nesnesinin (dinamik türünün) A bölümündeki x veri elemanına erişilir. Artık B türü üzerinden A sınıfının  x veri
    elemanına erişilemez. Bu anlatılanlar sınıf dışından erişimler için geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();

        b.x = 10;

        System.out.printf("b.x=%d%n", b.x);

        A a = b; //upcasting

        System.out.printf("a.x=%d%n", a.x);
    }
}


class B extends A {
    public int x;
    //...
}

class A {
    public int x;
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	super referansı ile taban sınıfın bir elemanına erişilebilir. Aşağıdaki örnekte setValues metodu ile hem taban
	hem de türemiş sınıfta aynı isimde bulunan veri elemanlarına atama yapılmıştır. super referansı ile taban sınıfın
	bir metodu da çağrılabilir. Bu konunun detayları ileride ele alınacaktır. Örnekte super.x erişiminde super
	referansın kaldırarak sonucu inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();

        b.setValues(10, 20);

        System.out.printf("b.x=%d%n", b.x);

        A a = b;

        System.out.printf("a.x=%d%n", a.x);
    }
}

class B extends A {
    public int x;

    public void setValues(int a, int b)
    {
        x = a; //this.x = a;
        super.x = b;
        super.foo();
    }
    //...
}

class A {
    public int x;

    public void foo()
    {
        System.out.println("A.foo()");
    }
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf içerisinde taban sınıfta bulunan static bir veri elemanı ile aynı isimde bir veri elemanı bildirilebilir.
	Aşağıdaki örnekte *** ile belirtilen ifadede sınıf ismi kullanılmazsa x static veri elemanı olarak B'nin elemanı
	set edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B.setValues(10, 20);
        System.out.printf("B.x=%d%n", B.x);
        System.out.printf("A.x=%d%n", A.x);
    }
}

class B extends A {
    public static int x;

    public static void setValues(int a, int b)
    {
        x = a;
        A.x = b; //***
    }
    //...
}

class A {
    public static int x;

    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Polymorphism (çok biçimlilik): Programlamaya Biyoloji'den aktarılmıştır. Biyoloji'de çokbiçimlilik:
    "Farklı doku ya da organların evrim süreci içerisinde temel işlevleri aynı kalması koşuluyla, bu işlevi yerine
    getirme biçiminin değişmesidir" şeklinde tanımlanabilir. Örneğin duyma eylemi (davranışı) birbirlerinden türemiş
    canlılar arasında farklılık gösterebilmektedir. Ancak görev "duymaktır".

    Nesne yönelimli programlama tekniğinde aşağıda anlatılan çokbiçimliliğe "çalışma zamanı çok biçimliliği (runtime polymorphism)"
    denir. Çokbiçimlilik genel olarak iki gruba ayrılabilir: çalışma zamanı, derleme zamanı. Çoğu zaman "çokbiçimlilik"
    dendiğinde "çalışma zamanı çokbiçimliliği" anlaşılır. Bu aynı zamanda Biyoloji'den aktarılan çokbiçimliliktir.

    Çalışma zamanı çokbiçimliliği için çok fazla tanım ya da açıklama yapılabilse de aşağıdaki 3(üç) tanıma genel olarak
    indirgenebilir:
    1. Biyolojik Tanım: Taban sınıfın bir fonksiyonunun türemiş sınıfta yeniden gerçekleştirilmesidir.

    2. Yazılım Mühendisliği Tanımı: Türden bağımsız kod yazmaktır. Yani bir kavramın çok sayıda türevi olsa bile türevlerinden
    bağımsız olarak sadece o kavram kullanılarak kod yazmaktır

    3. Aşağı seviyeli tanım: Önceden yazılmış kodların sonradan yazılmış kodları çağırabilmesidir.

    Java'da çokbiçimlilik sanal metotlar (virtual methods) kullanılarak gerçekleştirilir. Java'da non-static olan ve
    final olmayan metotlar sanaldır. İleride bunun dışında sanal olan metotlar da anlatılacaktır.

    Sanal bir metodun türemiş sınıf içerisinde geri dönüş değeri ve imzası aynı olacak şekilde yazılmasına
    "override" denir. override işleminde erişim belirleyicinin durumu ileride ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte B sınıfına A'nın (yani taban sınıfının) foo bar metotları "override" edilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
    }

    public void bar(int a) //override
    {
        System.out.println("B.bar(int)");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }
    public void bar(int a)
    {
        System.out.println("A.bar(int)");
    }

}

/*----------------------------------------------------------------------------------------------------------------------
    non-static bir metot çağrısında metot sanal ise derleyici "çalışma zamanında referansın dinamik türüne bak, dinamik
    türe ilişkin sınfta metot override edilmişse onu çağır" kodunu üretir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B x = new B();
        A y;

        y = x;

        y.foo();
        y.bar(10);
    }
}


class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
    }

    public void bar(int a) //override
    {
        System.out.println("B.bar(int)");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }

    public void bar(int a)
    {
        System.out.println("A.bar(int)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    non-static bir metot çağrısında metot sanal ise derleyici "çalışma zamanında referansın dinamik türüne bak, dinamik
    türe ilişkin sınfta metot override edilmişse onu çağır" kodunu üretir. Aşağıdaki örnekte main metodunun içindeki
    müşteri kod A sınıfından türetilenlerden bağımsız olarak yazılmıştır. Yani türden bağımsız kod yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Factory factory = new Factory();
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        A x = factory.getAInstance(val);

        x.foo();
        x.bar(10);
    }
}


class Factory {
    //...
    public A getAInstance(int val)
    {
        return val > 0 ? new B() : new A();
    }
}

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
    }

    public void bar(int a) //override
    {
        System.out.println("B.bar(int)");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }

    public void bar(int a)
    {
        System.out.println("A.bar(int)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örneğe C sınıfı eklenmesine rağmen main metodu içerisindeki kodlar bundan etkilenmemiştir. Yani
    main metodu içerisinde A'dan türeyen sınıflar anlamında türden bağımsız kod yazılmıştır. Diğer bir söylemle
    A sınıfından türemiş her sınıf A olarak düşünülerek kod yazılmıştır. Çalışma zamanı sırasında dinamik tür ile
    gerçek türlere ilişkin metotlar çağrılmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Factory factory = new Factory();
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        A x = factory.getAInstance(val);

        x.foo();
        x.bar(10);
    }
}

class Factory {
    //...
    public A getAInstance(int val)
    {
        if (val > 0)
            return new C();
        if (val == 0)
            return new B();

        return new A();
    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo()");
    }

    public void bar(int a) //override
    {
        System.out.println("C.bar(int)");
    }
}

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
    }

    public void bar(int a) //override
    {
        System.out.println("B.bar(int)");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }

    public void bar(int a)
    {
        System.out.println("A.bar(int)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    25.04.2021
    Aşağıdaki örnekte yine türden bağımsız kod yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        MyApplication.run();
    }
}


class MyApplication {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        Random r = new Random();
        Factory factory = new Factory(r);

        for (int i = 0; i < n; ++i) {
            A a = factory.getRandomInstance();

            a.foo();
            a.bar(r.nextInt(100));
            System.out.println("------------------");
        }
    }
}

class Factory {
    private final Random m_random;

    public Factory()
    {
        this(new Random());
    }

    public Factory(Random random)
    {
        m_random = random;
    }

    public A getRandomInstance()
    {
        int val = m_random.nextInt(3);
        A a;

        switch (val) {
            case 0:
                a = new C();
                break;
            case 1:
                a = new B();
                break;
            default:
                a = new A();
        }

        return a;
    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo()");
    }

    public void bar(int a) //override
    {
        System.out.printf("C.bar(int):%02d%n", a);
    }
}

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
    }

    public void bar(int a) //override
    {
        System.out.printf("B.bar(int):%02d%n", a);
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }

    public void bar(int a)
    {
        System.out.printf("A.bar(int):%02d%n", a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sanal metot dinamik türe ilişkin sınıfta override edilmemişse sırasıyla taba sınıflara bakılır. İlk bulunan
    metot çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        MyApplication.run();
    }
}

class MyApplication {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        Random r = new Random();
        Factory factory = new Factory(r);

        for (int i = 0; i < n; ++i) {
            A a = factory.getRandomInstance();

            a.foo();
            a.bar(r.nextInt(100));
            System.out.println("------------------");
        }
    }
}

class Factory {
    private final Random m_random;

    public Factory()
    {
        this(new Random());
    }

    public Factory(Random random)
    {
        m_random = random;
    }

    public A getRandomInstance()
    {
        int val = m_random.nextInt(3);
        A a;

        switch (val) {
            case 0:
                a = new C();
                break;
            case 1:
                a = new B();
                break;
            default:
                a = new A();
        }

        return a;
    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo()");
    }
}

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
    }

    public void bar(int a) //override
    {
        System.out.printf("B.bar(int):%02d%n", a);
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }

    public void bar(int a)
    {
        System.out.printf("A.bar(int):%02d%n", a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sanal metot dinamik türe ilişkin sınıfta override edilmemişse sırasıyla taba sınıflara bakılır. İlk bulunan
    metot çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        MyApplication.run();
    }
}

class MyApplication {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        Random r = new Random();
        Factory factory = new Factory(r);

        for (int i = 0; i < n; ++i) {
            A a = factory.getRandomInstance();

            a.foo();
            a.bar(r.nextInt(100));
            System.out.println("------------------");
        }
    }
}

class Factory {
    private final Random m_random;

    public Factory()
    {
        this(new Random());
    }

    public Factory(Random random)
    {
        m_random = random;
    }

    public A getRandomInstance()
    {
        int val = m_random.nextInt(3);
        A a;

        switch (val) {
            case 0:
                a = new C();
                break;
            case 1:
                a = new B();
                break;
            default:
                a = new A();
        }

        return a;
    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo()");
    }

    public void bar(int a) //override
    {
        System.out.printf("C.bar(int):%02d%n", a);
    }
}

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }

    public void bar(int a)
    {
        System.out.printf("A.bar(int):%02d%n", a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sanal metot dinamik türe ilişkin sınıfta override edilmemişse sırasıyla taba sınıflara bakılır. İlk bulunan
    metot çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        MyApplication.run();
    }
}

class MyApplication {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        Random r = new Random();
        Factory factory = new Factory(r);

        for (int i = 0; i < n; ++i) {
            A a = factory.getRandomInstance();

            a.foo();
            a.bar(r.nextInt(100));
            System.out.println("------------------");
        }
    }
}

class Factory {
    private final Random m_random;

    public Factory()
    {
        this(new Random());
    }

    public Factory(Random random)
    {
        m_random = random;
    }

    public A getRandomInstance()
    {
        int val = m_random.nextInt(3);
        A a;

        switch (val) {
            case 0:
                a = new C();
                break;
            case 1:
                a = new B();
                break;
            default:
                a = new A();
        }

        return a;
    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo()");
    }
}

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }

    public void bar(int a)
    {
        System.out.printf("A.bar(int):%02d%n", a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bazen override edilen metot içerisinde taban sınıfının ilgili metodunun da çağrılması gerekebilir. Bu super referansı
    ile yapılabilir. Bu işlem mantıksal olarak bir davranışın eski davranışla beraber yeni eklentilerinin de olduğu
    anlamına gelir. Buna "augmentation" da denilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        MyApplication.run();
    }
}

class MyApplication {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        Random r = new Random();
        Factory factory = new Factory(r);

        for (int i = 0; i < n; ++i) {
            A a = factory.getRandomInstance();

            a.foo();
            System.out.println("------------------");
        }
    }
}

class Factory {
    private final Random m_random;

    public Factory()
    {
        this(new Random());
    }

    public Factory(Random random)
    {
        m_random = random;
    }

    public A getRandomInstance()
    {
        int val = m_random.nextInt(3);
        A a;

        switch (val) {
            case 0:
                a = new C();
                break;
            case 1:
                a = new B();
                break;
            default:
                a = new A();
        }

        return a;
    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo()");
        super.foo(); //augmentation
    }
}

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
        super.foo(); //augmentation
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki koda D sınıfı eklenmesine rağmen yine müşteri kodlar etkilenmemiştir. Ayrıca senaryo olarak taban sınıfın
    ilgili metodunun çağrılması kuralı varsa D sınıfı da bu kurala uygun olarak yazılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        MyApplication.run();
    }
}

class MyApplication {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        Random r = new Random();
        Factory factory = new Factory(r);

        for (int i = 0; i < n; ++i) {
            A a = factory.getRandomInstance();

            a.foo();
            System.out.println("------------------");
        }
    }
}

class Factory {
    private final Random m_random;

    public Factory()
    {
        this(new Random());
    }

    public Factory(Random random)
    {
        m_random = random;
    }

    public A getRandomInstance()
    {
        int val = m_random.nextInt(4);
        A a;

        switch (val) {
            case 0:
                a = new C();
                break;
            case 1:
                a = new B();
                break;
            case 2:
                a = new D();
                break;
            default:
                a = new A();
        }

        return a;
    }
}

class D extends C {
    public void foo() //override
    {
        System.out.println("D.foo()");
        super.foo(); //augmentation
    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo()");
        super.foo(); //augmentation
    }
}

class B extends  A {
    public void foo() //override
    {
        System.out.println("B.foo()");
        super.foo(); //augmentation
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo()");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    CompanyApp örneği
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.company.CompanyApp;

class App {
    public static void main(String [] args)
    {
        CompanyApp.run();
    }
}


package org.csystem.app.samples.company;

public class Employee {
    private String m_name;
    private String m_citizenId;
    private String m_address;

    //...

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        //...
        m_citizenId = citizenId;
    }

    public String getAddress()
    {
        return m_address;
    }

    public void setAddress(String address)
    {
        //...
        m_address = address;
    }

    public double calculateInsurancePayment()
    {
        return 0;
    }
    //...
}

package org.csystem.app.samples.company;

public class HumanResources {
    //...
    public void payInsurance(Employee employee)
    {
        System.out.println("---------------------");
        System.out.printf("Name:%s%n", employee.getName());
        System.out.printf("Citizen Id:%s%n", employee.getCitizenId());
        System.out.printf("Payment:%f%n", employee.calculateInsurancePayment());
        System.out.println("---------------------");
    }
}

package org.csystem.app.samples.company;

public final class CompanyApp {
    private CompanyApp()
    {
    }

    public static void run()
    {
        HumanResources hr = new HumanResources();
        Manager m = new Manager();

        m.setName("Ali");
        m.setAddress("Mecidiyeköy");
        m.setCitizenId("12345678912");
        m.setSalary(20000);
        m.setDepartment("Yazılım");

        Worker w = new Worker();

        w.setName("Veli");
        w.setAddress("Şişli");
        w.setCitizenId("12345677912");
        w.setFeePerHour(100);
        w.setHourPerDay(8);

        SalesManager sm = new SalesManager();

        sm.setName("Ayşe");
        sm.setAddress("Beylikdüzü");
        sm.setCitizenId("12345678916");
        sm.setSalary(20000);
        sm.setDepartment("Yazılım");
        sm.setExtra(1200.34);

        ProjectWorker pw = new ProjectWorker();

        pw.setName("Zeynep");
        pw.setAddress("Fatih");
        pw.setCitizenId("12345577912");
        pw.setFeePerHour(89.78);
        pw.setHourPerDay(8);
        pw.setProjectName("network system");
        pw.setRatio(20.5);

        hr.payInsurance(m);
        hr.payInsurance(w);
        hr.payInsurance(sm);
        hr.payInsurance(pw);
    }
}

package org.csystem.app.samples.company;

public class Manager extends Employee {
    private double m_salary;
    private String m_department;

    //...

    public double getSalary()
    {
        return m_salary;
    }

    public void setSalary(double salary)
    {
        //...
        m_salary = salary;
    }

    public String getDepartment()
    {
        return m_department;
    }

    public void setDepartment(String department)
    {
        //...
        m_department = department;
    }

    public double calculateInsurancePayment()
    {
        return m_salary * 1.5;
    }

    //...
}

package org.csystem.app.samples.company;

public class Worker extends Employee {
    private int m_hourPerDay;
    private double m_feePerHour;

    //...

    public int getHourPerDay()
    {
        return m_hourPerDay;
    }

    public void setHourPerDay(int hourPerDay)
    {
        //...
        m_hourPerDay = hourPerDay;
    }

    public double getFeePerHour()
    {
        return m_feePerHour;
    }

    public void setFeePerHour(double feePerHour)
    {
        //...
        m_feePerHour = feePerHour;
    }

    public double calculateInsurancePayment()
    {
        return m_feePerHour * m_hourPerDay * 30;
    }
}

package org.csystem.app.samples.company;

public class ProjectWorker  extends Worker {
    private String m_projectName;
    private double m_ratio;
    //...

    public String getProjectName()
    {
        return m_projectName;
    }

    public void setProjectName(String projectName)
    {
        //...
        m_projectName = projectName;
    }

    public double getRatio()
    {
        return m_ratio;
    }

    public void setRatio(double ratio)
    {
        //...
        m_ratio = ratio;
    }

    public double calculateInsurancePayment()
    {
        double payment = super.calculateInsurancePayment();

        return payment + payment * m_ratio;
    }

    //...
}

package org.csystem.app.samples.company;

public class SalesManager extends Manager {
    private double m_extra;

    //...

    public double getExtra()
    {
        return m_extra;
    }

    public void setExtra(double extra)
    {
        //...
        m_extra = extra;
    }

    public double calculateInsurancePayment()
    {
        return super.calculateInsurancePayment() + m_extra;
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Object sınıfının toString metodu nesneye ilişkin tekil (unique) bir bilgiyi yazı olarak döndürür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        System.out.println(s.toString());
        System.out.println(k.toString());
    }
}

class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Object sınııfnın toString metodu sanal bir mettotur. Bir nesnenin yazısal karşılığı olması durumunda ı sınıf için
    toString override edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Object o1 = new Sample();
        Object o2 = new Sample();

        System.out.println(o1.toString());
        System.out.println(o2.toString());
    }
}

class Sample {
    public String toString()
    {
        return "Sample";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    print ve println metotlarının Object parametreli overload'ları ekrana basacakları yazı için toString metodunu
    çağırırlar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;
import org.csystem.util.math.Fraction;

class App {
    public static void main(String [] args)
    {
        Date date = new Date(10, 9, 1976);
        Fraction fraction = new Fraction(3, -5);
        Time time = new Time();

        System.out.println(date);
        System.out.println(fraction);
        System.out.println(time);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    printf metodu (dolayısıyla String sınıfının format metodu) s format karakterine karşılık gelen yazı için toString
    metodunu çağırır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;
import org.csystem.util.math.Fraction;

class App {
    public static void main(String [] args)
    {
        Date date = new Date(10, 9, 1976);
        Fraction fraction = new Fraction(3, -5);
        Time time = new Time();

        System.out.printf("Tarih:%s%n", date);
        System.out.printf("Kesir:%s%n", fraction);
        System.out.printf("Zaman:%s%n", time);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte otomatik kutulama yapılmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int a = 10;
        double b = 20;
        boolean c = true;

        System.out.printf("a = %s, b = %s, c = %s%n", a, b, c);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte int türü için  yazı elde etme işlemi önce auto-baxing sonra da toString metodu çağrılarak
    yapılır. Yani derleyici aşağıdaki koda benzer bir kod üretir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int a = 10;
        String s = "Değer:" + a; //"Değer:" + Integer.valueOf(a).toString()

        System.out.println(s);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte referanslara ilişkin türler için toString metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;
import org.csystem.util.datetime.Time;
import org.csystem.util.math.Fraction;

class App {
    public static void main(String [] args)
    {
        Date date = new Date(10, 9, 1976);
        Fraction fraction = new Fraction(3, -5);
        Time time = new Time();

        String sDate = "Tarih:" + date; //"Tarih:" + date.toString()
        String sFraction = "Kesir:" + fraction; //"Kesir:" + fraction.toString()
        String sTime = "Zaman:" + time; //"Zaman:" + time.toString()

        System.out.println(sDate);
        System.out.println(sFraction);
        System.out.println(sTime);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının toString metodu [] içerisindeki yazıları elde etmek için toString metodunu çağırır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList();
        ArrayList dates = new ArrayList();

        numbers.add(20); //auto-boxing
        numbers.add(230); //auto-boxing

        dates.add(new Date());
        dates.add(new Date(21, 3, 2021));
        dates.add(new Date(12, 4, 2010));

        System.out.println(numbers);
        System.out.println(dates);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfının toString metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.collection.CSDArrayList;
import org.csystem.util.datetime.Date;

class App {
    public static void main(String [] args)
    {
        CSDArrayList numbers = new CSDArrayList();
        CSDArrayList dates = new CSDArrayList();
        CSDArrayList names = new CSDArrayList();

        numbers.add(20);
        numbers.add(230);

        dates.add(new Date());
        dates.add(new Date(21, 3, 2021));
        dates.add(new Date(12, 4, 2010));

        System.out.println(numbers);
        System.out.println(dates);
        System.out.println(names);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.collection;

public class CSDArrayList {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void doWorkForIllegalArgumentException(String message)
    {
        System.out.println(message);
        System.exit(-1);
    }

    private static void doWorkForIndexOutOfBoundsException(String message)
    {
        System.out.println(message);
        System.exit(-1);
    }

    private static void checkCapacityValue(int capacity)
    {
        if (capacity < 0)
            doWorkForIllegalArgumentException("Capacity can not be negative");
    }

    private void checkIndex(int index)
    {
        if (index < 0 || index >= m_index)
            doWorkForIndexOutOfBoundsException("Index out of bounds");
    }

    private void changeCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        System.arraycopy(m_elems, 0, temp, 0, m_index);

        m_elems = temp;
    }

    public CSDArrayList()
    {
        m_elems = new Object[DEFAULT_CAPACITY];
    }

    public CSDArrayList(int capacity)
    {
        checkCapacityValue(capacity);
        m_elems = new Object[capacity];
    }

    public boolean add(Object elem)
    {
        if (m_elems.length == m_index)
            changeCapacity(m_elems.length == 0 ? 1 : m_elems.length * 2);

        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, Object elem)
    {
        //TODO:
    }

    public int capacity()
    {
        return m_elems.length;
    }

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public void ensureCapacity(int capacity)
    {
        if (capacity < m_elems.length)
            return;

        changeCapacity(Math.max(m_elems.length * 2, capacity));
    }

    public Object get(int index)
    {
        checkIndex(index);

        return m_elems[index];
    }

    public Object set(int index, Object elem)
    {
        checkIndex(index);
        Object oldElem = m_elems[index];

        m_elems[index] = elem;

        return oldElem;
    }


    private Object remove(int index)
    {
        //TODO:
        Object oldVal = m_elems[index];

        //TODO:

        return oldVal;
    }

    public int size()
    {
        return m_index;
    }

    public void trimToSize()
    {
        if (m_index != m_elems.length)
            changeCapacity(m_index);
    }

    public String toString()
    {
        String str = "[";

        for (int i = 0; i < m_index; ++i) {
            if (str.length() != 1)
                str += ", ";

            str += m_elems[i];
        }

        return str + "]";
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ParserApp örneği
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.parser.ParserApp;

class App {
    public static void main(String [] args)
    {
        ParserApp.run();
    }
}


package org.csystem.app.samples.parser;

import java.util.Scanner;

public final class ParserApp {
    private ParserApp()
    {
    }
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Parser parser = new Parser();

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String s = kb.nextLine();

            if ("elma".equals(s))
                break;

            StringSource ss = new StringSource(s);
            CharArraySource cs = new CharArraySource(s.trim());

            parser.setSource(ss);

            int digitsCount = parser.doParseForDigits();
            int whitespacesCount = parser.doParseForWhitespaces();

            System.out.printf("Rakam sayısı:%d%n", digitsCount);
            System.out.printf("Boşluk sayısı:%d%n", whitespacesCount);
            System.out.println("--------------------------------------");

            parser.setSource(cs);

            digitsCount = parser.doParseForDigits();
            whitespacesCount = parser.doParseForWhitespaces();

            System.out.printf("Rakam sayısı:%d%n", digitsCount);
            System.out.printf("Boşluk sayısı:%d%n", whitespacesCount);
            System.out.println("--------------------------------------");
        }
    }
}

package org.csystem.app.samples.parser;

public class Parser {
    private Source m_source;

    public Parser()
    {
    }

    public Parser(Source source)
    {
        setSource(source);
    }

    public void setSource(Source source)
    {
        //...
        m_source = source;
    }

    public int doParseForDigits()
    {
        m_source.reset();
        int count = 0;
        int c;

        while ((c = m_source.getNextChar()) != -1)
            if (Character.isDigit(c))
                ++count;

        return count;
    }

    public int doParseForWhitespaces()
    {
        m_source.reset();
        int count = 0;
        int c;

        while ((c = m_source.getNextChar()) != -1)
            if (Character.isWhitespace(c))
                ++count;

        return count;
    }
    //...
}

package org.csystem.app.samples.parser;

public class Source {
    public int getNextChar()
    {
        return -1;
    }

    public void reset()
    {
    }
}

package org.csystem.app.samples.parser;

public class StringSource extends Source {
    private final String m_str;
    private int m_index;

    public StringSource(String str)
    {
        m_str = str;
    }

    public int getNextChar()
    {
        return m_index == m_str.length() ? -1 : m_str.charAt(m_index++);
    }

    public void reset()
    {
        m_index = 0;
    }
}

package org.csystem.app.samples.parser;

public class CharArraySource extends Source {
    private final char [] m_chars;
    private int m_index;

    public CharArraySource(String str)
    {
        this(str.toCharArray());
    }

    public CharArraySource(char [] chars)
    {
        m_chars = chars;
    }

    public int getNextChar()
    {
        return m_index == m_chars.length ? -1 : m_chars[m_index++];
    }

    public void reset()
    {
        m_index = 0;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    01.05.2021
    Bazı durumlarda bir sınıf bir kavramı soyut olarak temsil ediyor olabilir. Bu durumda sınıfın tek başına
    anlamı yoktur. Yani nesne yönelimli programlama bakış açısıyla o sınıf türünden nesnenin tek başına anlamı yoktur. Ancak
    o sınıftan türeyen sınıfların nesne olarak anlamı vardır. Bu tarz sınıflara soyut (abstract) sınıflar denir.
    Soyut olmayan sınıflara da somut (concrete) sınıflar denir. Bu tip durumlarda sınıfın soyut (abstract) bildirilmesi
    daha uygundur.Örneğin CompanyApp uygulamasında Employee sınıfı tek başına anlamlı değildir ancak soyut olarak
    "çalışan kavramını" temsil eder. Employee sınıfından türetilen sınıflar nesne olarak anlamlıdır. Yani Employee
    sınıfından türemiş olan sınıflar somut (concrete) sınıflardır

    Bu durumda programcı abstract bir sınıf gördüğünde "bu sınıftan türetme yapmam gerekiyor varsa abstract metotları
    override etmem gerekiyor" anlamalıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Soyut bir sınıf abstract anahtar sözcüğü ile bildirilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

abstract class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın abstract metotları olabilir. abstract metotlar gövdesi olmayan metotlardır. Bu metotlara gövde yazımı
    error oluşturur. abstract metotlar abstract anahtar sözcüğü ile bildirilir. Bu metotlar sanaldır. Dolayısıyla
    override edilebilir. En az bir tane abstract metodu olan bir sınıf abstract olarak bildirilmelidir.
    Aksi durumda error oluşur. Dikkat edilirse abstract bir sınıfın abstract bir metodu olmak zorunda değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

abstract class A {
    public abstract void foo() //error
    {
    }

}

class Mample { //error
    public abstract void bar();
}

abstract class Sample {
    public abstract void foo();
    public abstract void tar();

    public void bar()
    {}
}

abstract class Test {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıf türünden bir nesne new operatörü ile yaratılamaz. new işlemi sınıf içerisinde de yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error
	}
}

abstract class Sample {
	public abstract void foo();
	public abstract void tar();

	public void bar()
	{
		Sample s = new Sample(); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıfların da non-static veri elemanları olabilir. abstract sınıfların abstract olmayan metotları da
    olabilir. Yani abstract olma özellikler dışında concrete bir sınıftan farkı yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

abstract class Sample {
    private int m_x;
    public abstract void foo();
    public abstract void tar();

    static {
        //...
    }

    {
        //....
    }
    public void bar()
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract bir sınıftan türetilmiş olan bir sınıf taban sınıfının en az bir tane abstract metodunu override etmezse
    türemiş sınıf da abstract olarak bildirilmek zorundadır. Sınıf içerisinde hiç abstract metot kalmadıysa bu durumda
    sınıf concrete olabilir. Şüphesiz aşağıdaki örnekte E sınıfının A'nın tüm metotlarını override etmiş olmasına
    rağmen conrete olma zorunluluğu yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

abstract class E extends A {
	public void foo()
	{
		//...
	}

	public void bar()
	{
		//...
	}
}

class C extends A {
	public void foo()
	{
		//...
	}
	public void bar()
	{
		//...
	}
}

abstract class D extends A {
	public void foo()
	{
		//...
	}
}

class B extends A { //error
	public void foo()
	{
		//...
	}
}

abstract class A {
	public abstract void foo();
	public abstract void bar();
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki durumda C sınıfında artık hiç abstract metot kalmadığından concrete olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class C extends B {
    public void bar()
    {
        //...
    }
}

abstract class B extends A {
    public void foo()
    {
        //...
    }
}

abstract class A {
    public abstract void foo();
    public abstract void bar();
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıf referanslarının taban sınıf referansı olarak kullanımı anlamlıdır. Bu durumda polymoprhism' de
    abstract sınıflarla yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A x = new C();

		x.foo();
		x.bar();
	}
}

class C extends B {
	public void bar()
	{
		System.out.println("C.bar");
	}
}

abstract class B extends A {
	public void foo()
	{
		System.out.println("B.foo");
	}
}

abstract class A {
	public abstract void foo();
	public abstract void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıflarda ctor olabilir. abstract sınıfların ctor'larının public yapılması anlamsızdır. public yerine
    protected yapılması okunabilirlik açısından daha uygundur. private ve no-modifier erişimcilerin ctor açısından
    anlamı olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		B b = new B(10, 20);

		//..
	}
}

class B extends A {
	private int m_y;

	public B(int x, int y)
	{
		super(x);
		m_y = y;
	}

	public void foo()
	{

	}
}

abstract class A {
	private int m_x;

	private A()
	{
		//...
	}

	protected A(int x)
	{
		this();
		m_x = x;
	}

	public int getX()
	{
		return m_x;
	}

	public void setX(int x)
	{
		m_x = x;
	}

	public abstract void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıflar final olarak bildirilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

abstract final class A { //error

}

/*----------------------------------------------------------------------------------------------------------------------
    Şüphesiz bir sınıf başka bir sınıftan türetilip abstract olmayacaksa final bildirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

final class B extends A {
	//...
}

abstract class A {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
    CompanyApp uygulaması
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.company.CompanyApp;

class App {
    public static void main(String [] args)
    {
        CompanyApp.run();
    }
}


package org.csystem.app.samples.company;

public final class CompanyApp {
    private CompanyApp()
    {
    }

    public static void run()
    {
        HumanResources hr = new HumanResources();
        Manager m = new Manager();

        m.setName("Ali");
        m.setAddress("Mecidiyeköy");
        m.setCitizenId("12345678912");
        m.setSalary(20000);
        m.setDepartment("Yazılım");

        Worker w = new Worker();

        w.setName("Veli");
        w.setAddress("Şişli");
        w.setCitizenId("12345677912");
        w.setFeePerHour(100);
        w.setHourPerDay(8);

        SalesManager sm = new SalesManager();

        sm.setName("Ayşe");
        sm.setAddress("Beylikdüzü");
        sm.setCitizenId("12345678916");
        sm.setSalary(20000);
        sm.setDepartment("Yazılım");
        sm.setExtra(1200.34);

        ProjectWorker pw = new ProjectWorker();

        pw.setName("Zeynep");
        pw.setAddress("Fatih");
        pw.setCitizenId("12345577912");
        pw.setFeePerHour(89.78);
        pw.setHourPerDay(8);
        pw.setProjectName("network system");
        pw.setRatio(20.5);

        hr.payInsurance(m);
        hr.payInsurance(w);
        hr.payInsurance(sm);
        hr.payInsurance(pw);
    }
}

package org.csystem.app.samples.company;

public abstract class Employee {
    private String m_name;
    private String m_citizenId;
    private String m_address;

    //...

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        //...
        m_citizenId = citizenId;
    }

    public String getAddress()
    {
        return m_address;
    }

    public void setAddress(String address)
    {
        //...
        m_address = address;
    }

    public abstract double calculateInsurancePayment();
    //...
}

package org.csystem.app.samples.company;

public class HumanResources {
    //...
    public void payInsurance(Employee employee)
    {
        System.out.println("---------------------");
        System.out.printf("Name:%s%n", employee.getName());
        System.out.printf("Citizen Id:%s%n", employee.getCitizenId());
        System.out.printf("Payment:%f%n", employee.calculateInsurancePayment());
        System.out.println("---------------------");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ParserApp uygulaması
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.parser.ParserApp;

class App {
    public static void main(String [] args)
    {
        ParserApp.run();
    }
}


package org.csystem.app.samples.parser;

public abstract class Source {
    public abstract int getNextChar();
    public abstract void reset();
}

package org.csystem.app.samples.parser;

import java.util.Scanner;

public final class ParserApp {
    private ParserApp()
    {
    }
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Parser parser = new Parser();

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String s = kb.nextLine();

            if ("elma".equals(s))
                break;

            StringSource ss = new StringSource(s);
            CharArraySource cs = new CharArraySource(s.trim());

            parser.setSource(ss);

            int digitsCount = parser.doParseForDigits();
            int whitespacesCount = parser.doParseForWhitespaces();

            System.out.printf("Rakam sayısı:%d%n", digitsCount);
            System.out.printf("Boşluk sayısı:%d%n", whitespacesCount);
            System.out.println("--------------------------------------");

            parser.setSource(cs);

            digitsCount = parser.doParseForDigits();
            whitespacesCount = parser.doParseForWhitespaces();

            System.out.printf("Rakam sayısı:%d%n", digitsCount);
            System.out.printf("Boşluk sayısı:%d%n", whitespacesCount);
            System.out.println("--------------------------------------");
        }
    }
}

package org.csystem.app.samples.parser;

public class Parser {
    private Source m_source;

    public Parser()
    {
    }

    public Parser(Source source)
    {
        setSource(source);
    }

    public void setSource(Source source)
    {
        //...
        m_source = source;
    }

    public int doParseForDigits()
    {
        m_source.reset();
        int count = 0;
        int c;

        while ((c = m_source.getNextChar()) != -1)
            if (Character.isDigit(c))
                ++count;

        return count;
    }

    public int doParseForWhitespaces()
    {
        m_source.reset();
        int count = 0;
        int c;

        while ((c = m_source.getNextChar()) != -1)
            if (Character.isWhitespace(c))
                ++count;

        return count;
    }
    //...
}

package org.csystem.app.samples.parser;

public class StringSource extends Source {
    private final String m_str;
    private int m_index;

    public StringSource(String str)
    {
        m_str = str;
    }

    public int getNextChar()
    {
        return m_index == m_str.length() ? -1 : m_str.charAt(m_index++);
    }

    public void reset()
    {
        m_index = 0;
    }
}

package org.csystem.app.samples.parser;

public class CharArraySource extends Source {
    private final char [] m_chars;
    private int m_index;

    public CharArraySource(String str)
    {
        this(str.toCharArray());
    }

    public CharArraySource(char [] chars)
    {
        m_chars = chars;
    }

    public int getNextChar()
    {
        return m_index == m_chars.length ? -1 : m_chars[m_index++];
    }

    public void reset()
    {
        m_index = 0;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    override işleminde erişim belirleyici erişim anlamında yükseltilebilir ancak düşürülemez. Bu durumda public bir
    sanal metot public olarak override edilmek zorundadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
	protected void foo() //error
	{

	}
}

abstract class A {
	public abstract void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
    override işleminde erişim belirleyici erişim anlamnında yükseltilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
    public void foo()
    {

    }
}

abstract class A {
    protected abstract void foo();
}


/*----------------------------------------------------------------------------------------------------------------------
    override işleminde erişim belirleyici erişim anlamında yükseltilebilir. Ancak bu durumda aşağıdaki gibi
    sınıfların da paket anlamında uygun yerlerinde olması gerekir. Erişim belirleyicilerinin anlamlarını hatırlayınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.B;

class App {
	public static void main(String [] args)
	{
		A x = new B();

		x.foo();
	}
}


package org.csystem.app;

public class A {
    void foo()
    {
        System.out.println("A.foo");
    }
}

package test;

import org.csystem.app.A;

public class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

package test;

import org.csystem.app.A;

public class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    final olarak bildirilmiş bir metot sanal değildir. Override edilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
    public void foo() //error
    {

    }
}

class A {
    public final void foo()
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    final olarak bildirilmiş bir metot sanal değildir. Override edilemez. Aşağıdaki örnekte B sınıfı foo metodunu
    override etmiştir. B foo'nun sanallığını kaldırdığında C sınıfında foo override edilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class C extends B {
	public void foo() //error
	{}
}

class B extends A {
	public final void foo()
	{
	}
}

abstract class A {
	public abstract void foo();
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    Java' da static bir metot türemiş sınıfta aynı geri dönüş değeri ve aynı imza ile ve erişim belirleyiciyi
    düşürmemek şartıyla yazılabilir. Bu durumda metot hangi sınıf ismi ile çağrılıyorsa o sınıfın metodu çağrılır.
    Bu durum her ne kadar override işlemini andırsa da "override" dendiğinde non-static bir metot anlaşılır. static
    metotlar için bu işleme bazı kaynaklar "static override" derler. Ancak unutulmamalıdır ki "override" non-static
    metotlar ve polymorphism için anlamlıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A.foo();
		B.foo();
	}
}

class B extends A {
	public static void foo()
	{
		System.out.println("B.foo");
	}
}

class A {
	public static void foo()
	{
		System.out.println("A.foo");
	}
}
/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte B sınıfının foo metodu içerisinde A sınıfının foo metodu çağrılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A.foo();
		B.foo();
	}
}

class B extends A {
	public static void foo()
	{
		System.out.println("B.foo");
		A.foo();
	}
}

class A {
	public static void foo()
	{
		System.out.println("A.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte x A türünden olduğundan ve foo' da static olduğundan A'nın foo metodu çağrılır.
    static bir metodun referans ile çağrılmasının sınıf ismi ile çağrılmasından farkı olmadığını hatırlayınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A x = new B();

		x.foo();
	}
}

class B extends A {
	public static void foo()
	{
		System.out.println("B.foo");
	}
}

class A {
	public static void foo()
	{
		System.out.println("A.foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte bir oyun sistemine ilişkin demo bir şablon hazırlanmıştır. Bu sisteme oyun olarak
	dahil olabilmek için AbstractGame isimli şablon (template) sınıftan türetme yapmak ve ilgili metotları
	override etmek gerekmektedir. Konunun daha fazla detayları vardır. Burada demo biçiminde ele alınmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.games.template.GameRunnerApp;

class App {
    public static void main(String [] args)
    {
        GameRunnerApp app = new GameRunnerApp();

        app.run();
    }
}

package org.csystem.games.template;

import org.csystem.games.ballfall.BallFallGame;
import org.csystem.games.craps.CrapsGame;
import org.csystem.games.zombie.WalkingDeadGame;

public class GameRunnerApp {
    private final GameController m_controller;

    private void initGames() // Bu metot oyunları da bilmeden yükleyebilir. Burada ele alınmayacaktır
    {
        m_controller.add(new WalkingDeadGame());
        m_controller.add(new BallFallGame());
        m_controller.add(new CrapsGame());
    }

    public GameRunnerApp()
    {
        m_controller = new GameController();
        this.initGames();
    }

    public void run()
    {
        m_controller.run();
    }
}

package org.csystem.games.template;

import java.util.ArrayList;
import java.util.Scanner;

public class GameController {
    private final ArrayList m_games = new ArrayList();

    private AbstractGame getGameByOption(int option)
    {
        return (AbstractGame)m_games.get(option);
    }

    private void displayMenu()
    {
        int size = m_games.size();

        System.out.println("Oyunlar:");
        for (int i = 0; i < size; ++i) {
            AbstractGame game = (AbstractGame)m_games.get(i);
            System.out.printf("%d.%s%n", i + 1, game.name);
        }

        System.out.printf("%d.Çıkış%n", size + 1);
        System.out.print("Oyun numarasını giriniz:");
    }

    public void add(AbstractGame game)
    {
        m_games.add(game);
    }

    public void run()
    {
        Scanner kb = new Scanner(System.in);

        int sizep1 = m_games.size() + 1;

        for (;;) {
            if (m_games.isEmpty()) {
                System.out.print("Lütfen oyun yükleyiniz:");
                break;
            }
            this.displayMenu();
            int option = Integer.parseInt(kb.nextLine());

            if (option < 0 || option > sizep1) {
                System.out.println("Geçersiz seçenek");
                continue;
            }

            if (option == sizep1)
                break;

            AbstractGame curGame = getGameByOption(option - 1);

            curGame.run();
        }
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.print("Tekrar yapıyor musunuz?");
    }
}

package org.csystem.games.zombie;

import org.csystem.games.template.AbstractGame;

public class WalkingDeadGame extends AbstractGame {

    public WalkingDeadGame()
    {
        super("walking dead game");
    }
    public void init()
    {
        System.out.println("WalkingDeadGame.init");
    }

    public void play()
    {
        System.out.println("WalkingDeadGame.play");
    }

    public void pause()
    {
        System.out.println("WalkingDeadGame.pause");
    }

    public void load()
    {
        System.out.println("WalkingDeadGame.load");
    }

    public void save()
    {
        System.out.println("WalkingDeadGame.save");
    }
    public void destruct()
    {
        System.out.println("WalkingDeadGame.destruct");
    }
}

package org.csystem.games.ballfall;

import org.csystem.games.template.AbstractGame;

import java.util.Scanner;

public class BallFallGame extends AbstractGame {
    private BallFall m_ballFallGame;
    private Scanner m_kb;

    public BallFallGame()
    {
        super("Homework-002");
    }

    public void init()
    {
        m_ballFallGame = new BallFall();
        m_kb = new Scanner(System.in);
    }

    public void play()
    {
        for (;;) {
            System.out.print("Width?");
            int width = Integer.parseInt(m_kb.nextLine());

            if (width <= 0)
                break;

            System.out.print("Height?");
            int height = Integer.parseInt(m_kb.nextLine());

            m_ballFallGame.play(width, height);

            System.out.println(m_ballFallGame.getShape());
            System.out.println("//////////////////////");
        }
    }

    public void pause()
    {
        System.out.println("BallFallGame.pause");
    }

    public void load()
    {
        System.out.println("BallFallGame.load");
    }

    public void save()
    {
        System.out.println("BallFallGame.save");
    }
    public void destruct()
    {
        System.out.println("BallFallGame.destruct");
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    BallFallGame sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.games.ballfall;

public class BallFall {
	private String m_shape;

	private static boolean updateRightFlag(int ballIndex, boolean isRight, int width)
	{
		if (ballIndex == 0)
			isRight = true;
		else if (ballIndex == width - 1)
			isRight = false;

		return isRight;
	}

	private static int updateBallIndex(boolean isRight, int ballIndex)
	{
		if (isRight)
			++ballIndex;
		else
			--ballIndex;

		return ballIndex;
	}


	private void fillSpace(int begin, int end)
	{
		for (int i = begin; i < end; ++i)
			m_shape += ' ';
	}

	private void fillBall(int ballIndex, int end)
	{
		fillSpace(0, ballIndex);
		m_shape += '*';
		fillSpace(ballIndex + 1, end);
	}

	public BallFall()
	{
		m_shape = "";
	}


	public String getShape()
	{
		return m_shape;
	}

	public void play(int width, int height)
	{
		int ballIndex = 0;
		boolean isRight= true;

		m_shape = "";
		for (int i = 1; i <= height; ++i) {
			m_shape += '|';
			fillBall(ballIndex, width);
			isRight = updateRightFlag(ballIndex, isRight, width);

			if (width != 1)
				ballIndex = updateBallIndex(isRight, ballIndex);

			m_shape += "|\n";
		}

		m_shape = m_shape.substring(0, m_shape.length() - 1);
	}
}


package org.csystem.games.craps;

import org.csystem.games.ballfall.BallFall;
import org.csystem.games.template.AbstractGame;

import java.util.Scanner;

public class CrapsGame extends AbstractGame {
    private Craps m_craps;
    private Scanner m_kb;
    public CrapsGame()
    {
        super("Craps simulation");
    }

    public void init()
    {
        System.out.println("Designed and implemented by Mert Çelik");
        m_craps = new Craps();
        m_kb = new Scanner(System.in);
    }

    public void play()
    {
        for (;;) {
            System.out.print("Kaç kez oynamak istersiniz?");
            int n = Integer.parseInt(m_kb.nextLine());

            if (n <= 0)
                break;

            int count = 0;

            for (int i = 0; i < n; ++i) {
                m_craps.play();
                if (m_craps.isWin())
                    ++count;
            }

            System.out.printf("p = %f%n", (double)count / n);
        }
    }

    public void pause()
    {
        System.out.println("BallFallGame.pause");
    }

    public void load()
    {
        System.out.println("BallFallGame.load");
    }

    public void save()
    {
        System.out.println("BallFallGame.save");
    }
    public void destruct()
    {
        System.out.println("Designed and implemented by Mert Çelik");
    }
}

/*--------------------------------------------------------------------------------------------------------------------
    Craps sınıfı
---------------------------------------------------------------------------------------------------------------------*/
package org.csystem.games.craps;

import java.util.Random;

public class Craps {
	private boolean m_win;
	private final Random m_random;

	public int total()
	{
		return m_random.nextInt(6) + 1 + m_random.nextInt(6) + 1;
	}

	public void doWorkForIndeterminite(int sum)
	{
		int newSum;

		while ((newSum = total()) != sum)
			if (newSum == 7)
				break;

		m_win = newSum == sum;
	}

	public void doWorkForSum(int sum)
	{
		switch (sum) {
		case 7:
		case 11:
			m_win = true;
			break;
		case 2:
		case 3:
		case 12:
			m_win = false;
			break;
		default:
			doWorkForIndeterminite(sum);
		}
	}

	public Craps()
	{
		m_random = new Random();
	}

	public boolean isWin()
	{
		return m_win;
	}

	public void play()
	{
		doWorkForSum(total());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    02.05.2021
    Exception İşlemleri:
    Exception programlamada genel olarak çalışma zamanında oluşan hatalara denir. Ancak bazen bir exeception hata
    durumuna ilişkin olmayabilir. Exception oluştuğunda programın nasıl devam edeceğinin belirlenmesine
    "exception handling" denir. Örneğin, bir yön bulma uygulamasında uygulamanın GPS sensöründen bilgi alamaması
    durumu bir exception durumudur. Bu durumda program bunu kullanıcıya belirterek uygulamanın devam etmesini
    sağlayabilir.

    Java' da exception işlemleri için aşağıdaki anahtar sözcükler kullanılır:
    try, catch, throw, finally, throws

    Bir exception throw anahtar sözcüğü ile fırlatılabilir. throw anahtar sözcüğünün kullanımının genel biçimi şöyledir:

    throw <referans>;

    throw anahtar sözcüğü bir referans alır. throw anahtar sözcüğünün aldığı referansın Throwable sınıfından doğrudan
    ya da dolaylı olarak türemiş bir sınıf türünden olması gerekir.

    Bir exception fırlatıldığında akış exception'ın fırlatıldığı metottan çıkar.

    Bir exception yakalanamaz ise bu durumda exception ın fırlatıldığı akış (thread) sonlanır.

    Akış exception bakımından ele alınacaksa (handling) try bloğu içerisinde yazılmalıdır. try bloğu
    catch bloğu veya blokları veya tek başına finally bloğu veya catch blokları ve finally bloğu
    ile devam edebilir. try bloğu tek başına olamaz. try bloğu tüm diğer blokları ile birlikte tek bir deyimdir.
    try bloğu ile birlikte bulunan diğer bloklar arasında herhangi bir deyim yazılamaz.

    catch bloğunun parantezi içerisinde yazılan parametreye catch parametresi denir. catch parametresine
    ilişkin türün bir exception sınıfı yani Throwable'dan doğrudan ya da dolaylı olarak türetilmiş bir sınıf türünden
    olması gerekir.

    Exception oluşursa (fırlatılırsa) akış try bloğundan bir daha geri dönmemek üzere (non-resumptive) catch bloklarına
    sıçrar. catch blokları yukarıdan aşağıya switch deyimi gibi teker teker kontrol edilir. Uygun catch bloğu bulunursa
    o catch bloğu çalıştırılır. Uygun catch bloğu fırlatılan exception nesnesinin adresinin (referansının) ilgili catch
    parametresine doğrudan atanabildiği ilk catch bloğudur. Exception yakalanırsa yakalanan catch bloğuna ilişkin kodlar
    çalıştırılır. Kodlar bitince tüm diğer catch blokları atlanarak akış devam eder. Eğer exception hiç yakalanamazsa akış
    sonlanır. Yani bir catch bloğu çalıştırılırsa diğer catch blokları çalıştırılmaz. try bloğu exception oluşmadan sonlanırsa
    tüm catch blokları atlanarak akış devam eder.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
     Aşağıdaki örnekte MyException sınıfı doğrudan ya da dolaylı olarak Throwable sınıfından türetilmediği için
     throw' a referans olarak verilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class MathUtil {
    public static double myLog(double val)
    {
        if (val <= 0) {
            MyException ex = new MyException();

            throw ex; //error
        }

        //...
    }

}

class MyException {

}

/*----------------------------------------------------------------------------------------------------------------------
    Bir exception fırlatılması
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        System.out.printf("log(%f)=%f%n", val, MathUtil.myLog(val));
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val <= 0) {
            MyException ex = new MyException();

            throw ex;
        }

        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    throw ile o an nesne yaratılarak fırlatılmasına ilişkin ifade çok sık kullanılmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        System.out.printf("log(%f)=%f%n", val, MathUtil.myLog(val));
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val <= 0)
            throw new MyException();

        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    try-catch blokları: Örnekte parseDouble metodunun fırlattığı exception'ın yakalanamadığına dolayısıyla bu exception
    fırlatıldığında akışın sonlandığına dikkat ediniz. Kodu çeşitli sayılarla test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double val = Double.parseDouble(kb.nextLine());

		try {
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) {
			System.out.println("My Excepion yakalandı");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val <= 0)
			throw new MyException();

		return Math.log(val);
	}
}

class MyException extends RuntimeException {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    try-catch blokları: Örnekte parseDouble metodunun fırlattığı exception'ın yakalanamadığına dolayısıyla bu exception
    fırlatıldığında akışın sonlandığına dikkat ediniz. Kodu çeşitli sayılarla test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double val = Double.parseDouble(kb.nextLine());

		try {
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) {
			System.out.println("My Exception yakalandı");
		}
		catch (YourException ex) {
			System.out.println("Your Excepion yakalandı");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException();

		if (val == 0)
			throw new YourException();

		return Math.log(val);
	}
}


class MyException extends RuntimeException {
	//...
}

class YourException extends RuntimeException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
    Taban sınıf parametreli catch bloğu o sınıftan türemiş olan sınıflara ilişkin exception nesnelerini yakalayabilir.
    Bu işlem aslında bir upcasting işlemidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		double val = Double.parseDouble(kb.nextLine());

		try {
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) {
			System.out.println("My Exception yakalandı");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException();

		if (val == 0)
			throw new YourException();

		return Math.log(val);
	}
}


class MyException extends RuntimeException {
	//...
}

class YourException extends MyException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf parametreli catch bloğu taban sınıf parametreli catch bloğundan sonra yazılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double val = Double.parseDouble(kb.nextLine());

		try {
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) {
			System.out.println("My Exception yakalandı");
		}
		catch (YourException ex) { //error
			System.out.println("Your Exception yakalandı");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException();

		if (val == 0)
			throw new YourException();

		return Math.log(val);
	}
}


class MyException extends RuntimeException {
	//...
}

class YourException extends MyException {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf exception parametreli catch bloğu taban sınıf parametreli catch bloğundan önce yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        try {
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (YourException ex) {
            System.out.println("Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("My Exception yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends MyException {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir kod paraçasının try bloğu içerisine alınması o kod parçasının fırlattığı exception'ın yakalanacağı
    anlamına gelmez. Fırlatıldıktan sonra uygun catch bloğunun bulunması gerekir. Aksi durumda akış sonlanır.
    Bu durumda aslında akış hemen sonlanmaz. Detaylar ileride ele alınacaktır. Aşağıdaki örnekte parseDouble metodunun
    fırlattığı exception nesnesini yakalayabilecek bir catch bloğu bulunamadığından akış sonlanır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (YourException ex) {
            System.out.println("Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("My Exception yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();

        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends MyException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Throwable parametreli catch bloğu tüm fırlatılan exception nesnelerini yakalayabilir. Şüphesiz Throwable parametreli
    catch bloğunun tüm catch bloklarından sonra yazılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (YourException ex) {
			System.out.println("Your Exception yakalandı");
		}
		catch (MyException ex) {
			System.out.println("My Exception yakalandı");
		}
		catch (Throwable ex) {
			System.out.println("Exception yakalandı");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException();

		if (val == 0)
			throw new YourException();


		return Math.log(val);
	}
}


class MyException extends RuntimeException {
	//...
}

class YourException extends MyException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir try bloğu içerisinde bir exception yakalanamaz ise o try bloğunu kapsayan try bloğunun catch bloklarına
    bakılır. Bu işlem uygun catch bloğu bulununcaya veya bulunamayıncaya kadar devam eder. Bulunursa uygun catch bloğu
    çalıştırılır bulunamazsa akış sonlanır. Eğer bir exception try bloğu içerisinde yakalanmışsa kapsayan try bloklarının
    catch bloklarına bakılmaz. Aşağıdaki örneği çeşitli girdiler ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Sample.foo();
			System.out.println("main:try sonu");
		}
		catch (YourException ex) {
			System.out.println("main:Your Exception yakalandı");
		}
		catch (MyException ex) {
			System.out.println("main:My Exception yakalandı");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Sample {
	public static void foo()
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) {
			System.out.println("foo:My Exception yakalandı");
		}

		System.out.println("foo sonu");
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException();

		if (val == 0)
			throw new YourException();

		return Math.log(val);
	}
}


class MyException extends RuntimeException {
	//...
}

class YourException extends RuntimeException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte foo metodu MyException fırlatıldığında onu yakalamış ve aynı nesneyi yeniden fırlatmıştır.
    Bu işleme "rethow" denir.

    Aşağıdaki örnekte foo metodu müşteri kodları açısından MyException da fırlatabilir. Bu foo için oluşturulacak
    dökümanda yazılır. foo metodunu yazan açısından ise Myexception hem ilgili try bloğunda işlenmiş hem de aynı exception
    nesnesi müşteri koda fırlatılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Sample.foo();
            System.out.println("main:try sonu");
        }
        catch (YourException ex) {
            System.out.println("main:Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("main:My Exception yakalandı");
        }
        catch (Throwable ex) {
            System.out.println("main:Throwable yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static void foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("foo:My Exception yakalandı");
            throw ex; //rethrow
        }

        System.out.println("foo sonu");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}
/*----------------------------------------------------------------------------------------------------------------------
    finally bloğu try bloğundan nasıl çıkılırsa çıkılsın çalıştırılacak bloktur. finally bloğu try bloğunda catch
    blokları ile birlikte olacaksa tüm catch bloklarının sonunda olmalıdır. Aşağıdaki örneği çeşitli değerler girerek
    çalıştırınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Sample.foo();
            System.out.println("main:try sonu");
        }
        catch (YourException ex) {
            System.out.println("main:Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("main:My Exception yakalandı");
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static void foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("foo:My Exception yakalandı");
        }
        finally {
            System.out.println("foo:finally");
        }

        System.out.println("foo sonu");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    finally bloğu try bloğundan nasıl çıkılırsa çıkılsın çalıştırılacak bloktur. finally bloğu try bloğunda catch
    blokları ile birlikte olacaksa tüm catch bloklarının sonunda olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			double result = Sample.foo();

			System.out.printf("result:%f%n", result);
		}
		catch (YourException ex) {
			System.out.println("main:Your Exception yakalandı");
		}
		catch (MyException ex) {
			System.out.println("main:My Exception yakalandı");
		}
		finally {
			System.out.println("main:finally");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Sample {
	public static double foo()
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val);

			return result;
		}
		catch (MyException ex) {
			System.out.println("foo:My Exception yakalandı");
			throw ex;
		}
		finally {
			System.out.println("foo:finally");
		}
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException();

		if (val == 0)
			throw new YourException();


		return Math.log(val);
	}
}


class MyException extends RuntimeException {
	//...
}

class YourException extends RuntimeException {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    try-finally yani catch bloksuz bir try bloğu ile exception nesnesi yakalanmadan ve aynı zamanda exception
    oluşsa da oluşmasa da yapılacak bir işleme yönelik kod yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            double result = Sample.foo();

            System.out.printf("result:%f%n", result);

        }
        catch (YourException ex) {
            System.out.println("main:Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("main:My Exception yakalandı");
        }
        catch (NumberFormatException ex) {
            System.out.println("main:NumberFormatException yakalandı");
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());

            return MathUtil.myLog(val);
        }
        finally {
            System.out.println("foo:finally");
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte return edilmeden önce try yazısı ekleneceğinden çıktı exceptiontryfinally biçiminde olur.
    Aşağıdaki örnekte durumun anlaşılması için MutableString sınıfı yazılmıştır. Sınıf daha iyi yazılabilir. Burada
    bu durum gözardı edilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		System.out.println(Sample.foo("exception")); //exceptiontryfinally
	}
}


class Sample {
	public static MutableString foo(String str)
	{
		MutableString mutableString = new MutableString(str);

		try {
			return mutableString.append("try");
		}
		finally {
			mutableString.append("finally");
		}
	}
}

class MutableString {
	private String m_str;

	public MutableString(String str)
	{
		this.setStr(str);
	}

	public void setStr(String str)
	{
		//...
		m_str = str;
	}

	public MutableString append(String str)
	{
		m_str += str;

		return this;
	}

	//...

	public String toString()
	{
		return m_str;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.foo("exception")); //exceptiontry
    }
}


class Sample {
    public static String foo(String str)
    {
        MutableString mutableString = new MutableString(str);

        try {
            return mutableString.append("try").toString();
        }
        finally {
            mutableString.append("finally");
            System.out.printf("In foo:%s%n", mutableString);
        }
    }
}

class MutableString {
    private String m_str;

    public MutableString(String str)
    {
        this.setStr(str);
    }

    public void setStr(String str)
    {
        //...
        m_str = str;
    }

    public MutableString append(String str)
    {
        m_str += str;

        return this;
    }

    //...

    public String toString()
    {
        return m_str;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		System.out.println(Sample.foo("exception")); //exceptiontry
	}
}


class Sample {
	public static String foo(String str)
	{
		try {
			str += "try";

			return str;
		}
		finally {
			str += "finally";
			System.out.printf("In foo:%s%n", str);
		}
	}
}
/*----------------------------------------------------------------------------------------------------------------------
    Exception sınıfları içerisinde tutulan elemanlar ile bilgi taşınabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) {
			System.out.printf("Exception message:%s%n", ex.getMessage());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException("val can not be negative");

		if (val == 0)
			throw new MyException("val can not be zero");


		return Math.log(val);
	}
}


class MyException extends RuntimeException {
	private final String m_message;

	public MyException(String message)
	{
		m_message = message;
	}

	public String getMessage() {return m_message;}
}

/*----------------------------------------------------------------------------------------------------------------------
    Throwable sınıfı içerisinde exception işlemlerine yönelik bir takım veri elemanları bulunmaktadır. Bunlardan en temel
    olanı mesaja karşılık gelen elemandır. Throwable sınıfından türetilmiş olan sınıflar yani exception sınıfları genel
    olarak String parametreli ctor elemanını yazarlar böylelikle hiyararşik olarak mesaj elemanı Throwable sınıfına
    aktarılmış olur. İsterse programcı başka bilgileri de yazdığı exception sınıfına ekleyebilir. Throwable sınıfının
    getMessage metodu ile mesaj bilgisi elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.printf("Exception message:%s, Error Status:%s%n", ex.getMessage(), ex.getErrorStatus());

            if (ex.getErrorStatus() == MyExceptionStatus.NEGATIVE)
                System.out.println("Negatif değer kabul edilemez");
            else
                System.out.println("Sıfır değeri kabul edilemez");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative", MyExceptionStatus.NEGATIVE);

        if (val == 0)
            throw new MyException("val can not be zero", MyExceptionStatus.ZERO);


        return Math.log(val);
    }
}

enum MyExceptionStatus {ZERO, NEGATIVE}

class MyException extends RuntimeException {
    private final MyExceptionStatus m_errorStatus;

    public MyException(String message, MyExceptionStatus errorStatus)
    {
        super(message);
        m_errorStatus = errorStatus;
    }

    public MyExceptionStatus getErrorStatus()
    {
        return m_errorStatus;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    getMessage metodu override edilebilir. Böylelikle programcı kendi exception sınıfına özel getMessage yazabilir.
    Aşağıdaki örnekte polimorfik olarak MyException sınıfının getMessage metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative", MyExceptionStatus.NEGATIVE);

        if (val == 0)
            throw new MyException("val can not be zero", MyExceptionStatus.ZERO);

        return Math.log(val);
    }
}

enum MyExceptionStatus {ZERO, NEGATIVE}

class MyException extends RuntimeException {
    private final MyExceptionStatus m_errorStatus;

    public MyException(String message, MyExceptionStatus errorStatus)
    {
        super(message);
        m_errorStatus = errorStatus;
    }

    public MyExceptionStatus getErrorStatus()
    {
        return m_errorStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Error Status:%s", super.getMessage(), m_errorStatus);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Throwable sınıfının parametresiz printStackTrace metodu exception fırlatılması noktalarını bir stack biçiminde
    gösteren detaylı mesajı ekrana basar. Bu metotta basılan yazı akış exception yakalanmadığından dolayı sonlandığında da
    basılan yazı ile neredeyse aynıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (Throwable ex) {
			ex.printStackTrace();
		}
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException("val can not be negative", ErrorStatus.NEGATIVE);

		if (val == 0)
			throw new MyException("val can not be zero", ErrorStatus.ZERO);


		return Math.log(val);
	}
}

enum ErrorStatus {ZERO, NEGATIVE}

class MyException extends RuntimeException {
	private final ErrorStatus m_errorStatus;
	public MyException(String message, ErrorStatus errorStatus)
	{
		super(message);
		m_errorStatus = errorStatus;
	}

	public ErrorStatus getErrorStatus()
	{
		return m_errorStatus;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Error Status:%s", super.getMessage(), m_errorStatus);
	}
}



/*----------------------------------------------------------------------------------------------------------------------
    Throwable sınıfı içerisinde Throwable türünden bir referans tutulur. Bu referans bir exception sınıfı içerisinde
    başka bir exception referansının tutulabilmesine olanak sağlar. getCause metodu ile içsel olarak tutulan referans
    elde edilebilir. Ayrıca Throwable sınıfının Throwble parametresi de alan ctor elemanı ile bu bilgi nesneye verilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            System.out.println(Sample.foo());
        }
        catch (WrapperException ex) {
            System.out.println(ex.getMessage());
            Throwable cause = ex.getCause();

            if (cause instanceof NumberFormatException)
                System.out.printf("Cause Message:%s%n", cause.getMessage());
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            return result;
        }
        catch (Throwable ex) {
            //...
            throw new WrapperException("foo exception", ex);
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new WrapperException("val < 0", new MyException("val can not be negative", ErrorStatus.NEGATIVE));

        if (val == 0)
            throw new MyException("val can not be zero", ErrorStatus.ZERO);

        return Math.log(val);
    }
}

class WrapperException extends RuntimeException {
    public WrapperException(String message)
    {
        super(message);
    }

    public WrapperException(String message, Throwable cause)
    {
        super(message, cause);
    }

    public String getMessage()
    {
        Throwable cause =  getCause();

        return String.format("Message:%s%s",
                super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
    }
}

enum ErrorStatus {ZERO, NEGATIVE}

class MyException extends RuntimeException {
    private final ErrorStatus m_errorStatus;
    public MyException(String message, ErrorStatus errorStatus)
    {
        super(message);
        m_errorStatus = errorStatus;
    }

    public ErrorStatus getErrorStatus()
    {
        return m_errorStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Error Status:%s", super.getMessage(), m_errorStatus);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    07.05.2021
    Java'da exception sınıfları kategori olarak iki gruba ayrılır: checked, unchecked
    unchecked exception sınıfları: Bir exception sınıfının türetme hiyararşisi içerisinde Error veya RuntimeException sınıfı
    varsa unchecked exception sınıfıdır.

    checked exception sınıfları: unchecked olmayan exception sınıflarıdır

    Anahtar Notlar: Bir exception sınıfının unchecked veya checked olmasının çalışma zamanı açısından bir önemi yoktur.
    Yani tüm exception sınıfları için exception mekanizması çalışma zamanı sırasında aynıdır. Bir exception sınıfının
    checked olması derleme zamanında bir takım özellikleri (detayları) beraberinde getirir.

    Anahtar Notlar: Exception sınıflarının yazımında geleneksel olarak Throwable sınıfından doğrudan türetme yapılmaz

    Anahtar Notlar: Türetme kavramı dolayısıyla bir exception sınıfından türetilen bir başka exception sınıfı
    kategori olarak taban sınıfı ile aynıdır. Yani taban sınıfı checked ise kendisi de checked bir exception
    sınıfı olur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Checked ve unchecked exception sınıfları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class MyException extends Throwable { //checked

}

class YourException extends Error { //unchecked

}

class OurException extends Exception { //checked

}

class TheirException extends RuntimeException { //unchecked

}

class HisException extends TheirException { //unchecked

}

class HerException extends OurException { //checked

}

/*----------------------------------------------------------------------------------------------------------------------
    checked bir exception throw edilen metodun içerisinde eğer exception ele alınmayacaksa (handle) throws bildirimi
    yapılmalıdır. Aksi durumda error oluşur. Aşağıdaki kodu inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) {
			System.out.println(ex.getMessage());
		}
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val) throws MyException
	{
		if (val < 0)
			throw new MyException("val can not be negative");

		if (val == 0)
			throw new MyException("val can not be zero");

		return Math.log(val);
	}
}

class MyException extends Exception {
	public MyException(String message)
	{
		super(message);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    checked bir exception throw edilen metodun içerisinde eğer exception ele alınmayacaksa throws bildirimi
    yapılmalıdır. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative"); //error

        if (val == 0)
            throw new MyException("val can not be zero"); //error

        return Math.log(val);
    }
}

class MyException extends Exception {
    public MyException(String message)
    {
        super(message);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Birden fazla checked exception fırlatılması durumunda exception sınıfları arasında doğrudan ya da dolaylı olarak
    türetme ilişkisi yoksa hepsi birden throws listesine yazılmalıdır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val) throws MyException, YourException
	{
		if (val < 0)
			throw new MyException("val can not be negative");

		if (val == 0)
			throw new YourException("val can not be zero");

		return Math.log(val);
	}
}

class MyException extends Exception {
	public MyException(String message)
	{
		super(message);
	}
}

class YourException extends Exception {
	public YourException(String message)
	{
		super(message);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    checked exception fırlatma ihtimali olan bir akışın throws bildirimi yapılmayacaksa try bloğu içerisinde
    olması ve fırlatma ihtimali olan checked exception'ları yakalayabilecek catch bloklarının varolması zorunludur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val); //error

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) {
			System.out.println(ex.getMessage());
		}
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double myLog(double val) throws MyException, YourException
	{
		if (val < 0)
			throw new MyException("val can not be negative");

		if (val == 0)
			throw new YourException("val can not be zero");

		return Math.log(val);
	}
}

class MyException extends Exception {
	public MyException(String message)
	{
		super(message);
	}
}

class YourException extends Exception {
	public YourException(String message)
	{
		super(message);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    checked exception sınıfı türünden parametreli bir catch bloğunun ait olduğu try bloğunda o checked exception
    türüne ilişkin nesneyi fırlatabilecek bir akış bulunmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = Math.log(val);

			System.out.printf("log(%f)=%f%n", val, result);
		}
		catch (MyException ex) { //error
			System.out.println(ex.getMessage());
		}
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MyException extends Exception {
	public MyException(String message)
	{
		super(message);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kural Exception ve Throwable sınıfları için geçerli değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		try {
			//...
		}
		catch (Exception ex) {
			//...
		}
		catch (Throwable ex) {
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir metodun fırlatabileceği checked exception sınıfları arasında türetme ilişkisi varsa throws listesine istenirse
    yalnızca taban sınıf yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = Math.log(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val) throws MyException
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new YourException("val can not be zero");


        return Math.log(val);
    }
}

class MyException extends Exception {
    public MyException(String message)
    {
        super(message);
    }
}

class YourException extends MyException {
    public YourException(String message)
    {
        super(message);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    throws bildirimi olan bir metodun override edilmesi durumunda override edilen metotta throws listesinde
    olan exception sınıfları kaldırılabilir. Yani örneğin, hiç throws listesi de yazılmayabilir. throws listesi
    override edilen metotta olacaksa throws listesindeki sınıflar ya taban sınıfın metoduyla aynı olan veya ondan türemiş
    sınıflar türünden olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class E extends A {
	public void foo() throws TheirException //error
	{
		//...
	}
}

class D extends A {
	public void foo() throws OurException
	{

	}
}

class C extends A {
	public void foo() throws MyException
	{
		//...
	}
}

class B extends A {
	public void foo()
	{
		//...
	}
}

abstract class A {
	//...
	public abstract void foo() throws MyException, YourException;
}

class MyException extends Exception {

}

class OurException extends MyException {

}

class YourException extends Exception {

}

class TheirException extends Exception {

}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problemden dolayı programcı aşağıdaki gibi kodda yöntemini değiştirmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public static void bar() throws YourException
	{
		//...
	}
}
class B extends A {
	public void foo() throws YourException //error
	{
		Sample.bar();
	}
}

abstract class A {
	public abstract void foo() throws MyException;
}


class MyException extends Exception {

}
class YourException extends Exception {

}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problem aşağıdaki gibi çözülebilir. Aşağıdaki kodda unchecked exception içerisine checked bir exceptiom
    referansı (cause) verilmiştir. Bu durumda yukarıdaki hata oluşmaz. Bu çözüm override ettiğimiz metoda ilişkin
    sınıfı bizim tasarlamadığımız durumlarda daha çok karşımıza çıkar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public static void bar() throws YourException
	{
		//...
	}
}

class B extends A {
	public void foo()
	{
		try {
			Sample.bar();
		}
		catch (YourException ex) {
			throw new WrapperException("wrapper", ex);
		}
	}
}

class WrapperException extends RuntimeException {
	public WrapperException(String message)
	{
		super(message);
	}
	public WrapperException(String message, Throwable cause)
	{
		super(message, cause);
	}

	public String getMessage()
	{
		Throwable cause =  getCause();
		return String.format("Message:%s%s",
				super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
	}
}

abstract class A {
	public abstract void foo() throws MyException;
}

class MyException extends Exception {

}

class YourException extends Exception {

}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problem abstract metodun çok genel bir kullanımı olabilecekse aşağıdaki gibi abstract metodun
    bildirimine throws Exception eklenerek çözülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public static void bar() throws YourException
	{
		//...
	}
}

class B extends A {
	public void foo() throws YourException
	{
		Sample.bar();
	}
}

abstract class A {
	public abstract void foo() throws Exception;
}

class MyException extends Exception {

}

class YourException extends Exception {

}

/*----------------------------------------------------------------------------------------------------------------------
    NumberFormatException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("Bir sayı giriniz:");
            int val = Integer.parseInt(kb.nextLine());

            System.out.println(val * val);
        }
        catch (NumberFormatException ex) {
            System.out.printf("Message:%s%n", ex.getMessage());
            System.out.println("Geçersiz formatta sayı girdiniz");
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        int a = Console.readInt("Birinci sayıyı giriniz:", "Hatalı giriş yaptınız:");
        int b = Console.readInt("İkinci sayıyı giriniz:", "Hatalı giriş yaptınız:");

        System.out.printf("%d + %d = %d%n", a, b, a + b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        double a = Console.readDoubleLine("Birinci sayıyı giriniz:", "Hatalı giriş yaptınız:");
        double b = Console.readDoubleLine("İkinci sayıyı giriniz:", "Hatalı giriş yaptınız:");

        System.out.printf("%f + %f = %f%n", a, b, a + b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        String s = Console.read("Bir yazı giriniz:");

        System.out.println(s.toUpperCase());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        char ch = Console.readCharLine("Bir karakter giriniz:", "Hatalı giriş yaptınız");

        System.out.println(Character.isWhitespace(ch) ? "Boşluk karakteri" : "Boşluk karakteri değil");
    }
}


package org.csystem.util;

import java.util.Scanner;

public final class Console {
    private static final Scanner ms_kb;

    static {
        ms_kb = new Scanner(System.in);
    }

    private Console()
    {
    }

    /////////////////////readInt methods/////////////////////
    public static int readInt()
    {
        return readInt("");
    }

    public static int readInt(String message)
    {
        return readInt(message, "");
    }

    public static int readInt(String message, String errMessage)
    {
        for (;;) {
            try {
                System.out.print(message);
                return Integer.parseInt(ms_kb.nextLine());
            }
            catch (NumberFormatException ignore) {
                System.out.print(errMessage);
            }
        }
    }

    public static int readIntLine(String message)
    {
        return readIntLine(message, "");
    }

    public static int readIntLine(String message, String errMessage)
    {
        return readInt(message + '\n', errMessage + '\n');
    }

    /////////////////////readDouble methods/////////////////////
    public static double readDouble()
    {
        return readDouble("");
    }

    public static double readDouble(String message)
    {
        return readDouble(message, "");
    }

    public static double readDouble(String message, String errMessage)
    {
        for (;;) {
            try {
                System.out.print(message);
                return Double.parseDouble(ms_kb.nextLine());
            }
            catch (NumberFormatException ignore) {
                System.out.print(errMessage);
            }
        }
    }

    public static double readDoubleLine(String message)
    {
        return readDoubleLine(message, "");
    }

    public static double readDoubleLine(String message, String errMessage)
    {
        return readDouble(message + '\n', errMessage + '\n');
    }

    /////////////////////readString methods/////////////////////
    public static String read()
    {
        return read("");
    }

    public static String read(String message)
    {
        System.out.print(message);
        return ms_kb.nextLine();
    }

    public static String readLine(String message)
    {
        return read(message + '\n');
    }

    /////////////////////readChar methods/////////////////////
    public static char readChar()
    {
        return readChar("");
    }

    public static char readChar(String message)
    {
        return readChar(message, "");
    }

    public static char readChar(String message, String errMessage)
    {
        for (;;) {
            System.out.print(message);
            String s = ms_kb.nextLine();

            if (s.length() <= 1)
                return s.isEmpty() ? '\n': s.charAt(0);

            System.out.print(errMessage);
        }
    }

    public static char readCharLine(String message)
    {
        return readCharLine(message + '\n', "");
    }

    public static char readCharLine(String message, String errMessage)
    {
        return readChar(message + '\n', errMessage + '\n');
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ClassCastException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new A();

        B y = (B)x;

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class A {

}

class B extends A {

}

/*----------------------------------------------------------------------------------------------------------------------
    ClassCastException sınıfı aşağıdaki gibi try-catch ile kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
	public static void main(String [] args)
	{
		try {
			int val = Console.readInt("Bir sayı giriniz:");
			A x = val > 0 ? new B() : new A();
			B y = (B) x;

			System.out.println("Tekrar yapıyor musunuz?");
		}
		catch (ClassCastException ex) {
			System.out.println("Haksız dönüşüm");
		}
	}
}

class A {

}

class B extends A {

}
/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnek instanceof operatörü ile de yapılabilir. Bu şekilde kullanım daha çok tercih edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
	public static void main(String [] args)
	{
		int val = Console.readInt("Bir sayı giriniz:");
		A x = val > 0 ? new B() : new A();

		if (x instanceof B) {
			B y = (B) x;
			//...
			System.out.println("Tekrar yapıyor musunuz?");
		}
		else
			System.out.println("Haksız dönüşüm");
	}
}

class A {

}

class B extends A {

}

/*----------------------------------------------------------------------------------------------------------------------
    NullPointerException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = null;

        s.foo();
    }
}

class Sample {
    public void foo()
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte getRandomArray metodunun döndürdüğü referansın null olması durumunda NullPointerException
    nesnesi fırlatılır. NullPointerException nesnesinin try-catch bloğu ile işlenmesi genel olarak tercih edilmez.
    Akışın bu exception fırlatılması noktasına gelmesi engellenir. Hatta gerekirse başka bir exception fırlatılabilir.
    Örnekte ** ile belirtilen kodu kaldırarak test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (int i = 0; i < 5; ++i) {
			System.out.print("Eleman sayısını giriniz:");
			int n = Integer.parseInt(kb.nextLine());

			System.out.print("Minimum değeri giriniz:");
			int min = Integer.parseInt(kb.nextLine());

			System.out.print("Maximun değeri giriniz:");
			int max = Integer.parseInt(kb.nextLine());

			int [] a = Util.getRandomArray(r, n, min, max);

			if (a == null) continue; //**

			for (int val : a)
				System.out.printf("%d ", val);

			System.out.println("\n//////////////");
		}
	}
}

class Util {
	//...
	public static int [] getRandomArray(Random r, int n, int min, int max)
	{
		if (r == null || n <= 0|| min >= max)
			return null;

		int [] a = new int[n];

		for (int i = 0; i < n; ++i)
			a[i] = r.nextInt(max - min) + min;

		return a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    IllegalArgumentException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("min?");
        int min = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(kb.nextLine());

        try {
            Random r = new Random();

            for (int i = 0; i < 10; ++i)
                System.out.printf("%d ", RandomUtil.nextInt(r, min, max));

            System.out.println();
        }
        catch (IllegalArgumentException ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class RandomUtil {
    public static int nextInt(Random r, int min, int max)
    {
        if (r == null)
            throw new IllegalArgumentException("r can not be null value");

        if (min >= max)
            throw new IllegalArgumentException(String.format("min must be less than max:min=%d, max=%d", min, max));

        return r.nextInt(max - min) + min;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    IndexOutOfBoundsException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("n?");
        int n = Integer.parseInt(kb.nextLine());

        System.out.print("start?");
        int start = Integer.parseInt(kb.nextLine());

        System.out.print("end?");
        int end = Integer.parseInt(kb.nextLine());

        int [] a = ArrayUtil.generateRandomArray(n, 0, 100);

        ArrayUtil.display(2, a);
        ArrayUtil.display(2, Util.getSubArray(a, start, end));
    }
}

class Util {
    public static int [] getSubArray(int []a, int start, int end) //[start, end)
    {
        if (a == null)
            throw new IllegalArgumentException("a can not be null");

        if (start < 0 || end < 0 || start >= end || start >= a.length || end > a.length)
            throw new IndexOutOfBoundsException(String.format("Invalid bounds:start=%d, end=%d", start, end));

        int [] res = new int[end - start];

        for (int i = start; i < end; ++i)
            res[i - start] = a[i];

        return res;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayIndexOutOfBoundsException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("n?");
        int n = Integer.parseInt(kb.nextLine());

        System.out.print("start?");
        int start = Integer.parseInt(kb.nextLine());

        System.out.print("end?");
        int end = Integer.parseInt(kb.nextLine());

        int [] a = ArrayUtil.generateRandomArray(n, 0, 100);

        ArrayUtil.display(2, a);
        ArrayUtil.display(2, Util.getSubArray(a, start, end));
    }
}

class Util {
    public static int [] getSubArray(int []a, int start, int end) //[start, end)
    {
        if (a == null)
            throw new IllegalArgumentException("a can not be null");

        if (start < 0 || end < 0 || start >= end || start >= a.length || end > a.length)
            throw new ArrayIndexOutOfBoundsException(String.format("Invalid bounds:start=%d, end=%d", start, end));

        int [] res = new int[end - start];

        for (int i = start; i < end; ++i)
            res[i - start] = a[i];

        return res;
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    UnsupportedOperationException sınıfı. Bu sınıf aşağıdaki gibi desteklenmeyen metotların boş bırakılması ya da
    geri dönüş değeri varsa anlamsız return deyimi yazmak yerine tercih edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new B();

        x.foo();
        //x.bar();
    }
}

class B extends A {
    public void foo()
    {
        //...
    }

    public int bar()
    {
        throw new UnsupportedOperationException("bar not supported in B");
    }
}

abstract class A {
    //...
    public abstract void foo();
    public abstract int bar();
}

/*----------------------------------------------------------------------------------------------------------------------
    Java 7 ile birlikte birden fazla exception için ortak bir iş yapılacaksa | atomu kullanılarak catch bloğu
    yazılabilir. Bu catch bloğu içerisinde iki sınıfın da ancak ortak elemanları kullanılablir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			double result = Sample.foo();

			System.out.printf("result:%f%n", result);
		}
		catch (MyException | YourException ex) { //Since Java 7
			System.out.println("ortak iş");
			System.out.println(ex.getMessage());
		}
		catch (NumberFormatException ex) {
			System.out.println("main:NumberFormatException yakalandı");
		}
		finally {
			System.out.println("main:finally");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Sample {
	public static double foo()
	{
		try {
			Scanner kb = new Scanner(System.in);

			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.myLog(val);

			return result;
		}
		finally {
			System.out.println("foo:finally");
		}
	}
}

class MathUtil {
	public static double myLog(double val)
	{
		if (val < 0)
			throw new MyException("val can not be negative");

		if (val == 0)
			throw new YourException("val can not be zero");


		return Math.log(val);
	}
}


class MyException extends RuntimeException {
	public MyException(String msg)
	{
		super(msg);
	}
}

class YourException extends RuntimeException {
	public YourException(String msg)
	{
		super(msg);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlem istenildiği kadar exception sınıfı ile yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            double result = Sample.foo();

            System.out.printf("result:%f%n", result);
        }
        catch (MyException | YourException | NumberFormatException ex) { //Since Java 7
            System.out.println("ortak iş");
            System.out.println(ex.getMessage());
        }
        catch (Throwable ex) {
            System.out.printf("Throwable:%s%n", ex.getMessage());
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            return result;
        }
        finally {
            System.out.println("foo:finally");
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new YourException("val can not be zero");


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    public MyException(String msg)
    {
        super(msg);
    }
}

class YourException extends RuntimeException {
    public YourException(String msg)
    {
        super(msg);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Birden fazla exception'ın | atomu yakalanması durumunda exception sınıfları arasında türetme ilişkisi
    olmaması gerekir. Olması durumunda türemiş exception sınıfı taban sınıfı ile birlikte kullanılamaz. Zaten
    türemiş sınıf exception nesnesi taban sınıf parametreli catch bloğu ile yakalanabilir. Java bu durumda gereksiz
    kod yazımını engellemek için error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            double result = Sample.foo();

            System.out.printf("result:%f%n", result);
        }
        catch (MyException | YourException | NumberFormatException ex) { //error
            System.out.println("ortak iş");
            System.out.println(ex.getMessage());
        }
        catch (Throwable ex) {
            //...
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            return result;
        }
        finally {
            System.out.println("foo:finally");
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new YourException("val can not be zero");


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    public MyException(String msg)
    {
        super(msg);
    }
}

class YourException extends MyException {
    public YourException(String msg)
    {
        super(msg);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.collection;

public class CSDArrayList {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void doWorkForIllegalArgumentException(String message)
    {
        throw new IllegalArgumentException(message);
    }

    private static void doWorkForIndexOutOfBoundsException(String message)
    {
        throw new IndexOutOfBoundsException(message);
    }

    private static void checkCapacityValue(int capacity)
    {
        if (capacity < 0)
            doWorkForIllegalArgumentException("Capacity can not be negative");
    }

    private void checkIndex(int index)
    {
        if (index < 0 || index >= m_index)
            doWorkForIndexOutOfBoundsException("Index out of bounds");
    }

    private void changeCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        System.arraycopy(m_elems, 0, temp, 0, m_index);

        m_elems = temp;
    }

    public CSDArrayList()
    {
        m_elems = new Object[DEFAULT_CAPACITY];
    }

    public CSDArrayList(int capacity)
    {
        checkCapacityValue(capacity);
        m_elems = new Object[capacity];
    }

    public boolean add(Object elem)
    {
        if (m_elems.length == m_index)
            changeCapacity(m_elems.length == 0 ? 1 : m_elems.length * 2);

        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, Object elem)
    {
        //TODO:
    }

    public int capacity()
    {
        return m_elems.length;
    }

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public void ensureCapacity(int capacity)
    {
        if (capacity < m_elems.length)
            return;

        changeCapacity(Math.max(m_elems.length * 2, capacity));
    }

    public Object get(int index)
    {
        checkIndex(index);

        return m_elems[index];
    }

    public Object set(int index, Object elem)
    {
        checkIndex(index);
        Object oldElem = m_elems[index];

        m_elems[index] = elem;

        return oldElem;
    }


    private Object remove(int index)
    {
        //TODO:
        Object oldVal = m_elems[index];

        //TODO:

        return oldVal;
    }

    public int size()
    {
        return m_index;
    }

    public void trimToSize()
    {
        if (m_index != m_elems.length)
            changeCapacity(m_index);
    }

    public String toString()
    {
        String str = "[";

        for (int i = 0; i < m_index; ++i) {
            if (str.length() != 1)
                str += ", ";

            str += m_elems[i];
        }

        return str + "]";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Date sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Date {
    private static final String [] MONTHS_TR;
    private static final String [] MONTHS_EN;
    private static final String [] DAYS_OF_WEEK_TR;
    private static final String [] DAYS_OF_WEEK_EN;
    private static final Month [] MONTHS;

    static {
        MONTHS_TR = new String[] {"", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran",
                "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};
        MONTHS_EN = new String[] {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
        DAYS_OF_WEEK_TR = new String[] {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
        DAYS_OF_WEEK_EN = new String[] {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
        MONTHS = Month.values();
    }

    private int m_day;
    private int m_month;
    private int m_year;
    private int m_dayOfWeek;

    private static boolean isValidDate(int day, int month, int year)
    {
        if (day < 1 || day > 31 || month < 1 || month > 12)
            return false;

        return day <= MONTHS[month - 1].getDays(year);
    }

    private static int getTotalDaysByMonth(int month, int year)
    {
        int totalDays = 0;

        for (int m  = month - 1; m >= 1; --m)
            totalDays += MONTHS[m - 1].getDays(year);

        return month > 2 && Month.isLeapYear(year) ? totalDays + 1 : totalDays;
    }

    private static int getDayOfYear(int day, int month, int year)
    {
        return day + getTotalDaysByMonth(month, year);
    }

    private static int getDayOfWeek(int day, int month, int year)
    {
        int totalDays = getDayOfYear(day, month, year);

        for (int y = 1900; y < year; ++y)
            totalDays += Month.isLeapYear(y) ? 366 : 365;

        return totalDays % 7;
    }

    private static String getDaySuffix(int day)
    {
        String suffix = "th";

        switch (day) {
            case 1:
            case 21:
            case 31:
                suffix = "st";
                break;
            case 2:
            case 22:
                suffix = "nd";
                break;
            case 3:
            case 23:
                suffix = "rd";
                break;
        }

        return suffix;
    }

    private static void doWorkForException(String message)
    {
        throw new DateTimeException(message);
    }

    private static void checkForDate(int day, int month, int year, String errMessage)
    {
        if (!isValidDate(day, month, year))
            doWorkForException(errMessage);
    }

    private void checkForDay(int val)
    {
        checkForDate(val, m_month, m_year, "Invalid day value:" + val);
    }

    private void checkForMonth(int val)
    {
        checkForDate(m_day, val, m_year, "Invalid month value:" + val);
    }

    private void checkForYear(int val)
    {
        checkForDate(m_day, m_month, val, "Invalid year value:" + val);
    }

    private void set(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    public static Date of()
    {
        return of(new Random());
    }

    public static Date of(Random r)
    {
        return of(r, new Date().m_year);
    }

    public static Date of(int year)
    {
        return of(new Random(), year);
    }

    public static Date of(Random r, int year)
    {
        return of(r, year, year);
    }

    public static Date of(int minYear, int maxYear)
    {
        return of(new Random(), minYear, maxYear);
    }

    public static Date of(Random r, int minYear, int maxYear)
    {
        int year = r.nextInt(maxYear - minYear + 1) + minYear;
        int month = r.nextInt(12) + 1;
        int day = r.nextInt(MONTHS[month - 1].getDays(year)) + 1;

        return new Date(day, month, year);
    }

    public Date() //Burada yazılanların bilinmesi gerekmez. Sadece default ctor'un anlamı olarak yazılmıştır
    {
        Calendar now = Calendar.getInstance();

        m_day = now.get(Calendar.DAY_OF_MONTH);
        m_month = now.get(Calendar.MONTH) + 1;
        m_year = now.get(Calendar.YEAR);
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    public Date(int day, Month month, int year)
    {
        this(day, month.ordinal() + 1, year);
    }

    public Date(int day, int month, int year)
    {
        checkForDate(day, month, year, String.format("Invalid date values: all values -> %d, %d, %d", day, month, year));
        set(day, month, year);
    }

    public int getDay()
    {
        return m_day;
    }

    public void setDay(int day)
    {
        if (day == m_day)
            return;

        checkForDay(day);
        set(day, m_month, m_year);
    }

    public Month getMonth()
    {
        return MONTHS[m_month - 1];
    }

    public void setMonth(Month month)
    {
        setMonthValue(month.ordinal() + 1);
    }
    public int getMonthValue()
    {
        return m_month;
    }

    public void setMonthValue(int month)
    {
        if (month == m_month)
            return;

        checkForMonth(month);
        set(m_day, month, m_year);
    }

    public int getYear()
    {
        return m_year;
    }

    public void setYear(int year)
    {
        if (year == m_year)
            return;

        checkForYear(year);
        set(m_day, m_month, year);
    }

    public DayOfWeek getDayOfWeek()
    {
        return DayOfWeek.values()[m_dayOfWeek];
    }

    public String getDayOfWeekTR()
    {
        return DAYS_OF_WEEK_TR[m_dayOfWeek];
    }

    public String getDayOfWeekEN()
    {
        return DAYS_OF_WEEK_EN[m_dayOfWeek];
    }

    public boolean isLeapYear()
    {
        return Month.isLeapYear(m_year);
    }

    public boolean isWeekend()
    {
        return m_dayOfWeek == 0 || m_dayOfWeek == 6;
    }

    public boolean isWeekday()
    {
        return !isWeekend();
    }

    public String toString()
    {
        return toString('/');
    }

    public String toString(char delimiter)
    {
        return String.format("%02d%c%02d%c%04d", m_day, delimiter, m_month, delimiter, m_year);
    }

    public String toStringTR()
    {
        return String.format("%d %s %d", m_day, MONTHS_TR[m_month], m_year);
    }

    public String toStringEN()
    {
        return String.format("%d%s %s %d", m_day, getDaySuffix(m_day), MONTHS_EN[m_month], m_year);
    }

    public String toLongDateStringTR()
    {
        return String.format("%s %s", toStringTR(), DAYS_OF_WEEK_TR[m_dayOfWeek]);
    }

    public String toLongDateStringEN()
    {
        return String.format("%s %s", toStringEN(), DAYS_OF_WEEK_EN[m_dayOfWeek]);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Time sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Time {
    private int m_hour;
    private int m_minute;
    private int m_second;
    private int m_millisecond;

    private static void doWorkForException(String message)
    {
        throw new DateTimeException(message);
    }

    private static boolean isValidForBound(int val, int max)
    {
        return 0 <= val && val <= max;
    }

    private static boolean isValidForHour(int val)
    {
        return isValidForBound(val, 23);
    }

    private static boolean isValidForMinute(int val)
    {
        return isValidForBound(val, 59);
    }

    private static boolean isValidForSecond(int val)
    {
        return isValidForBound(val, 59);
    }

    private static boolean isValidForMillisecond(int val)
    {
        return isValidForBound(val, 999);
    }

    private static boolean isValidForTime(int hour, int minute, int second, int millisecond)
    {
        return isValidForHour(hour) && isValidForMinute(minute) &&
                isValidForSecond(second) && isValidForMillisecond(millisecond);
    }

    private static void checkForHour(int val)
    {
        if (!isValidForHour(val))
            doWorkForException("Invalid hour value:" + val);
    }

    private static void checkForMinute(int val)
    {
        if (!isValidForMinute(val))
            doWorkForException("Invalid minute value:" + val);
    }

    private static void checkForSecond(int val)
    {
        if (!isValidForSecond(val))
            doWorkForException("Invalid second value:" + val);
    }

    private static void checkForMillisecond(int val)
    {
        if (!isValidForMillisecond(val))
            doWorkForException("Invalid millisecond value value:" + val);
    }

    private static void checkForTime(int hour, int minute, int second, int millisecond)
    {
        if (!isValidForTime(hour, minute, second, millisecond))
            doWorkForException(String.format("Invalid time values:all values -> %d, %d, %d, %d", hour, minute, second, millisecond));
    }

    public static Time of()
    {
        return of(new Random());
    }

    public static Time of(Random r)
    {
        return new Time(r.nextInt(24), r.nextInt(60), r.nextInt(60), r.nextInt(1000));
    }

    public Time() //Burada yazılanların bilinmesi gerekmez. Sadece default ctor'un anlamı olarak yazılmıştır
    {
        Calendar now = Calendar.getInstance();

        m_hour = now.get(Calendar.HOUR_OF_DAY);
        m_minute = now.get(Calendar.MINUTE);
        m_second = now.get(Calendar.SECOND);
        m_millisecond = now.get(Calendar.MILLISECOND);
    }

    public Time(int hour, int minute)
    {
        this(hour, minute, 0);
    }

    public Time(int hour, int minute, int second)
    {
        this(hour, minute, second, 0);
    }

    public Time(int hour, int minute, int second, int millisecond)
    {
        checkForTime(hour, minute, second, millisecond);
        m_hour = hour;
        m_minute = minute;
        m_second = second;
        m_millisecond = millisecond;
    }

    public int getHour()
    {
        return m_hour;
    }

    public void setHour(int hour)
    {
        if (hour == m_hour)
            return;

        checkForHour(hour);
        m_hour = hour;
    }

    public int getMinute()
    {
        return m_minute;
    }

    public void setMinute(int minute)
    {
        if (minute == m_minute)
            return;

        checkForMinute(minute);
        m_minute = minute;
    }

    public int getSecond()
    {
        return m_second;
    }

    public void setSecond(int second)
    {
        if (second == m_second)
            return;

        checkForSecond(second);
        m_second = second;
    }

    public int getMillisecond()
    {
        return m_millisecond;
    }

    public void setMillisecond(int millisecond)
    {
        if (millisecond == m_millisecond)
            return;

        checkForMillisecond(millisecond);
        m_millisecond = millisecond;
    }

    public String toLongTimeString()
    {
        return String.format("%s.%03d", toString(), m_millisecond);
    }

    public String toString()
    {
        return String.format("%s:%02d", toShortTimeString(), m_second);
    }

    public String toShortTimeString()
    {
        return String.format("%02d:%02d", m_hour, m_minute);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Fraction sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;
import org.csystem.util.math.Fraction;
import org.csystem.util.math.FractionException;

class App {
    public static void main(String [] args)
    {
        for (;;) {
            try {
                int a = Console.readInt("Pay değerini giriniz:");
                int b = Console.readInt("Payda değerini giriniz:");
                Fraction f = new Fraction(a, b);

                System.out.println(f);
            }
            catch (FractionException ex) {
                System.out.println(ex.getMessage());
            }
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Fraction sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math;

public class Fraction {
    private int m_a;
    private int m_b;

    private static Fraction add(int a1, int b1, int a2, int b2)
    {
        return new Fraction(a1 * b2 + a2 * b1, b1 * b2);
    }

    private static Fraction subtract(int a1, int b1, int a2, int b2)
    {
        return add(a1, b1, -a2, b2);
    }

    private static Fraction multiply(int a1, int b1, int a2, int b2)
    {
        return new Fraction(a1 * a2, b1 * b2);
    }

    private static Fraction divide(int a1, int b1, int a2, int b2)
    {
        return multiply(a1, b1, b2, a2);
    }

    private static void check(int a, int b)
    {
        if (b == 0) {
            if (a == 0)
               throw new FractionException("Indefinite", FractionExceptionStatus.INDEFINITE, a, b);

            throw new FractionException("Undefined", FractionExceptionStatus.UNDEFINED, a, b);
        }
    }

    private void simplify()
    {
        int min = Math.min(Math.abs(m_a), m_b);

        for (int i = min; i >= 2; --i)
            if (m_a % i == 0 && m_b % i == 0) {
                m_a /= i;
                m_b /= i;
                break;
            }
    }

    private void setSign()
    {
        if (m_b < 0) {
            m_a = -m_a;
            m_b = -m_b;
        }
    }

    private void set(int a, int b)
    {
        if (a == 0) {
            m_a = 0;
            m_b = 1;
            return;
        }
        m_a = a;
        m_b = b;
        setSign();
        simplify();
    }

    public Fraction()
    {
        m_b = 1;
    }

    public Fraction(int a)
    {
        m_a = a;
        m_b = 1;
    }

    public Fraction(int a, int b)
    {
        check(a, b);
        this.set(a, b);
    }

    public int getNumerator()
    {
        return m_a;
    }

    public void setNumerator(int val)
    {
        if (val == m_a)
            return;

        this.set(val, m_b);
    }

    public int getDenominator()
    {
        return m_b;
    }

    public void setDenominator(int val)
    {
        if (val == m_b)
            return;

        check(m_a, val);
        this.set(m_a, val);
    }

    public double getRealValue()
    {
        return (double) m_a / m_b;
    }

    //add methods
    public static Fraction add(int val, Fraction f)
    {
        return add(val, 1, f.m_a, f.m_b);
    }

    public Fraction add(Fraction other)
    {
        return add(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction add(int val)
    {
        return add(m_a, m_b, val, 1);
    }

    //subtract methods
    public static Fraction subtract(int val, Fraction f)
    {
        return subtract(val, 1, f.m_a, f.m_b);
    }

    public Fraction subtract(Fraction other)
    {
        return subtract(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction subtract(int val)
    {
        return subtract(m_a, m_b, val, 1);
    }

    //multiply methods
    public static Fraction multiply(int val, Fraction f)
    {
        return multiply(val, 1, f.m_a, f.m_b);
    }

    public Fraction multiply(Fraction other)
    {
        return multiply(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction multiply(int val)
    {
        return multiply(m_a, m_b, val, 1);
    }

    //divide methods
    public static Fraction divide(int val, Fraction f)
    {
        return divide(val, 1, f.m_a, f.m_b);
    }

    public Fraction divide(Fraction other)
    {
        return divide(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction divide(int val)
    {
        return divide(m_a, m_b, val, 1);
    }

    //increment
    public void increment(int val)
    {
        m_a += m_b * val;
    }

    public void increment()
    {
        this.increment(1);
    }

    //decrement
    public void decrement(int val)
    {
        this.increment(-val);
    }

    public void decrement()
    {
        this.decrement(1);
    }

    public String toString()
    {
        return String.format("%d%s", m_a, m_b == 1 ? "" : String.format(" / %s = %f", m_b, getRealValue()));
    }
}

package org.csystem.util.math;

public class FractionException extends NumberFormatException {
    private final FractionExceptionStatus m_status;
    private final int m_a;
    private final int m_b;

    public FractionException(String s, FractionExceptionStatus status, int a, int b)
    {
        super(s);
        m_status = status;
        m_a = a;
        m_b = b;
    }

    public FractionExceptionStatus getStatus()
    {
        return m_status;
    }

    public int getNumerator()
    {
        return m_a;
    }

    public int getDenominator()
    {
        return m_b;
    }

    public String getMessage()
    {
        return String.format("Message: %s, Error Status: %s, Numerator: %d, Denominator: %d", super.getMessage(), m_status, m_a, m_b);
    }
}

package org.csystem.util.math;

public enum FractionExceptionStatus {
    INDEFINITE, UNDEFINED
}

/*----------------------------------------------------------------------------------------------------------------------
    08.05.2021
    Arayüzler (Interfaces):
	Bilindiği gibi Java'da sınıf ve enum bildirimi bir tür bildirimidir (user defined types). Java' da interface
	anahtar sözcüğü ile arayüz (interface) bildirimi yapılabilmektedir. Arayüz bildirimi de bir tür bildirimidir.

	Arayüzler daha çok abstract sınıflara benzese de şüphesiz farklı özelliklere sahiptir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	interface ismini diğer tür bildirimlerinden ayırt etmek için biz kendi interface'lerimizin
	ismini "I" ile başlatacağız. Java'daki standart arayüz isimlerinde bu kurala uyulmamıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
    //...
}

interface ISample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde veri elemanı bildirimi yapılabilir. Bu veri elemanları yazılsa da yazılmasa da
	public static ve final olarak bildirilmiş olur. Biz bildirimlerde bu anahtar sözcükleri yazmayacağız.
	Interface içerisinde final olmayan veya public dışında erişim belirleyiciye sahip veya static olmayan
	veri elemanı bildirimi yapılamaz. Fakat interface içerisinde veri elemanı çok sık gerekmemektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.println(IX.PI);
        IX.PI = 2.34; //error
    }
}

interface IX {
    double PI = 3.14;
}

interface IY {
    private int x; //error
}

/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde gövdesiz metotlar olabilir. Bu metotlar yazılsa da yazılmasa da public ve abstract olur.
	Yine biz public ve abstract yazmayacağız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
    void foo();
    int bar(double val);
}

/*----------------------------------------------------------------------------------------------------------------------
	Hiç bir abstract metodu olmayan arayüzlere işaretleme arayüzleri (marker interfaces) denir.
	Genel olarak işaretleme arayüzlerinin içerisi boş bırakılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IMarker { //marker interface

}

interface IX { //marker interface
    String name = "IX";
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte interface içerisinde gövdeli (abstract olmayan) non-static metotlar yazılabilir. Bu metotlar
	default anahtar sözcüğü ile bildirilmelidir. Yazılsa da yazılmasa da default metotlar public'dir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
    default void foo() //Since Java 8
    {
        //...
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte bir arayüz içerisinde static metotlar olabilir. Şüphesiz static metotlar gövdeli olmalıdır.
	Bu metotlar da yazılsa da yazılmasa da public dir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        IX.foo();
    }
}

interface IX {
    static void foo() //Since Java 8
    {
        System.out.println("foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte belli koşullar altında arayüzler kullanım anlamında genişletilmiştir. Buna göre içerisinde
	bir ve yalnız bir tane abstract metodu olan arayüzlere fonksiyonel arayüzler (functional interfaces) denir.
	Fonksiyonel arayüzler ile Java'da fonksiyonel programlama daha kolay ve gelişmiş biçimde yapılabilmektedir.
	Aşağıdaki kodda fonksiyonel programlama tekniğine ilişkin bir örnek verilmiştir. Konunun detayı uygulama
	kursunda ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        IIntBinaryOperation intBinaryOperator = (a, b) -> a + b; //Integer::sum

        StringConverterUtil.display(String::length, "ankara");
        System.out.println(intBinaryOperator.applyAsInt(10, 20));
    }
}

class StringConverterUtil {
    public static void display(IStringToIntConverter stringToIntConverter, String str)
    {
        System.out.println(stringToIntConverter.convert(str));
    }
}

interface IIntBinaryOperation {
    int applyAsInt(int a, int b);
}

interface IStringToIntConverter {
    int convert(String str);
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 9 ile birlikte arayüzler içerisinde private metotlar yazılabilir. Şüphesiz bu metotların gövdeleri olmalıdır.
	private metotlar için default anahtar sözcüğü kullanılmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
    private void foo() //Since Java 9
    {
        //...
    }

    default void bar()
    {
        foo();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde bulunabilen private metotlar static olarak da bildirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
	private static void foo() //Since Java 9
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde olabilecek elemanlar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
    int NUM = 10;

    private void foo() //Since Java 9
    {

    }

    private static void bar() //Since Java 9
    {

    }

    default void tar() //Since Java 8
    {

    }

    static void func() // Since Java 8
    {

    }

    void zar();
    void car();
}

/*----------------------------------------------------------------------------------------------------------------------
	interface türünden nesne yaratılmaz ve yaratılamaz. interface nesne özelliği olmayan bir tür bildirimidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        IX ix = new IX(); //error

        //...
    }
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	interface bildiriminde abstract anahtar sözcüğü yazılabilir ancak yazmayacağız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX {
    //...
}

abstract interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü implements anahtar sözcüğü ile destekler (implementation)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX {
    //...
}

interface IX {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf birden fazla arayüzü destekleyebilir. Bu durumda hangi arayüzün listede önce olduğunun hiç bir önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX, IY, IZ {

}

interface IX {
    //...
}

interface IY {
    //...
}

interface IZ {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf başka bir sınıftan türetilip istediği kadar arayüzü destekleyebilir. Bu durumda taban sınıf
	listenin başında olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A implements IX, IY, IZ {
    //...
}


class A {

}

interface IX {
    //...
}

interface IY {
    //...
}

interface IZ {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü destekliyorsa o arayüzün tüm abstract metotlarını override etmelidir. Eğer birini bile override
	etmezse sınıf bildiriminde abstract yazılmalıdır. Yani sınıf abstract olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

abstract class B implements IX {
    public void foo()
    {
        //...
    }
}

class A implements IX {
    public void foo()
    {
        //...
    }

    public void bar()
    {
        //...
    }
}

interface IX {
    void foo();
    void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	Arayüz referansları taban sınıf referansı gibi kullanılabilir. Böylelikle çok biçimlilik arayüzler ile de
	yapılabilmektedir. Yani arayüzler çoklu türetmeyi (multiple inheritance) kısmi olarak kullanabilme olanağı sağlar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Mample m = new Mample();
        Sample s = new Sample();
        Test t = new Test();

        m.doWorkForIX(s);
        m.doWorkForIY(s);
        m.doWorkForIX(t);
    }
}

class Mample {
    public void doWorkForIX(IX ix)
    {
        ix.foo();
    }

    public void doWorkForIY(IY iy)
    {
        iy.bar();
    }
}

class Test implements IX {
    public void foo()
    {
        System.out.println("Test.foo");
    }
}

class Sample implements IX, IY {
    public void foo()
    {
        System.out.println("Sample.foo");
    }

    public void bar()
    {
        System.out.println("Sample.bar");
    }
}

interface IX {
    void foo();
}

interface IY {
    void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	Arayüz referansları taban sınıf referansı gibi kullanılabilir. Böylelikle çok biçimlilik arayüzler ile de
	yapılabilmektedir. Yani arayüzler çoklu türetmeyi kısmi olarak kullanabilme olanağı sağlar. Aşağıdaki örnekte
	Test sınıfı IY arayüzünü desteklemediğinde ** ile belirtilen çağrıda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Mample m = new Mample();
        Test t = new Test();

        m.doWorkForIX(s);
        m.doWorkForIY(s);
        m.doWorkForIX(t);
        m.doWorkForIY(t); //** error
    }
}

class Mample {
    public void doWorkForIX(IX ix)
    {
        ix.foo();
    }

    public void doWorkForIY(IY iy)
    {
        iy.bar();
    }
}

class Test implements IX {
    public void foo()
    {
        System.out.println("Test.foo");
    }

}

class Sample implements IX, IY {
    public void foo()
    {
        System.out.println("Sample.foo");
    }

    public void bar()
    {
        System.out.println("Sample.bar");
    }
}

interface IX {
    void foo();
}

interface IY {
    void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	Birden fazla arayüz içerisinde aynı imzaya ve geri dönüş değerine sahip bir sanal metot varsa ve bir sınıf
	bu iki arayüzü de destekliyorsa bir tane metot ikisi için de override edilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Mample m = new Mample();

        s.foo();
        m.doWorkForIX(s);
        m.doWorkForIY(s);
    }
}

class Mample {
    public void doWorkForIX(IX ix)
    {
        ix.foo();
    }

    public void doWorkForIY(IY iy)
    {
        iy.foo();
        iy.bar();
    }
}

class Sample implements IX, IY {
    public void foo()
    {
        System.out.println("Sample.foo");
    }

    public void bar()
    {
        System.out.println("Sample.bar");
    }
}

interface IX {
    void foo();
}

interface IY {
    void foo();
    void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü destekliyorsa o sınıftan türetilmiş bir sınıf da aynı arayüzü destekler. Bu durum
	türemiş sınıf arayüz listesinde belirtilmek zorunda değildir. İstenirse belirtilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();

        IX ix = b;

        ix.foo();
    }
}

class C extends A implements IX {

}

class B extends A {

}

class A implements IX {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte B sınıfı IX arayüzünün foo metodunu override etmiştir. Şüphesiz B açısından bu metot taban sınıfının
	metodudur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();

        IX ix = b;

        ix.foo();
    }
}

class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

class A implements IX {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

interface IX {
    void foo();
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte B sınıfı IX arayüzünün foo metodunu override etmiştir. Şüphesiz B açısından bu metot taban sınıfının
	metodudur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();

        IX ix = b;

        ix.foo();
    }
}

class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
        super.foo();
    }
}

class A implements IX {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte foo metodu A sınıfında final yapılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();

        IX ix = b;

        ix.foo();
    }
}

class B extends A {
    public void foo() //error
    {

    }
}

class A implements IX {
    public final void foo()
    {
        System.out.println("A.foo");
    }
}

interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir arayüz başka bir arayüzden türetilebilir. Burada extends anahtar sözcüğü kullanılır. Bu durumda türemiş arayüzü
	destekleyen bir sınıf taban arayüzü de desteklemiş olur yani somut sınıf olabilmek için tüm abstract metotları
	override etmesi gerekir. Aşağıdaki örnekte A sınıfı hem IY yi hem de IX'i desteklemiş olur. Arayüz listesinde sadece
	IY yazılması yeterlidir. İstenirse IX de yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();

        IY iy = a;
        IX ix = a;

        ix = iy; //upcasting

        System.out.println(ix.getClass().getName());
    }
}

class B implements IY, IX {
    public void foo()
    {

    }

    public void bar()
    {

    }
}

class A implements IY {
    public void foo()
    {

    }

    public void bar()
    {

    }
}

interface IY extends IX {
    void bar();
}

interface IX {
    void foo();
}


/*----------------------------------------------------------------------------------------------------------------------
	Arayüzler arasında çoklu türetme (multiple inheritance) yapılabilir. Aşağıdaki örnekte IZ yi destekleyen bir sınıf
	listeye yazılsa da yazılmasa da IX ve IY yi de destekler
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();

        IZ iz = a;
        IY iy = a;
        IX ix = a;
        //...

        ix = iz; //upcasting
        iy = iz; //upcasting
    }
}

class A implements IZ {
    public void foo()
    {

    }

    public void bar()
    {

    }

    public void tar()
    {

    }
}

interface IZ extends IX, IY {
    void tar();
}

interface IY  {
    void foo();
}

interface IX {
    void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	default metotlar sanaldır. default metotlar da override edilebilir. Bu durumda çok biçimli olarak override edilen
	çağrılır. default metotlar override edilmek zorunda değildir. Aşağıdaki örnekte B sınıfı foo default metodunu
	override etmemiştir, somut sınıf olarak bildirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix = a;

        ix.foo();

        ix = new B();

        ix.foo();
    }
}

class B implements IX {

}

class A implements IX {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

interface IX {
    default void foo()
    {
        System.out.println("IX.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	super referansı taban sınıfı temsil ettiğinden aşağıdaki örnekte taban sınıf da Object olduğundan error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix = a;

        ix.foo();
    }
}

class A implements IX {
    public void foo()
    {
        System.out.println("A.foo");
        super.foo(); //error: Burada super referansı Object türündendir
    }
}

interface IX {
    default void foo()
    {
        System.out.println("IX.foo");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçerlidir. super.foo() çağrısında B sınfının foo metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix = a;

        ix.foo();
    }
}

class A extends B implements IX {
    public void foo()
    {
        System.out.println("A.foo");
        super.foo(); //Burada super referansı B türündendir
    }
}

class B {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

interface IX {
    default void foo()
    {
        System.out.println("IX.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçerlidir. B' den kalıtımla alınan foo metodu A'nın foo metodu olarak ix referansı ile çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix = a;

        ix.foo();
    }
}

class A extends B implements IX {

}

class B {
    public void foo()
    {
        System.out.println("B.foo");
    }
}
interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte C sınıfı için foo metodu public olarak override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix = a;

        ix.foo();
    }
}

class C extends B implements IX { //error: Geçerli olsaydı IX için foo metodunun erişim belirleyicisi düşürülmüş olurdu

}


class A extends B implements IX {
    public void foo()
    {
        System.out.println("A.foo");
    }
}


class B {
    protected void foo()
    {
        System.out.println("B.foo");
    }
}

interface IX {
    void foo();
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnekte sınıfı abstract yaparak da error engellenemez. Buradaki hata IX'in foo metodunun protected olarak
	bırakılmasıdır. Bu da error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix = a;

        ix.foo();
    }
}

abstract class C extends B implements IX {
    //...
}

class B {
    protected void foo()
    {
        System.out.println("B.foo");
    }
}

class A extends B implements IX {
    public void foo()
    {
        System.out.println("A.foo");
    }
}


interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durum geçersizdir. Çünkü bir sınıf içerisinde aynı imzaya sahip birden fazla metot bildirimi yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX, IY {
    public void foo() //error
    {

    }

    public int foo() //error
    {
        return 10;
    }
}

interface IX {
    void foo();
}

interface IY {
    int foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıfın sanal bir metodu referansa geri dönen bir metot ise, bu metot türemiş sınıfta override edilirken
	geri dönüş değeri olan referansa ilişkin sınıftan türetilmiş bir sınıf geri dönüş değeri olarak yazılabilir.
	Buna İnglizce olarak "covariant return type" denir. Bu kullanım yararlı olsa da Java'da pek tercih edilmez.
	Burada geri dönüş değeri bir interface ise override edilirken geri dönüş değeri bilgisi yerine o interface'i
	implemente eden bir sınıf yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
    public Y foo()
    {
        Y y = new Y();

        //...
        return y;
    }
}

class Y extends X {

}

abstract class A {
    public abstract X foo();
}

class X {
    //...
}
/*----------------------------------------------------------------------------------------------------------------------
	Sanal bir metodun geri dönüş değeri Object türündense override edililirken geri dönüş bilgisi yerine istenilen bir
	referans türü yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Random;

class D implements IFactory {
    public Sample create()
    {
        return new Sample();
    }
}

class Sample {

}

class E implements IFactory {
    public int [] create()
    {
        return ArrayUtil.generateRandomArray(10, 10, 100);
    }
}

class C implements IFactory {
    public Random create()
    {
        return new Random();
    }
}

class B implements IFactory {
    public String create()
    {
        return "ankara";
    }
}

interface IFactory {
    Object create();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durum covariant return type kuralları dolayısıyla geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX, IY {
    public String foo()
    {
        return "ankara";
    }
}

interface IX {
    String foo();
}

interface IY {
    Object foo();
}


/*----------------------------------------------------------------------------------------------------------------------
    (Abstract) sınıflar ile arayüzler arasındaki farklar: (Maddelerin sırasının önemi yoktur)
    - Arayüzler interface anahtar sözcüğü ile abstract sınıflar ise class anahtar sözcüğü ile bildirilir

    - Arayüzler non-static veri elemanlarına sahip olamaz, abstract sınıflar olabilir

    - Arayüzler nesne özelliği göstermediğinden ctor'ları olamaz, abstract sınıfların olabilir

    - Arayüzlerin abstract metotları public ve abstract yazılmasa da bu şekilde kabul edilir. abstract
    sınıflarda bunlar yazılmalıdır

    - Arayüzlere Java 8 ile birlikte eklenen gövdeli non-static metotlar default anahtar sözcüğü ile yazılmalıdır.
    abstract sınıflarda doğrudan erişim belirleyici ile yazılmalıdır.

    - Arayüzlerin veri elemanları yazılsa da yazılmasa da public, static ve final olur. abstract sınıflarda
    bunlar belirtilmelidir.

    - Bir sınıf bir arayüzü implements anahtar sözcüğü ile destekler (implementation), abstract sınıftan
    ise extends anahtar sözcüğü ile türetilebilir.Burada arayüzler için türetme teriminin kullanılmadığına dikkat ediniz

    - Bir sınıf istediği kadar arayüzü destekleyebilir, ancak tek bir sınıftan türetilebilir

    - Arayüzler arasında çoklu türetme yapılabilir. Ancak sınıflar arasında çoklu türetme geçersizdir.

    - Arayüzler türünden nesne hiç bir şekilde yaratılmaz, abstract sınıf türünden nesne türemiş sınıf nesnesi içerisinde
     otomatik olarak yaratılır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir tür ne zaman interface ne zaman abstract sınıf yapılmalıdır? Programcı buna nasıl karar verecektir?
	Bu durumda yeni başlayanlar için bu sorunun cevabı şöyle özetlenebilir:
	"Önce interface düşünülmeli, interface özellikleri yazacağınız türü karşılamıyorsa (abstract) sınıf tercih edilmelidir"

	interface yapılabildiği yerde abstract sınıf yerine interface yapılması, bu interface'i destekleyen sınıfın başka bir
	sınıftan da türetilmesi olanağını sağlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	ParserApp uygulaması
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.samples.parser.ParserApp;

class App {
    public static void main(String[] args)
    {
        ParserApp.run();
    }
}

package org.csystem.app.samples.parser;

import java.util.Scanner;

public final class ParserApp {
    private ParserApp()
    {
    }
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Parser parser = new Parser();

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String s = kb.nextLine();

            if ("elma".equals(s))
                break;

            StringISource ss = new StringISource(s);
            CharArrayISource cs = new CharArrayISource(s.trim());

            parser.setSource(ss);

            int digitsCount = parser.doParseForDigits();
            int whitespacesCount = parser.doParseForWhitespaces();

            System.out.printf("Rakam sayısı:%d%n", digitsCount);
            System.out.printf("Boşluk sayısı:%d%n", whitespacesCount);
            System.out.println("--------------------------------------");

            parser.setSource(cs);

            digitsCount = parser.doParseForDigits();
            whitespacesCount = parser.doParseForWhitespaces();

            System.out.printf("Rakam sayısı:%d%n", digitsCount);
            System.out.printf("Boşluk sayısı:%d%n", whitespacesCount);
            System.out.println("--------------------------------------");
        }
    }
}

package org.csystem.app.samples.parser;

public interface ISource {
    int getNextChar();
    void reset();
}

package org.csystem.app.samples.parser;

public class Parser {
    private ISource m_source;

    public Parser()
    {
    }

    public Parser(ISource source)
    {
        setSource(source);
    }

    public void setSource(ISource source)
    {
        //...
        m_source = source;
    }

    public int doParseForDigits()
    {
        m_source.reset();
        int count = 0;
        int c;

        while ((c = m_source.getNextChar()) != -1)
            if (Character.isDigit(c))
                ++count;

        return count;
    }

    public int doParseForWhitespaces()
    {
        m_source.reset();
        int count = 0;
        int c;

        while ((c = m_source.getNextChar()) != -1)
            if (Character.isWhitespace(c))
                ++count;

        return count;
    }
    //...
}
package org.csystem.app.samples.parser;

public class StringISource implements ISource {
    private final String m_str;
    private int m_index;

    public StringISource(String str)
    {
        m_str = str;
    }

    public int getNextChar()
    {
        return m_index == m_str.length() ? -1 : m_str.charAt(m_index++);
    }

    public void reset()
    {
        m_index = 0;
    }
}

package org.csystem.app.samples.parser;

public class CharArrayISource implements ISource {
    private final char [] m_chars;
    private int m_index;

    public CharArrayISource(String str)
    {
        this(str.toCharArray());
    }

    public CharArrayISource(char [] chars)
    {
        m_chars = chars;
    }

    public int getNextChar()
    {
        return m_index == m_chars.length ? -1 : m_chars[m_index++];
    }

    public void reset()
    {
        m_index = 0;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    09.05.2021
    Arayüzlerle İlgili Tür Dönüştürmeleri

    Arayüzlerle ilgili tür dönüştürmeleri dört durum olarak ele alınabilir:

    1. Bir sınıf referansının onun desteklediği bir arayüz referansına dönüştürülmesi

    2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi

    3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi

    4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	1. Bir sınıf referansının onun desteklediği bir arayüz referansına dönüştürülmesi doğrudan yapılabilir
	Bu durum çok aşikar bir durumdur. Arayüz referansının taban sınıf referansı gibi kullanılmasıdır. Zaten interface'in
	hedeflerinden biri de budur.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();

        IX ix;

        ix = a;
    }
}

class A implements IX {

}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi:
	Bu dönüşüm tür dönüştürme operatörü ile yapılmalıdır. Ancak çalışma zamanı sırasında arayüz referansının dinamik
	türünün dönüştürülecek sınıfı kapsayıp kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür. Kapsamıyorsa haksız
	dönüşümdür. ClassCastException nesnesi fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix;

        ix = a;

        B b = (B)ix; //Haklı dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class A extends B implements IX {
    //...
}

class B {
    //...
}

interface IX {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
	2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi:
	Bu dönüşüm tür dönüştürme operatörü ile yapılmalıdır. Ancak çalışma zamanı sırasında arayüz referansının dinamik
	türünün dönüştürülecek sınıfı kapsayıp kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür. Kapsamıyorsa haksız
	dönüşümdür. ClassCastException nesnesi fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix = a;

        B b = (B)ix; //Haksız dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class A implements IX {

}

class B {
    //...
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilmişse doğrudan yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IY iy = a;
        IX ix;

        ix = iy; //upcasting
        //...
    }
}


class A implements IY {

}

interface IY extends IX {
    //...
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse tür dönüştürme
	operatörü ile yapılabilir. Bu durumda çalışma zamanı sırasında kaynak arayüz referansının dinamik türünün hedef
	arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşüdür. Desteklemiyorsa haksız dönüşümdür.
	ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IY iy = a;
        IX ix;

        ix = (IX)iy; //Haklı dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}


class A  implements IY, IX {

}

interface IY {
    //...
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse tür dönüştürme
	operatörü ile yapılabilir. Bu durumda çalışma zamanı sırasında kaynak arayüz referansının dinamik türünün hedef
	arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşüdür. Desteklemiyorsa haksız dönüşümdür.
	ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();
        IY iy = a;
        IX ix = (IX) iy; //Haksız dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}


class A implements IY {
    //...
}

interface IY {
    //...
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse
	tür dönüştürme operatörü ile yapılabilir. Bu durumda çalışma zamanı sırasında kaynak arayüz referansının
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşüdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new B();
        IY iy = a;
        IX ix;

        ix = (IX)iy; //Haklı dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class B extends A implements IX {
    //...
}

class A implements IY {
    //...
}

interface IY {
    //...
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse
	tür dönüştürme operatörü ile yapılabilir. Bu durumda çalışma zamanı sırasında kaynak arayüz referansının
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşüdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new B();
        IY iy = a;
        IX ix;

        ix = (IX)iy; //Haksız dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class B extends A {
    //...
}

class A implements IY {
    //...
}

interface IY {
    //...
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi:
	Bu işlem tür dönüştürme operatörü ile yapılabilir. Çalışma zamanı sırasında kaynak referansın
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşümdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new B();
        IX ix;

        ix = (IX)a; //Haklı dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class B extends A implements IX {
    //...
}

class A {
    //...
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi:
	Bu işlem tür dönüştürme operatörü ile yapılabilir. Çalışma zamanı sırasında kaynak referansın
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşümdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new B();
        IX ix = (IX)a; //Haksız dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class B extends A {
    //...
}

class A {
    //....
}

interface IX {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Nesne Klonlanması: Bir nesnenin o anki durumunun (state) kopyasının çıkartılmasına klonlama denir. Klonlama işleminden
    sonra her iki nesne de ayrı nesneler olarak yaşamaya devam ederler.

    Bir nesnenin kopyası kendisi tarafından çıkartılabilir. Çünkü sınıfın private veri elemanları olabilir. Bu
    elemanların da kopyasının çıkartılması gerekir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Cloneable arayüzü: Bu arayüz bir nesnenin klonlanabileceğini belirtir. Bu arayüzü destekleyen sınıflar clone
	isimli bir metodu yazarlar. Aslında Cloneable arayüzü işaretleme arayüzüdür. Maalesef bu yanlış bir tasarımdır.
	Bu arayüzü destekleyen sınıflar Object sınıfının içerisinde protected olarak bildirilmiş clone metodunu override
	ederler. clone metodu zorunlu olmasa da Cloneable arayüzünü destekleyen sınıflar için public override edilmelidir.
	Bunun pratikte istisnası yoktur ve olmamalıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir klonlama işlemi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(10);

        System.out.println("s:");
        s.foo();
        System.out.printf("s.x=%d%n", s.getX());

        System.out.println("----------------------------------");

        Sample clone = (Sample)s.clone();

        System.out.println("clone:");
        clone.foo();
        System.out.printf("clone.x=%d%n", clone.getX());

        System.out.println("----------------------------------");
        System.out.println("s:");
        s.foo();
        System.out.printf("s.x=%d%n", s.getX());
    }
}

class Sample implements Cloneable {
    private final int m_x;
    private boolean m_flag;

    public Sample(int x)
    {
        m_x = x;
    }

    public int getX() {return m_x;}

    public void foo()
    {
        System.out.printf("Before:m_flag=%b%n", m_flag);
        m_flag = !m_flag;
        System.out.printf("After:m_flag=%b%n", m_flag);
    }

    public Object clone()
    {
        Sample s = new Sample(m_x);

        s.m_flag = m_flag;

        return s;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf içerisinde bir referans bildirilmişse kopyalama işlemi iki şekilde yapılabilir: sığ (shallow) kopyalama,
	derin (deep) kopyalama

	Kopyalanacak nesneye ilişkin sınıfın içinde bulunan referansa ilişkin nesnenin kopyası çıkartılmıyor ise sığ kopyalama,
	çıkartılıyor ise derin kopyalamadır.

	Derin kopyalama yapabilmek için içerde tutulan referansa ilişkin sınıfın da Cloneable olması gerekir.

	Sınıf tasarımında clone metoduna bakılarak kopyalamanın derin veya sığ olup olmadığı anlaşılamaz. Bu durum
	sınıfın clone metodunun dökümantasyonuna bakılarak anlaşılabilir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir sığ kopyalama (shallow copy) örneği
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A(10);
        B b = new B(23, a);

        B clone = (B)b.clone();

        System.out.printf("b.a.x=%d%n", b.getA().getX());
        System.out.printf("clone.a.x=%d%n", clone.getA().getX());
        System.out.printf("b.y=%d%n", b.getY());
        System.out.printf("clone.y=%d%n", clone.getY());

        System.out.println("-----------------------------------");
        b.getA().setX(45);
        b.setY(89);

        System.out.printf("b.a.x=%d%n", b.getA().getX());
        System.out.printf("clone.a.x=%d%n", clone.getA().getX());
        System.out.printf("b.y=%d%n", b.getY());
        System.out.printf("clone.y=%d%n", clone.getY());
    }
}

class B implements Cloneable {
    private int m_y;
    private A m_a;

    public B(int y, A a)
    {
        m_y = y;
        m_a = a;
    }

    public int getY()
    {
        return m_y;
    }

    public void setY(int y)
    {
        m_y = y;
    }

    public A getA()
    {
        return m_a;
    }

    public void setA(A a)
    {
        m_a = a;
    }

    public Object clone()
    {
        return new B(m_y, m_a);
    }
}

class A {
    private int m_x;

    public A(int x)
    {
        m_x = x;
    }

    public int getX()
    {
        return m_x;
    }

    public void setX(int x)
    {
        //...
        m_x = x;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir derin kopyalama (deep copy) örneği
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A(10);
        B b = new B(23, a);

        B clone = (B)b.clone();

        System.out.printf("b.a.x=%d%n", b.getA().getX());
        System.out.printf("clone.a.x=%d%n", clone.getA().getX());
        System.out.printf("b.y=%d%n", b.getY());
        System.out.printf("clone.y=%d%n", clone.getY());
        System.out.println("-----------------------------------");

        b.getA().setX(45);
        b.setY(89);

        System.out.printf("b.a.x=%d%n", b.getA().getX());
        System.out.printf("clone.a.x=%d%n", clone.getA().getX());
        System.out.printf("b.y=%d%n", b.getY());
        System.out.printf("clone.y=%d%n", clone.getY());
    }
}

class B implements Cloneable {
    private int m_y;
    private A m_a;

    public B(int y, A a)
    {
        m_y = y;
        m_a = a;
    }

    public int getY()
    {
        return m_y;
    }

    public void setY(int y)
    {
        m_y = y;
    }

    public A getA()
    {
        return m_a;
    }

    public void setA(A a)
    {
        m_a = a;
    }

    public Object clone()
    {
        return new B(m_y, (A)m_a.clone());
    }
}

class A implements Cloneable {
    private int m_x;

    public A(int x)
    {
        m_x = x;
    }

    public int getX()
    {
        return m_x;
    }

    public void setX(int x)
    {
        m_x = x;
    }
    public Object clone()
    {
        return new A(m_x);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	clone metodu aşağıdaki gibi override edilirse (covariant return type) downcasting yapılmadan da çağrılabilir.
	Ancak bu yaklaşım Java' da çok tercih edilmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(10);

        System.out.println("s:");
        s.foo();

        Sample clone = s.clone();

        System.out.println("clone:");
        clone.foo();

        System.out.println("s:");
        s.foo();
    }
}

class Sample implements Cloneable {
    private final int m_x;
    private boolean m_flag;

    public Sample(int x)
    {
        m_x = x;
    }

    public int getX() {return m_x;}

    public void foo()
    {
        System.out.printf("Before:m_flag=%b%n", m_flag);
        m_flag = !m_flag;
        System.out.printf("After:m_flag=%b%n", m_flag);
    }

    public Sample clone()
    {
        Sample s = new Sample(m_x);

        s.m_flag = m_flag;

        return s;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfı sığ kopyalama yapar. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList devices = new ArrayList();

        devices.add(new DeviceInfo(1, "test", 5050));
        devices.add(new DeviceInfo(2, "sensor", 5051));
        devices.add(new DeviceInfo(3, "mest", 5698));

        System.out.printf("devices:%s%n", devices);

        ArrayList clone = (ArrayList)devices.clone();

        System.out.printf("clone:%s%n", clone);

        System.out.println("----------------------------------------");

        ((DeviceInfo)clone.get(1)).setName("SENSOR");

        System.out.printf("devices:%s%n", devices);
        System.out.printf("clone:%s%n", clone);
    }
}

class DeviceInfo {
    private int m_id;
    private String m_name;
    private int m_port;

    public DeviceInfo() {}

    public DeviceInfo(int id, String name, int port)
    {
        //...
        m_id = id;
        m_name = name;
        m_port = port;
    }

    public int getId()
    {
        return m_id;
    }

    public void setId(int id)
    {
        //...
        m_id = id;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }

    public String toString()
    {
        return String.format("[%d]%s:%d", m_id, m_name, m_port);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte clone referansına ilişkin nesnenin (ArrayList) içerisindeki bir bilgi değiştirilmiştir.
	Yani artık clone yeni adresteki nesneyi görmektedir. Orjinal nesne bundan etkilenmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList devices = new ArrayList();

        devices.add(new DeviceInfo(1, "test", 5050));
        devices.add(new DeviceInfo(2, "sensor", 5051));
        devices.add(new DeviceInfo(3, "mest", 5698));

        System.out.printf("devices:%s%n", devices);

        ArrayList clone = (ArrayList)devices.clone();

        System.out.printf("clone:%s%n", clone);

        System.out.println("-----------------------------------------------");

        clone.set(1, new DeviceInfo(2, "SENSOR", 6767));

        System.out.printf("devices:%s%n", devices);
        System.out.printf("clone:%s%n", clone);
    }
}

class DeviceInfo {
    private int m_id;
    private String m_name;
    private int m_port;

    public DeviceInfo() {}

    public DeviceInfo(int id, String name, int port)
    {
        //...
        m_id = id;
        m_name = name;
        m_port = port;
    }

    public int getId()
    {
        return m_id;
    }

    public void setId(int id)
    {
        //...
        m_id = id;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }
    public String toString()
    {
        return String.format("[%d]%s:%d", m_id, m_name, m_port);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte devices referansına ilişkin ArrayList nesnesine yeni bir eleman eklenmiştir. clone
	referansına ilişkin ArrayList nesnesinin bundan haberi olmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList devices = new ArrayList();

        devices.add(new DeviceInfo(1, "test", 5050));
        devices.add(new DeviceInfo(2, "sensor", 5051));
        devices.add(new DeviceInfo(3, "mest", 5698));

        System.out.printf("devices:%s%n", devices);

        ArrayList clone = (ArrayList)devices.clone();

        System.out.printf("clone:%s%n", clone);

        System.out.println("------------------------------------------------");

        devices.add(new DeviceInfo(5, "weathersensor", 9898));

        System.out.printf("devices:%s%n", devices);
        System.out.printf("clone:%s%n", clone);
    }
}

class DeviceInfo {
    private int m_id;
    private String m_name;
    private int m_port;

    public DeviceInfo() {}

    public DeviceInfo(int id, String name, int port)
    {
        //...
        m_id = id;
        m_name = name;
        m_port = port;
    }

    public int getId()
    {
        return m_id;
    }

    public void setId(int id)
    {
        //...
        m_id = id;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }
    public String toString()
    {
        return String.format("[%d]%s:%d", m_id, m_name, m_port);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.collection.CSDArrayList;

class App {
    public static void main(String [] args)
    {
        CSDArrayList devices = new CSDArrayList();

        devices.add(new DeviceInfo(1, "test", 5050));
        devices.add(new DeviceInfo(2, "sensor", 5051));
        devices.add(new DeviceInfo(3, "mest", 5698));

        System.out.printf("devices:%s%n", devices);

        CSDArrayList clone = (CSDArrayList)devices.clone();

        System.out.printf("clone:%s%n", clone);

        System.out.println("----------------------------------------");

        ((DeviceInfo)clone.get(1)).setName("SENSOR");

        System.out.printf("devices:%s%n", devices);
        System.out.printf("clone:%s%n", clone);
    }
}

class DeviceInfo {
    private int m_id;
    private String m_name;
    private int m_port;

    public DeviceInfo() {}

    public DeviceInfo(int id, String name, int port)
    {
        //...
        m_id = id;
        m_name = name;
        m_port = port;
    }

    public int getId()
    {
        return m_id;
    }

    public void setId(int id)
    {
        //...
        m_id = id;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }

    public String toString()
    {
        return String.format("[%d]%s:%d", m_id, m_name, m_port);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.collection;

public class CSDArrayList implements Cloneable {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void doWorkForIllegalArgumentException(String message)
    {
        throw new IllegalArgumentException(message);
    }

    private static void doWorkForIndexOutOfBoundsException(String message)
    {
        throw new IndexOutOfBoundsException(message);
    }

    private static void checkCapacityValue(int capacity)
    {
        if (capacity < 0)
            doWorkForIllegalArgumentException("Capacity can not be negative");
    }

    private void checkIndex(int index)
    {
        if (index < 0 || index >= m_index)
            doWorkForIndexOutOfBoundsException("Index out of bounds");
    }

    private void changeCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        System.arraycopy(m_elems, 0, temp, 0, m_index);

        m_elems = temp;
    }

    public CSDArrayList()
    {
        m_elems = new Object[DEFAULT_CAPACITY];
    }

    public CSDArrayList(int capacity)
    {
        checkCapacityValue(capacity);
        m_elems = new Object[capacity];
    }

    public boolean add(Object elem)
    {
        if (m_elems.length == m_index)
            changeCapacity(m_elems.length == 0 ? 1 : m_elems.length * 2);

        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, Object elem)
    {
        //TODO:
    }

    public int capacity()
    {
        return m_elems.length;
    }

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public Object clone()
    {
        CSDArrayList ca = new CSDArrayList(m_elems.length);

        System.arraycopy(m_elems, 0, ca.m_elems, 0, m_index);
        ca.m_index = m_index;

        return ca;
    }

    public void ensureCapacity(int capacity)
    {
        if (capacity < m_elems.length)
            return;

        changeCapacity(Math.max(m_elems.length * 2, capacity));
    }

    public Object get(int index)
    {
        checkIndex(index);

        return m_elems[index];
    }

    public Object set(int index, Object elem)
    {
        checkIndex(index);
        Object oldElem = m_elems[index];

        m_elems[index] = elem;

        return oldElem;
    }


    private Object remove(int index)
    {
        //TODO:
        Object oldVal = m_elems[index];

        //TODO:

        return oldVal;
    }

    public int size()
    {
        return m_index;
    }

    public void trimToSize()
    {
        if (m_index != m_elems.length)
            changeCapacity(m_index);
    }

    public String toString()
    {
        String str = "[";

        for (int i = 0; i < m_index; ++i) {
            if (str.length() != 1)
                str += ", ";

            str += m_elems[i];
        }

        return str + "]";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazı durumlarda nesne içerisinde bir takım kaynaklar (resources) kullanılıyor olabilir. Bu kaynakların kullanılmaya
	başlanmasına mantıksal olarak "kaynağın açılması" dersek kaynak kullanımı bittikten sonra bu kaynağın
	artk mantıksal olarak "kapatılması" yani artık serbest bırakılması gerekebilir. Java' da nesneler garbage collector
	tarafından yok edildiğinden kullanılan kaynağı geri bırakmak için nesnenin ölmesi beklenmez. Çünkü örneğin
	bu kaynak iş bittikten sonra başka bir nesne tarafından tekrar kullanılmaya başlayabilir. Bu durumda eskiden kullanan
	nesne ölmezse yeni nesne bu kaynağın kullanımına başlayamayabilir. Burada kaynak olarak belirttiğimiz bir dosya,
	bir cihaz vb. olabilir. Böylesi bir durumda Closeable arayüzü kullanılır. Closeable arayüzü close metoduna sahiptir.
	Anlatılana benzer kaynağı kullanan sınıf Closeable arayüzünü destekler ve bu sınıfı kullanan programcı (client) kaynakla
	işi bittikten sonra close metodunu çağırır. Java'da Closeable arayüzünü destekleyen bir sınıfı gören programcı
	yukarıdaki anlatılanları bilir ve close metodunu çağırması gerektiğini anlar.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte finally bloğunda çağrılan close metodu try-catch içerisine alınarak checked exception fırlatmasından
	dolayı oluşan error engellenmiştir.	Ancak çoğu zaman (her zaman değil) close metodunun exception fırlatması
	durumu programın ilgileneceği birşey değildir. Yani açık olan bir kaynağın close yapılamaması durumunda çoğu zaman
	programcının yapabileceği birşey yoktur. Dolayısıyla aşağıdaki örnekte finally içerisinde try-catch kullanılması
	checked exception probleminden dolayı yapılmıştır. Yani aslında gereksiz bir kod yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        Connection con  = null;

        try {
            con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
            con.doWork();
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
        finally {
            try {
                if (con != null)
                    con.close();
            }
            catch (Exception ex) {
                //...
            }
        }
    }
}

class Connection implements Closeable {
    private final String m_url;

    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }

    public void close()  throws IOException
    {
        System.out.println("Connection closed");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem aşağıdaki gibi daha az karmaşık ve biraz daha okunabilir olarak çözülebilir.
	Ayrıca bu yaklaşımda close metodu için exception işlenmesi de yapılabilir. Ancak üstteki örnekte close
	için yapılacak exception işlenmesi ayrıca yapılmak zorundadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        Connection con  = null;

        try {
            try {
                con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
                con.doWork();
            }
            finally {
                if (con != null)
                    con.close();
            }
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class Connection implements Closeable {
    private final String m_url;
    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi daha okunabilir hale getirilebilir. Java 7'ye kadar bu tarz örnekler en yalın
	aşağıdakine bezer şekilde yapılabilirdi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        Connection con  = null;

        try {
            ConnectionUtil.doWorkForConnection("postgresql:jdbc://localhost:8080/devicesdb");
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class ConnectionUtil {
    public static void doWorkForConnection(String url) throws IOException
    {
        Connection con = null;

        try {
            con = new Connection(url);
            con.doWork();
        }
        finally {
            if (con != null)
                con.close();
        }
    }
}

class Connection implements Closeable {
    private final String m_url;
    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte eklenen try-with resources (twr) deyimi ile yukarıdaki problem çok daha etkin olarak çözülebilir.
	twr deyimi ile AutoCloseable arayüzünü destekleyen sınıflar kullanılabilir. twr yukarıdaki örnekteki işlemlerin
	otomatik olarak yapılanı biçiminde düşünülebilir. Closeable arayüzü AutoCloseable arayüzünden türetilmiştir.
	Bu deyim ile close metodunun çağrılacağı da garanti altında olduğundan programcının çağırmayı unutması gibi
	bir durum da yaşanmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        try (Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb")) {
            con.doWork();
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class Connection implements Closeable {
    private final String m_url;

    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	twr birden fazla sınıf ile de kullanılabilir. Bu durumda close yaratılma sırasının tersinde çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        try (Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
             Image image = new Image("tatil.png")) {
            con.doWork();
            image.doWork();
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class Connection implements Closeable {
    private final String m_url;
    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }
}


class Image implements Closeable {
    private final String m_filename;

    public Image(String filename)
    {
        //...
        m_filename  = filename;
        System.out.printf("%s image opened%n", m_filename);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on image '%s'%n", m_filename);
    }
    public void close() throws IOException
    {
        System.out.println("Image closed");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	twr paranetezi içerisinde yaratılan nesnelere ilişkin referanslar final kabul edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        try (Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
             Image image = new Image("tatil.png")) {
            con = new Connection("test"); //error
            con.doWork();
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class Connection implements Closeable {
    private final String m_url;
    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }

}

class Image implements Closeable {
    private String m_filename;
    public Image(String filename)
    {
        //...
        m_filename  = filename;
        System.out.printf("%s image opened%n", m_filename);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on image '%s'%n", m_filename);
    }
    public void close() throws IOException
    {
        System.out.println("Image closed");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 9 ile birlikte twr'den önce yaratılmış olan nesnelere ilişkin referanslar da twr parantezi içerisinde
	kullanılabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
        Image image = new Image("tatil.png");

        try (con; image) { //Since Java 9
            con.doWork();
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class Connection implements Closeable {
    private final String m_url;

    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }
}

class Image implements Closeable {
    private final String m_filename;
    public Image(String filename)
    {
        //...
        m_filename  = filename;
        System.out.printf("%s image opened%n", m_filename);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on image '%s'%n", m_filename);
    }
    public void close() throws IOException
    {
        System.out.println("Image closed");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	twr parantezi içerisinde kullanılan referanslar yine final etkisi gösterir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
        Image image = new Image("tatil.png");

        try (con; image) { //error
            con.doWork();
            con = new Connection("test");
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class Connection implements Closeable {
    private final String m_url;
    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }
}

class Image implements Closeable {
    private final String m_filename;
    public Image(String filename)
    {
        //...
        m_filename  = filename;
        System.out.printf("%s image opened%n", m_filename);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on image '%s'%n", m_filename);
    }
    public void close() throws IOException
    {
        System.out.println("Image closed");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	twr parantezi içerisinde kullanılan referanslar yine final etkisi gösterir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String [] args)
    {
        Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
        Image image = new Image("tatil.png");


        try (con; image) { //error
            con.doWork();
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }

        con = new Connection("test");
    }
}

class Connection implements Closeable {
    private final String m_url;
    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }
}

class Image implements Closeable {
    private final String m_filename;
    public Image(String filename)
    {
        //...
        m_filename  = filename;
        System.out.printf("%s image opened%n", m_filename);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on image '%s'%n", m_filename);
    }
    public void close() throws IOException
    {
        System.out.println("Image closed");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	twr bloğu yalnız başına olabilir. Scanner sınıfı Closeable arayüzünü destekler
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try (Scanner kb = new Scanner(System.in)) {
            System.out.print("Bir sayı giriniz:");
            int val = Integer.parseInt(kb.nextLine());

            System.out.println(val * val);
        }
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    14.05.2021
	Generic kavramı derleme zamanında türden bağımsız kod yazabilmek için tasarlanmıştır. Programcı generic bir tür
	ya da metodu türden bağımsız olarak yazar. Generic tür ya da metotları kullanan programcı da hangi türde
	kullanacağına karar vererek aşağıda anlatılan özelliklere göre daha güvenli ve okunabilir kodlar yazabilir.
	Generic'ler kullanılarak derleme zamanında çok biçimli (compile time polymorphism) kodlar yazılabilmektedir.
	Generic olabilecek türler şunlardır: Sınıflar, arayüzler
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıf bildiriminde generic parametreler denen isimler kullanılır. Bu isimler açısal parantezler arasında
	virgülle ayrılacak şekilde sınıf isminden sonra yazılır. Generic parametreler değişken isimlendirme kurallarına
	uygun isimlerdir. Bu isimler bildirildikleri sınıf boyunca geçerlidir (class scope, sınıf faaliyet alanı). Generic
	parametre ismi bir tür ismi anlamına gelir. Generic parametreler tür isimlerinin şablon biçimidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A<T> { // T generic parametre
    //...
    private T m_t;
}


abstract class B<T, K, L> { //T, K ve L generic parametreler
    //...
    public abstract T foo(K k, L l);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıflar açılım ile kullanılabilir. Açılım generic parametrenin türünü belirtir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<String> a; // A nın String açılımı
        A<Integer> b; // A nın Integer açılımı
        A<Boolean> c; // A nın Boolean açılımı
    }
}

class A<T> { // T generic parametre
    //...
    private T m_t;
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıf açılımsız kullanılırsa generic parametreler Object kabul edilir. Ancak bu tamamen açılım
	anlamına gelmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a; // T Object kabul edilir

        //...
    }
}

class A<T> { // T generic parametre
    //...
    private T m_t;
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic açılımlar temel türlerle yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A<int> a; // error

	}
}

class A<T> { // T generic parametre
	//...
	private T m_t;
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem sarmalayan sınıflar ile açılım yapılarak çözülebilir. Yani generic parametre olarak temel türlerin
	kullanılacağı generic bir sınıf (ve metot) için sarmalayan sınıflar açılımda kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<Integer> x;
        A<Boolean> y;
        A<Float> z;
        //...


    }
}

class A<T> { // T generic parametre
    //...
    private T m_t;
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıflar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<Boolean, String> a;
        A<Integer, Boolean> b;
        //...
    }
}

class A<T, K> {
    //...

}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıflar türünden nesne yaratılması aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<Boolean, String> x;
        A<Integer, Float> y;

        x = new A<Boolean, String>();
        y = new A<Integer, Float>();

        //...
    }
}

class A<T, K> {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte new operatörü ile açılım yapılırken türler yazılmayabilir. Ancak açısal parantezler olmalıdır
	(diamond syntax). Şüphesiz olmaması bir sentaks ya da semantic bir hata oluşturmaz. Ancak kesinlikle kullanımı
	tavsiye edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<Boolean, String> x;
        A<Integer, Float> y;

        x = new A<>(); //Since Java 7 : Diamond syntax
        y = new A<>();

        //...
    }
}

class A<T, K> {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic parametreler için Object kullanılacaksa, Object açılımı yapılması iyi bir tekniktir. Yani generic sınıflar
	açılımsız kullanılmamalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<Object> x = new A<>();

        //...
    }
}

class A<T> {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların generic parametrelerinin kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

abstract class A<T, R> {
    public abstract R get(T t);
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıf generic olmayan bir sınıftan türetilebilir. Bu durumda generic sınıfın her açılımı
	o taban sınıftan türetilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<Boolean> bb = new B<>();
        B<String> bs = new B<>();

        A x;

        x = bs;
        x = bb;

        //...
    }
}


class B<T> extends A {
    //
}


class A {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic olmayan bir sınıf generic bir sınıfın herhangi bir açılımından türetilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();
        A<String> a;

        a = b;

        b.foo("ankara");
        a.foo("istanbul");
        a.foo(10); //error
        A<Integer> ai = b; //error

        //...
    }
}

class B extends A<String> {
    //
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic olmayan bir sınıf generic bir sınıfın herhangi bir açılımından türetilebilir. Aşağıdaki örnekte foo metodu
	override edilmiş ve taban sınıfın foo metodu da çağrılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();
        A<String> a = b;

        a.foo("istanbul");

        //...
    }
}

class B extends A<String> {
    public void foo(String str) //override
    {
        super.foo(str);
        System.out.println(str.toUpperCase());
    }
}


class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte derleme zamanında tür kontrolü dolayısıyla error oluşur (type safety)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();
        A<String> a = b;

        a.foo("ankara");
        a.foo(3.4); //error

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

class B extends A<String> {
    public void foo(String str)
    {
        super.foo(str);
        System.out.println(str.toUpperCase());
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte generic A sınıfı açılımsız kullanıldığından derleme zamanı tür kontrolü yapılamaz. Örneğimiz için
	foo metoduna double türü geçirildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();
        A a = b;

        a.foo(3.4);

        //...
    }
}

class B extends A<String> {
    public void foo(String str)
    {
        super.foo(str);
        System.out.println(str.toUpperCase());
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıf başka bir generic sınıfın bir açılımından türetilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<String> b = new B<>();
        A<Integer> a;

        a = b;

        a.foo(10);
        b.bar("ankara");

        B<Boolean> bb = new B<>();

        a = bb;

        a.foo(23);
        bb.bar(true);
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

class B<T> extends A<Integer> {
    public void bar(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıf başka bir generic sınıftan türetilebilir. Bu durumda türemiş sınıfın her açılımı taban sınıfın o
    açılımından türetilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<Integer> b = new B<>();
        A<Integer> a;

        a = b;

        b.foo(10);
        b.bar(1);

        B<String> b1 = new B<>();
        A<String> a1;

        a1 = b1;
        a1.foo("ankara");
        b1.bar("istanbul");
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

class B<T> extends A<T> {
    public void bar(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte K generic parametresi taban sınıf için kullanılmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<Integer, String> x = new B<>();
        A<String> y;

        y = x;
        x.bar(10, "zonguldak");
        x.foo("ankara");
        y.foo("izmir");

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

class B<T, K> extends A<K> {
    public void bar(T t, K k)
    {
        System.out.println(t);
        System.out.println(k);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte x' in türünden dolayı A<Boolean> açılımına atanamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<Integer, String> x = new B<>();
        A<Boolean> y = x; //error

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

class B<T, K> extends A<K> {
    public void bar(T t, K k)
    {
        System.out.println(t);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfının kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<String> names = new ArrayList<>();

        names.add("ali");
        names.add("veli");
        names.add("selami");

        for (String name : names)
            System.out.println(name.toUpperCase());

        System.out.println("***************");

        for (int i = 0; i < names.size(); ++i) {
            String str = names.get(i);

            System.out.println(str.toUpperCase());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfının kullanımı. Aşağıdaki örnekte foreach döngü deyiminde döngü değişkenine atama yapılmadan önce
	int türüne otomatik kutu açılır. Benzer şekilde add metodu çağrılarında da kutulma yapılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < 10; ++i)
            list.add(i * 10); //auto-boxing

        for (int val : list) //auto-unboxing
            System.out.printf("%d ", val);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte döngü değişkenine atama yapılmadan önce int türüne kutu açıldığı için error ya da exception
	durumu oluşmaz. Yani aslında for-each deyimindeki atama int türünden double türüne doğrudan yapılan atamadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < 10; ++i)
            list.add(i * 10); //auto-boxing

        for (double val : list) //auto-unboxing
            System.out.printf("%f%n", val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki anlatılana göre aşağıdaki for-each döngü deyiminde int türünden short türüne doğrudan atama geçersiz
	olduğundan error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < 10; ++i)
            list.add(i * 10); //auto-boxing

        for (short val : list) //error
            System.out.printf("%f ", val);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Çalışma zamanı sırasında generic bir sınıfın her açılımı aynı türdendir. Yani sınıf generic bile olsa o sınıfa
	ilişkin tek bir tür bulunmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<String> as = new A<>();
        A<Integer> ai = new A<>();
        A<Boolean> ab = new A<>();

        System.out.println(as.getClass().getName());
        System.out.println(ab.getClass().getName());
        System.out.println(ai.getClass().getName());
    }
}

class A<T> {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	CommandPrompt sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.samples.commandprompt;

import org.csystem.util.StringUtil;

import java.util.ArrayList;
import java.util.Scanner;

public class CommandPrompt {
    private static final String [] COMMANDS = {"length", "reverse", "upper", "lower", "change", "gett", "join", "cleart", "elma"};
    private final Scanner m_kb = new Scanner(System.in);
    private final ArrayList<String> m_textList = new ArrayList<>();
    private String m_prompt;

    private static String getCommandByText(String text)
    {
        if (text.length() < 3)
            return "";

        for (String cmdStr : COMMANDS)
            if (cmdStr.startsWith(text))
                return cmdStr;

        return "";
    }

    private static void lengthProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("length bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].length());
    }

    private static void reverseProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("reverse bir tane argüman almalıdır");
            return;
        }

        System.out.println(StringUtil.reverse(commandInfo[1]));
    }

    private static void upperProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("upper bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].toUpperCase());

    }

    private static void lowerProc(String [] commandInfo)
    {
        if (commandInfo.length != 2) {
            System.out.println("lower bir tane argüman almalıdır");
            return;
        }

        System.out.println(commandInfo[1].toLowerCase());
    }

    private void getTextsProc(String [] commandInfo)
    {
        if (commandInfo.length != 1) {
            System.out.println("gett argümansız yazılmalıdır");
            return;
        }

        for (;;) {
            System.out.println("İşlemi sonlandırmak için elma giriniz");
            System.out.print("Yazıyı giriniz:");
            String text = m_kb.nextLine();

            if ("elma".equals(text))
                break;

            m_textList.add(text);
        }
    }

    private void clearTextsProc(String [] commandInfo)
    {
        m_textList.clear();
    }

    private void joinProc(String [] commandInfo)
    {
        String sep = " ";

        if (commandInfo.length != 1)
            sep = StringUtil.join(commandInfo, 1, ' ');

        if (m_textList.isEmpty()) {
            System.out.println("Listede hiç yazı yok");
            return;
        }

        String str = StringUtil.join(m_textList, sep);

        System.out.println(str);
    }

    private void changeProc(String [] commandInfo)
    {
        m_prompt = StringUtil.join(commandInfo, 1, ' ');
    }

    private static void quitProc(String [] commandInfo)
    {
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.println("Tekrar yapıyor musunuz?");
        System.exit(0);
    }
    private void doWorkForCommand(String [] commandInfo)
    {
        switch (commandInfo[0]) {
            case "length":
                lengthProc(commandInfo);
                break;
            case "reverse":
                reverseProc(commandInfo);
                break;
            case "upper":
                upperProc(commandInfo);
                break;
            case "lower":
                lowerProc(commandInfo);
                break;
            case "change":
                changeProc(commandInfo);
                break;
            case "gett":
                getTextsProc(commandInfo);
                break;
            case "cleart":
                clearTextsProc(commandInfo);
                break;
            case "join":
                joinProc(commandInfo);
                break;
            default:
                quitProc(commandInfo);
                break;
        }
    }

    private void parseCommand(String [] commandsInfo)
    {
        String cmdStr = getCommandByText(commandsInfo[0]);

        if (!cmdStr.isEmpty()) {
            commandsInfo[0] = cmdStr;
            doWorkForCommand(commandsInfo);
        }
        else {
            System.out.println("Geçersiz komut");
        }
    }

    public CommandPrompt(String prompt)
    {
        m_prompt = prompt;
    }

    public void run()
    {
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.println("Homework-013 çalışma sorusuna ilişkin bir iskelet");
        System.out.println("Geri kalanları lütfen yapınız");

        for (;;) {
            System.out.print(m_prompt + ">");
            String cmd = m_kb.nextLine().trim();
            parseCommand(cmd.split("[ \t]"));
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.ArrayList;
import java.util.Random;
import static java.lang.Character.isWhitespace;
import static java.lang.Character.toLowerCase;
import static java.lang.Character.toUpperCase;
import static java.lang.Character.isLetter;

public final class StringUtil {
    private static final String ALPHABET_LOWER_TR;
    private static final String ALPHABET_LOWER_EN;
    private static final String ALPHABET_TR;
    private static final String ALPHABET_EN;

    static {
        ALPHABET_LOWER_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
        ALPHABET_LOWER_EN = "abcdefghijklmnopqrstuvwxyz";
        ALPHABET_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ" + ALPHABET_LOWER_TR;
        ALPHABET_EN = "ABCDEFGHIJKLMNOPQRSTUWXVYZ" + ALPHABET_LOWER_EN;
    }

    private StringUtil()
    {
    }

    public static String capitalize(String s)
    {
        return s.isEmpty() ? s : toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
    }

    public static String changeCase(String s)
    {
        char [] c = new char[s.length()];

        for (int i = 0; i < c.length; ++i) {
            char ch = s.charAt(i);

            c[i] = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);
        }

        return String.valueOf(c);
    }

    public static int countString(String s1, String s2)
    {
        int count = 0;

        for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
            ;

        return count;
    }

    public static int countStringIgnoreCase(String s1, String s2)
    {
        return countString(s1.toLowerCase(), s2.toLowerCase());
    }

    public static String getLetters(String s)
    {
        String str = "";
        int length = s.length();


        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);

            if (isLetter(c))
                str += c;
        }

        return str;
    }

    public static String getLongestPalindrome(String text)
    {
        String result = "";

        int end = text.length();

        while (end != 0) {
            int begin = 0;

            while (begin != end) {
                String str = text.substring(begin++, end);

                if (str.length() > 1 && isPalindrome(str) && str.length() > result.length())
                    result = str;
            }

            --end;
        }

        return result;
    }

    public static String getRandomText(Random r, int n, String sourceText)
    {
        int length = sourceText.length();
        char [] c = new char[n];

        for (int i = 0; i < n; ++i)
            c[i] = sourceText.charAt(r.nextInt(length));

        return String.valueOf(c);
    }

    public static String getRandomTextTR(Random r, int n)
    {
        return getRandomText(r, n, ALPHABET_TR);
    }

    public static String getRandomTextTR(int n)
    {
        return getRandomTextTR(new Random(), n);
    }

    public static String [] getRandomTextsTR(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextTR(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static String getRandomTextEN(Random r, int n)
    {
        return getRandomText(r, n, ALPHABET_EN);
    }

    public static String getRandomTextEN(int n)
    {
        return getRandomTextEN(new Random(), n);
    }

    public static String [] getRandomTextsEN(Random r, int n, int minLength, int maxLength)
    {
        String [] texts = new String[n];

        for (int i = 0; i < n; ++i)
            texts[i] = getRandomTextEN(r, r.nextInt(maxLength - minLength) + minLength);

        return texts;
    }

    public static boolean isJavaIdentifier(String s)
    {
        if (s.equals("_"))
            return false; //Java 9 ve sonrası için kdeğişken kontrolü

        if (s.isBlank())
            return false;

        char ch = s.charAt(0);

        if (!Character.isJavaIdentifierStart(ch))
            return false;

        int length = s.length();

        for (int i = 1; i < length; ++i)
            if (!Character.isJavaIdentifierPart(s.charAt(i)))
                return false;

        return true;
    }

    public static boolean isPalindrome(String s)
    {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char cLeft = toLowerCase(s.charAt(left));

            if (!isLetter(cLeft)) {
                ++left;
                continue;
            }

            char cRight = toLowerCase(s.charAt(right));

            if (!isLetter(cRight)) {
                --right;
                continue;
            }

            if (cLeft != cRight)
                return false;

            ++left;
            --right;
        }

        return true;
    }

    public static boolean isPangram(String text, String alphabet)
    {
        int length = alphabet.length();

        for (int i = 0; i < length; ++i)
            if (text.indexOf(alphabet.charAt(i)) == -1)
                return false;

        return true;
    }

    public static boolean isPangramEN(String s)
    {
        return isPangram(s.toLowerCase(), ALPHABET_LOWER_EN);
    }

    public static boolean isPangramTR(String s)
    {
        return isPangram(s.toLowerCase(), ALPHABET_LOWER_TR);
    }

    public static String join(ArrayList<String> list, String sep)
    {
        return join(list, 0, sep);
    }

    public static String join(ArrayList<String>  list, char sep)
    {
        return join(list, 0, sep);
    }

    public static String join(ArrayList<String>  list, int startIndex, char sep)
    {
        return join(list, startIndex, sep + "");
    }

    public static String join(ArrayList<String>  list, int startIndex, String sep)
    {
        String result = "";

        int size = list.size();

        for (int i = 0; i < size; ++i) {
            if (!result.isEmpty())
                result += sep;

            result += list.get(i);
        }

        return result;
    }

    public static String join(String [] str, char sep)
    {
        return join(str, 0, sep);
    }

    public static String join(String [] str, int startIndex, char sep)
    {
        return join(str, startIndex, sep + "");
    }

    public static String join(String [] str, int startIndex, String sep)
    {
        String result = "";

        int length = str.length;

        for (int i = startIndex; i < length; ++i) {
            if (!result.isEmpty())
                result += sep;

            result += str[i];
        }

        return result;
    }

    public static String join(String [] str, String sep)
    {
       return join(str, 0, sep);
    }

    public static String padLeading(String s, int length, char ch)
    {
        return length <= s.length() ? s : (ch + "").repeat(length - s.length()) + s;
    }

    public static String padLeading(String s, int length)
    {
        return padLeading(s, length, ' ');
    }

    public static String padTrailing(String s, int length, char ch)
    {
        return length <= s.length() ? s : s + (ch + "").repeat(length - s.length());
    }

    public static String padTrailing(String s, int length)
    {
        return padTrailing(s, length, ' ');
    }

    public static String removeWhiteSpaces(String s)
    {
        int length = s.length();
        String str = "";

        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);

            if (!isWhitespace(ch))
                str += ch;
        }

        return str;
    }

    public static String reverse(String s)
    {
        char [] c = s.toCharArray();

        ArrayUtil.reverse(c);

        return String.valueOf(c);
    }

    public static String squeeze(String s1, String s2)
    {
        String str = "";
        int length = s1.length();

        for (int i = 0; i < length; ++i) {
            char ch = s1.charAt(i);
            if (!s2.contains(ch + ""))
                str += ch;
        }

        return str;
    }

    public static String trimLeading(String s)
    {
        int i;
        int length = s.length();

        for (i = 0; i < length && isWhitespace(s.charAt(i)); ++i)
            ;

        return s.substring(i);
    }

    public static String trimTrailing(String s)
    {
        int i;

        for (i = s.length() - 1; i >= 0 && isWhitespace(s.charAt(i)); --i)
            ;

        return s.substring(0, i + 1);
    }

    public static String wrapWith(String str, char ch)
    {
        return wrapWith(str, ch, false);
    }

    public static String wrapWith(String str, char ch, boolean trim)
    {
        return wrapWith(str, ch, ch, trim);
    }

    public static String wrapWith(String str, char chBegin, char chEnd)
    {
        return wrapWith(str, chBegin, chEnd, false);
    }

    public static String wrapWith(String str, char chBegin, char chEnd, boolean trim)
    {
        return String.format("%c%s%c", chBegin, trim ? str.trim() : str, chEnd);
    }
}

package org.csystem.games.template;

import java.util.ArrayList;
import java.util.Scanner;

public class GameController {
    private final ArrayList<AbstractGame> m_games = new ArrayList<>();

    private AbstractGame getGameByOption(int option)
    {
        return (AbstractGame)m_games.get(option);
    }

    private void displayMenu()
    {
        int size = m_games.size();

        System.out.println("Oyunlar:");
        for (int i = 0; i < size; ++i) {
            AbstractGame game = m_games.get(i);
            System.out.printf("%d.%s%n", i + 1, game.name);
        }

        System.out.printf("%d.Çıkış%n", size + 1);
        System.out.print("Oyun numarasını giriniz:");
    }

    public void add(AbstractGame game)
    {
        m_games.add(game);
    }

    public void run()
    {
        Scanner kb = new Scanner(System.in);

        int sizep1 = m_games.size() + 1;

        for (;;) {
            if (m_games.isEmpty()) {
                System.out.print("Lütfen oyun yükleyiniz:");
                break;
            }
            this.displayMenu();
            int option = Integer.parseInt(kb.nextLine());

            if (option < 0 || option > sizep1) {
                System.out.println("Geçersiz seçenek");
                continue;
            }

            if (option == sizep1)
                break;

            AbstractGame curGame = getGameByOption(option - 1);

            curGame.run();
        }
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.print("Tekrar yapıyor musunuz?");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfının kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<ArrayList<String>> names = new ArrayList<>();
        ArrayList<String> nameList = new ArrayList<>();

        nameList.add("Ali");
        nameList.add("Veli");

        names.add(nameList);

        nameList = new ArrayList<>();

        nameList.add("Ayşe");
        nameList.add("Fatma");
        nameList.add("Zeynep");

        names.add(nameList);
        for (ArrayList<String> nl : names) {
            for (String name : nl)
                System.out.printf("%s ", name);
            System.out.println();
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic açılımlarda dizi türü de kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<int[]> list = new ArrayList<>();

        list.add(new int[] {1, 2, 3, 4});
        list.add(ArrayUtil.generateRandomArray(10, 10, 20));

        for (int [] a : list) {
            for (int val : a)
                System.out.printf("%d ", val);

            System.out.println();
        }

    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzün herhangi bir açılımını implemente eden bir sınıf içerisinde arayüzün metotları açılıma uygun
	şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Mample m = new Mample();

        s.foo("ankara");
        m.foo(true);
    }
}

class Mample implements IX<Boolean> {
    public void foo(Boolean b)
    {
        System.out.println(b ? "Doğru" : "Yanlış");
    }
}
class Sample implements IX<String> {
    public void foo(String str)
    {
        System.out.println(str.toUpperCase());
    }
}

interface IX<T> {
    void foo(T t);
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzün herhangi bir açılımını implemente eden bir sınıf içerisinde arayüzün metotları açılıma
    uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        StringToLengthConverter stringToLengthConverter = new StringToLengthConverter();
        ArrayList<String> cities = new ArrayList<>();

        cities.add("ankara");
        cities.add("istanbul");
        cities.add("izmir");
        cities.add("zonguldak");

        for (String city : cities)
            System.out.printf("%d ", stringToLengthConverter.convert(city));

        System.out.println();
    }
}

class StringToLengthConverter implements IConverter<String, Integer> {
    //...
    public Integer convert(String str)
    {
        return str.length();
    }
}

interface IConverter<T, R> {
    R convert(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic arayüzlerin bir kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.NumberUtil;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Ön yazıyı giriniz:");
        String prefix = kb.nextLine();

        Random r = new Random();
        NumToTextConverter numToTextConverter = new NumToTextConverter(prefix);

        while (true) {
            int val = r.nextInt(1000 + 999) - 999;

            System.out.printf("%d %s%n", val, numToTextConverter.convert(val));
            if (val == 0)
                break;

        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}


class NumToTextConverter implements IConverter<Integer, String> {
    private final String m_prefix;

    public NumToTextConverter(String prefix)
    {
        m_prefix = prefix;
    }

    public String convert(Integer val)
    {
        return String.format("%s:%s", m_prefix, NumberUtil.numberToText(val));
    }
}

interface IConverter<T, R> {
    R convert(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzü implemente eden bir sınıf içerisinde arayüzün metotları açılıma uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo("ankara");
        s.bar(20);
    }
}

class Sample implements IX<String>, IY<Integer> {
    public void foo(String str)
    {
        System.out.println(str.toUpperCase());
    }

    public void bar(Integer i)
    {
        System.out.println(i * i);
    }
}

interface IX<T> {
    void foo(T t);
}

interface IY<T> {
    void bar(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzü implemente eden bir sınıf içerisinde arayüzün metotları açılıma uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<Boolean> sb = new Sample<>();
        Sample<Double> sd = new Sample<>();
        Sample<String> ss = new Sample<>();

        sb.foo(true);
        sb.bar(false);

        sd.foo(3.4);
        sd.bar(4.5);

        ss.foo("ankara");
        ss.bar("istanbul");
    }
}

class Sample<T> implements IX<T>, IY<T> {
    public void foo(T t)
    {
        System.out.println("foo:");
        System.out.println(t);
    }

    public void bar(T t)
    {
        System.out.println("bar:");
        System.out.println(t);
    }
}

interface IX<T> {
    void foo(T t);
}

interface IY<T> {
    void bar(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzü implemente eden bir sınıf içerisinde arayüzün metotları açılıma uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<String, Boolean> ssb = new Sample<>();
        Sample<Integer, String> sis = new Sample<>();

        ssb.foo(true);
        ssb.bar("ankara");

        sis.foo("zonguldak");
        sis.bar(10);
    }
}

class Sample<T, K> implements IX<K>, IY<T> {
    public void foo(K k)
    {
        System.out.println("foo:");
        System.out.println(k);
    }

    public void bar(T t)
    {
        System.out.println("bar:");
        System.out.println(t);
    }
}

interface IX<T> {
    void foo(T t);
}

interface IY<T> {
    void bar(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir abstract sınıftan türetilen bir sınıf içerisinde taban sınıfın sanal metotları açılıma uygun şekilde
	override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class MyTask extends AsyncTask<String, String, Integer> {
    public Integer doInBackground(String [] params)
    {
        int val = 10;
        //...

        return val;
    }

    public void onProgressUpdate(String [] progresses)
    {
        //...
    }

    public void onPostExecute(Integer result)
    {
        //...
    }
}

abstract class AsyncTask<Params, Progress, Result> {
    //...
    protected abstract Result doInBackground(Params [] params);

    protected void onProgressUpdate(Progress [] progresses)
    {
        //...
    }

    protected void onPostExecute(Result result)
    {
        //...
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf generic bir arayüzün birden fazla açılımını destekleyemez. Çünkü arakodda tüm açılan generic parametrelerin
	türleri Object olarak ele alınır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample implements IX<Integer>, IX<String> { //error
    public void foo(String t)
    {

    }

    public void foo(Integer t)
    {

    }
}

interface IX<T> {
    void foo(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample<T> implements IX<Integer>, IY<String> { //error
    public void foo(String t)
    {

    }

    public void foo(Integer t)
    {

    }
}

interface IX<T> {
    void foo(T t);
}

interface IY<T> {
    void foo(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic parametrelere kısıt (constraint) verilebilir. Bu işlem için extends anahtar sözcüğü kullanılır. Aşağıdaki
	örnekte Mample sınıfı IX arayüzünü destekleyen bir tür ile açılabilir. Burada aslında Mample sınıfının generic
	parametresi için bir üst sınır verilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Mample<Sample> m;
        Mample<Integer> m1; //error
        //...
    }
}

class Mample<T extends IX> {
    //..
    public void bar(T t)
    {
        t.foo();
    }
}

class Sample implements IX {
    public void foo()
    {
        System.out.println("Sample.foo");
    }
}

interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	int türden bir dizi referansı Integer türden bir dizi referansına atanamaz. Aslında sarmalayan sınıf türünden
	dizi ile sarmaladığı sınıf türünden dizi referansları arasında dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<Integer> s = new Sample<>();
        int [] a = {1, 2, 4};

        s.display(a); //error
    }
}

class Sample<T> {
    //...
    public void display(T [] a)
    {
        for (T t : a)
            System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte String türden dizi ile display çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<String> s = new Sample<>();
        String [] cities = {"ankara", "istanbul", "izmir"};

        s.display(cities);
    }
}

class Sample<T> {
    //...
    public void display(T [] a)
    {
        for (T t : a)
            System.out.println(t);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic parametreler temel türler olarak belirlenemeyeceğinden aşağıdaki örnekte int, double ve long türden
	diziler için ayrı sınıflar yazılmıştır. Bu aynı zamanda kutulama işleminin de yapılmamasını sağlar. Çünkü sadece
	generic olan yazılsaydı display metodunu çağıran programcı int türden diziyi Integer türden bir dizi olarak
	oluşturup çağırması gerekirdi. Bu da otomatik kutulama anlamına gelecektir. Üstelik bu kopyalamanın O(n)
	karmaşıklıkta olacağına dikkat ediniz. Bu yaklaşım çok yerde kullanılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<String> sample = new Sample<>();
        IntSample intSample = new IntSample();
        LongSample longSample = new LongSample();
        DoubleSample doubleSample = new DoubleSample();

        String [] names = {"ali", "veli", "selami"};
        int [] a = {1, 2, 3, 4};
        long [] b = {1L, 3L, 6L};
        double [] c = {1.4, 2.89, -3.78};

        sample.display(names);
        intSample.display(a);
        longSample.display(b);
        doubleSample.display(c);
    }
}

class IntSample {
    //...
    public void display(int [] a)
    {
        for (int val : a)
            System.out.printf("%d ", val);

        System.out.println();
    }
}

class LongSample {
    //...
    public void display(long [] a)
    {
        for (long val : a)
            System.out.printf("%d ", val);

        System.out.println();
    }
}

class DoubleSample {
    //....
    public void display(double [] a)
    {
        for (double val : a)
            System.out.printf("%f ", val);

        System.out.println();
    }
}

class Sample<T> {
    public void display(T [] a)
    {
        for (T t : a)
            System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic parametreler temel türler olarak belirlenemeyeceğinden aşağıdaki örnekte int, double ve long türden
	diziler için ayrı metotlar yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<String> sample = new Sample<>();
        String [] names = {"ali", "veli", "selami"};
        int [] a = {1, 2, 3, 4};
        long [] b = {1L, 3L, 6L};
        double [] c = {1.4, 2.89, -3.78};

        sample.display(names);
        sample.display(a);
        sample.display(b);
        sample.display(c);
    }
}

class Sample<T> {
    public void display(long [] a)
    {
        for (long val : a)
            System.out.printf("%d ", val);

        System.out.println();
    }

    public void display(int [] a)
    {
        for (int val : a)
            System.out.printf("%d ", val);

        System.out.println();
    }

    public void display(double [] a)
    {
        for (double val : a)
            System.out.printf("%f ", val);

        System.out.println();
    }

    public void display(T [] a)
    {
        for (T t : a)
            System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıfın türemiş sınıf açılımı aynı generic sınıfın taban sınıf açılımına doğrudan atanamaz (invariant)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < 10; ++i)
            list.add(i * 10);

        Sample.display(list); //error
    }
}

class Sample {
    public static void display(ArrayList<Number> list)
    {
        for (Number n : list)
            System.out.println(n);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıfın türemiş sınıf açılımı aynı generic sınıfın taban sınıf açılımına tür dönüştürme operatörü ile de
	dönüştürülemez (invariant)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < 10; ++i)
            list.add(i * 10);

        Sample.display((ArrayList<Number>)list); //error
    }
}

class Sample {
    public static void display(ArrayList<Number> list)
    {
        for (Number n : list)
            System.out.println(n);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki durum ? extends ile aşağıdaki gibi çözülebilir (covariant)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Integer> integers = new ArrayList<>();

        for (int i = 0; i < 10; ++i)
            integers.add(i * 10);

        Sample.display(integers);

        System.out.println("/////////////////");
        ArrayList<Double> doubles = new ArrayList<>();

        for (double i = 0; i < 1.23; i += 0.1)
            doubles.add(i);

        Sample.display(doubles);
    }
}

class Sample {
    public static void display(ArrayList<? extends Number> list)
    {
        for (Number n : list)
            System.out.println(n);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki foo çağrısı geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Number> list = new ArrayList<>();

        Sample.foo(list);

        ArrayList<Object> listObjects = new ArrayList<>();

        Sample.foo(listObjects); //error
    }
}

class Sample {
    public static void foo(ArrayList<Integer> list)
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıda generic açılım contravariant duruma getirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Number> list = new ArrayList<>();

        Sample.foo(list);

        ArrayList<Object> listObjects = new ArrayList<>();

        Sample.foo(listObjects);
    }
}

class Sample {
    public static void foo(ArrayList<? super Integer> list)
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ? işereti açılımı kullanılmıştır. Bu herhangi bir tür demektir. Ancak Object gibi düşünülmemelidir.
	Bu durumun kullanımı uygulama kursunda ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<?> a;

        a = new A<>();

        a.foo("ankara"); //error
        a.bar();
    }
}

class A<T> {
    public void bar()
    {
        //...
    }

    public void foo(T t)
    {
        System.out.println(t);
    }
}



/*----------------------------------------------------------------------------------------------------------------------
	enum türleri ve exception sınıfları generic olarak bildirilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

enum A<T> { //error
    //...
}

class MyException<T> extends RuntimeException { //error
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	15.05.2021
	Generic metotlar: Java'da metotlar generic olarak yazılabilir. Bu durumda generic parametreler metodun parametreleri
	ve geri dönüş değeri türü için kullanılabilmektedir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Generic metotlar için generic parametreler geri dönüş değerinden önce açısal parantez içerisinde bildirilmelidir.
	Generic metotların çağrısında generic parametre ya da parametrelerin türleri geçilen argümana göre tespit
	edilebiliyorsa (type deduction, type inference)	çağrı tür belirtmeden de yapılabilir. Eğer çağrıda tür ya da
	türler belirtilecekse, metot isminden önce yine açısal parantez içerisinde belirtilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.<String>foo("ankara");
        s.foo("ankara");
        s.foo(10);
        s.foo(true);
    }
}

class Sample {
    public <T> void foo(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki 2 ve 5 numaraları çağrılarda tür açısal parantez ile belirtilmiş olsa da tam uyumlu metotlar çağrılır.
   Dikkat: Tür belirtilse bile String paramatreli metot çağrılır.
   Bu işlem generic bir işin türe özgü olarak farklılaşması gibi durumlarda kullanılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara"); //1
        Sample.<String>foo("ankara"); //2
        Sample.foo(10); //3
        Sample.foo(3.4); //4
        Sample.<Integer>foo(20); //5
    }
}

class Sample {
    public static void foo(String s)
    {
        System.out.println("foo(String)");
    }

    public static void foo(int val)
    {
        System.out.println("foo(int)");
    }

    public static <T> void foo(T t)
    {
        System.out.println("foo(T)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotlarında sınıfların generic parametreleri kullanılamaz. Generic sınıfların
	static elemanları tür belirtmeden sınıf ismi erişilebilir. Tür belirtimi error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara");
        Sample.foo(2.3);
        Sample<Integer>.foo(2);
    }
}

class Sample<T> {
    public void bar(T t)
    {
        System.out.println(t);
    }

    public static void foo(T t) //error
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotlarında sınıfların generic parametreleri kullanılamaz. Bu durumda static
	metotların da generic yapılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara");
        Sample.foo(2.3);

        Sample<String> ss = new Sample<>();
        Sample<Float> sf = new Sample<>();

        ss.bar("ankara");
        sf.bar(3.4F);
    }
}

class Sample<T> {
    public void bar(T t)
    {
        System.out.println(t);
    }

    public static <K> void foo(K k)
    {
        System.out.println(k);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotlarında sınıfların generic parametreleri kullanılamaz. Bu durumda static
	metotların da generic yapılması gerekir. Aşağıdaki örnekte static metodun generic pametresi ile sınıfın generic
	parametresi aynı isimdedir. Bu bir sorun oluşturmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara");
        Sample.foo(2.3);

        Sample<String> s = new Sample<>();

        s.bar("ankara");
    }
}

class Sample<T> {
    public void bar(T t)
    {
        System.out.println(t);
    }

    public static <T> void foo(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotlarında sınıfların generic parametreleri kullanılamaz. Bu durumda static, metotların da
	generic yapılması gerekir. Aşağıdaki örnekte foo bar metotlarının bildirimlerine ve client code içerisinde çağrılarına
	dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara", true);
        Sample.foo(2.3, 's');
        Sample.foo(true, false);

        Sample<Integer, String> s = new Sample<>();

        s.bar(10, "ankara");
    }
}

class Sample<T, K> {
    //...
    public void bar(T t, K k)
    {
        //...
    }

    public static <T, K> void foo(T t, K k)
    {
        System.out.println(t);
        System.out.println(k);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte generic bir sınıfın içerisinde non-static bir metot generic yapılmıştır (member generic). Örnekte
	dikkat edilirse foo metodunun ilk iki parametresinin türleri s referansının bildiriminde belirtilen türlerdir,
	geri kalanlar ise çağrı sırasında geçilen argümanların türlerine göre tespit edilecektir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<Integer, Float> s;

        s = new Sample<>();

        System.out.printf("Result:%s%n", s.foo(10, 3.4F, "ankara", true));
        System.out.printf("Result:%c%n", s.foo(10, 3.4F, 'z', 9L));
        System.out.printf("Result:%b%n", s.foo(10, 3.4F, false, 5.6));
    }
}

class Sample<T, K> {
    //...
    public <L, M> L foo(T t, K k, L l, M m)
    {
        System.out.println(t);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);

        return l;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte generic bar metodunun T ve K parametreli isim olarak sınıfın T ve K parametre isimleriniz gizler
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<Integer, Float> s;

        s = new Sample<>();
        s.foo(10, 3.4F);
        s.bar("ankara", true);
    }
}

class Sample<T, K> {
    //...
    public void foo(T t, K k)
    {
        System.out.println("foo");
        System.out.println(t);
        System.out.println(k);
    }

    public <T, K> void bar(T t, K k)
    {
        System.out.println("bar");
        System.out.println(t);
        System.out.println(k);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte doInBackground metodunun geri dönüş değerinin olmaması durumu için yazılan MyVoid isimli bir sınıf
	açılımda kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

final class MyVoid {
    private MyVoid()
    {}
}

class MyTask extends AsyncTask<String, String, MyVoid> {
    public MyVoid doInBackground(String [] params)
    {
        return null;
    }

    public void onProgressExecute(String [] progresses)
    {
        //...
    }

    public void onPostExecute(MyVoid myVoid)
    {
        //...
    }
}

abstract class AsyncTask<Params, Progress, Result> {
    protected abstract Result doInBackground(Params [] params);
    public void onProgressExecute(Progress [] progresses)
    {
        //...
    }

    public void onPostExecute(Result result)
    {
        //...
    }

    //...
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnekteki gibi durumlar için java.lang paketi içerisinde Void isimli bir yer tutucu (placeholder) sınıf
	vardır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class YourTask extends AsyncTask<Void, String, Void> {
    public Void doInBackground(Void [] params)
    {
        return null;
    }

    public void onProgressExecute(String [] progresses)
    {
        //...
    }

    public void onPostExecute(Void result)
    {
        //...
    }
}

class MyTask extends AsyncTask<String, String, Void> {
    public Void doInBackground(String [] params)
    {
        return null;
    }

    public void onProgressExecute(String [] progresses)
    {
        //...
    }

    public void onPostExecute(Void result)
    {
        //...
    }
}

abstract class AsyncTask<Params, Progress, Result> {
    protected abstract Result doInBackground(Params [] params);
    public void onProgressExecute(Progress [] progresses)
    {
        //...
    }

    public void onPostExecute(Result result)
    {
        //...
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte IRunnable parametreli submit metodundan elde edilen IFuture referansı ile get metodu çağrılır
	geri dönüş değeri (yani IFuture'ın açılımına ilişkin tür) kullanılamaz ya da anlamsızdır. Böylesi durumda IFuture
	? (wildcard) ile kullanılır. Örnek tamamen konuyu anlatmak içindir. Detaylar önemsizdir. Çalışıtırıldığında tamamı
	yazılmadığı için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        ExecutorService executorService = Executors.createExecutorService();

        IFuture<?> runnableFuture = executorService.submit(new MyRunnabble());

        runnableFuture.get();

        IFuture<String> callableFuture = executorService.submit(new MyCallable());

        System.out.printf("Result:%s%n", callableFuture.get());
    }
}

class MyCallable implements ICallable<String> {
    public String call()
    {
        String s = "ankara";

        //...
        return s;
    }
}

class MyRunnabble implements IRunnable {
    //...
    public void run()
    {
        //...
    }
}

class Executors {
    public static ExecutorService createExecutorService()
    {
        //....
        return new ExecutorService();
    }
}

class ExecutorService {
    public IFuture<?> submit(IRunnable runnable)
    {
        //...
        return null; // Öylesine yazıldı. Şüphesiz bir IFuture arayüzünü implemente eden nesnenin referansına geri döner
    }

    public <T> IFuture<T> submit(ICallable<T> callable)
    {
        //...
        return null; // Öylesine yazıldı. Şüphesiz bir IFuture arayüzünü implemente eden nesnenin referansına geri döner
    }
}

interface ICallable<T> {
    T call();
}

interface IRunnable {
    void run();
}

interface IFuture<T> {
    T get();
}


/*----------------------------------------------------------------------------------------------------------------------
	Java'da generic kavramı genel olarak arakoda yansıtılmadığı için aynı paket içerisinde aynı isimde fakat farklı sayıda
	generic parametreye sahip türler bildirilemez
----------------------------------------------------------------------------------------------------------------------*/
package test;

public class Tuple<T> { //error
    //
}

class Tuple<T1, T2> { //error

}

/*----------------------------------------------------------------------------------------------------------------------
    Unit sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Unit;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Unit<String>> units = new ArrayList<>();

        units.add(new Unit<>("ankara"));
        units.add(new Unit<>("istanbul"));

        for (Unit<String> unit : units)
            System.out.println(unit);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Unit sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Unit;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Unit<String>> units = new ArrayList<>();

        units.add(Unit.of("ankara"));
        units.add(Unit.of("istanbul"));

        for (Unit<String> unit : units)
            System.out.println(unit);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Unit sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Unit;

import java.util.ArrayList;

import static org.csystem.util.Unit.of;

class App {
    public static void main(String [] args)
    {
        ArrayList<Unit<String>> units = new ArrayList<>();

        units.add(of("ankara"));
        units.add(of("istanbul"));

        for (Unit<String> unit : units)
            System.out.println(unit);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Unit sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class Unit<T> {
    private final T m_t;

    public static <T> Unit<T> of(T t)
    {
        return new Unit<>(t);
    }

    public Unit(T t)
    {
        m_t = t;
    }

    public T get()
    {
        return m_t;
    }

    //...
    public String toString()
    {
        return String.format("{value: %s}", m_t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Pair sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Pair;
import static org.csystem.util.Pair.of;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Pair<Integer, Device>> devices = new ArrayList<>();

        devices.add(of(1, new Device(1, "test", "192.167.1.234", 30000)));
        devices.add(of(2, new Device(2, "weather", "192.167.2.134", 32000)));

        for (Pair<Integer, Device> devicePair : devices)
            System.out.println(devicePair.getSecond());

        System.out.println("----------------------------");

        for (Pair<Integer, Device> devicePair : devices)
            System.out.println(devicePair);
    }
}

class Device {
    private int m_id;
    private String m_name;
    private String m_host;
    private int m_port;

    public Device(int id, String name, String host, int port)
    {
        //...
        m_id = id;
        m_name = name;
        m_host = host;
        m_port = port;
    }

    public int getId()
    {
        return m_id;
    }

    public void setId(int id)
    {
        //...
        m_id = id;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getHost()
    {
        return m_host;
    }

    public void setHost(String host)
    {
        //...
        m_host = host;
    }

    public int getPort()
    {
        return m_port;
    }

    public void setPort(int port)
    {
        //...
        m_port = port;
    }

    public String toString()
    {
        return String.format("[%d](%s)%s:%d", m_id, m_name, m_host, m_port);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Pair sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Pair;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Pair<Integer, Integer>> points = new ArrayList<>();

        points.add(Pair.of(100, 100));
        points.add(Pair.of(67, -788));

        for (Pair<Integer, Integer> point : points)
            System.out.println(point);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Pair sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class Pair<F, S> {
    private final F m_first;
    private final S m_second;

    public static <F, S> Pair<F, S> of(F first, S second)
    {
        return new Pair<>(first, second);
    }

    public Pair(F first, S second)
    {
        m_first = first;
        m_second = second;
    }

    public F getFirst()
    {
        return m_first;
    }

    public S getSecond()
    {
        return m_second;
    }

    public String toString()
    {
        return String.format("{first: %s, second: %s}", m_first, m_second);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Triple sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Triple;

import java.util.ArrayList;

import static org.csystem.util.Triple.of;

class App {
    public static void main(String [] args)
    {
        ArrayList<Triple<Integer, Integer, Integer>> points = new ArrayList<>();

        points.add(of(100, 200, 67));
        points.add(of(-100, -200, -400));

        for (Triple<Integer, Integer, Integer> point : points)
            System.out.printf("{x: %d, y: %d, z: %d}%n", point.getFirst(), point.getSecond(), point.getThird());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Triple sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class Triple<F, S, T> {
    private final F m_first;
    private final S m_second;
    private final T m_third;

    public static <F, S, T> Triple<F, S, T> of(F first, S second, T third)
    {
        return new Triple<>(first, second, third);
    }

    public Triple(F first, S second, T third)
    {
        m_first = first;
        m_second = second;
        m_third = third;
    }

    public F getFirst()
    {
        return m_first;
    }

    public S getSecond()
    {
        return m_second;
    }

    public T getThird()
    {
        return m_third;
    }

    public String toString()
    {
        return String.format("{first: %s, second: %s, third: %s}", m_first, m_second, m_third);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic parametre türü new operatörü ile kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample<T> {
    private T m_t;

    public Sample(int n)
    {
        m_t = new T(); //error
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kuraldan dolayı generic türden dizi de new operatörü ile doğrudan yaratılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample<T> {
    private T [] m_t;

    public Sample(int n)
    {
        m_t = new T[n]; //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem aşağıdaki gibi yapılarak çözülebilir. Aşağıdaki kodda uyarının problem oluşturduğu bir durumun
	oluşması için çalışma zamanında özel bazı işlemler yapılması gerekir. Çünkü Object dizisinin referansı dışarıya
	Object [] türünden verilmemiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample<T> {
    private T [] m_t;
    private int m_index;

    public Sample(int n)
    {
        m_t = (T []) new Object[n]; //Uyarı önemsiz. Şimdilik görmeyin
    }

    public boolean add(T value)
    {
        if (m_index == m_t.length)
            return false;

        m_t[m_index++] = value;

        return true;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte de Object yaratılmış ve T türüne dönüştürülmüştür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample<T> {
    private T m_t;

    public Sample(int n)
    {
        m_t = (T) new Object(); //Uyarı önemsiz
    }
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneklerde  uyarı vermesinin nedenini anlamak için aşağıdaki örneği inceleyiniz. Örnekte objs referansı
	tamamen	durumu anlatma için bildirilmiş ve public yapılmıştır. Şüphesiz bu şekilde çok anlamı yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample<String> s = new Sample<>(10);

        s.add("ankara");
        s.add("istanbul");

        s.objs[2] = 3;


        for (int i = 0; i < s.size(); ++i) {
            String str = s.get(i);

            System.out.println(str);
        }
    }
}
class Sample<T> {
    private T [] m_t;
    private int m_index;

    public Sample(int n)
    {
        objs = new Object[n];
        m_t = (T []) objs; //Uyarı önemsiz. Şimdilik görmeyin
    }

    public Object[] objs;

    public int size()
    {
        return m_t.length;
    }

    public T get(int i)
    {
        return m_t[i];
    }

    public boolean add(T value)
    {
        if (m_index == m_t.length)
            return false;

        m_t[m_index++] = value;

        return true;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;
import org.csystem.util.collection.CSDArrayList;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        CSDArrayList<String> passwords = new CSDArrayList<>();
        Random r = new Random();

        for (int i = 0; i < 10; ++i)
            passwords.add(StringUtil.getRandomTextTR(r, 7));

        int size = passwords.size();

        for (int i = 0; i < size; ++i)
            System.out.println(passwords.get(i));
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.collection;

public class CSDArrayList<E> implements Cloneable {
    private static final int DEFAULT_CAPACITY = 10;
    private E [] m_elems;
    private int m_index;

    private static void doWorkForIllegalArgumentException(String message)
    {
        throw new IllegalArgumentException(message);
    }

    private static void doWorkForIndexOutOfBoundsException(String message)
    {
        throw new IndexOutOfBoundsException(message);
    }

    private static void checkCapacityValue(int capacity)
    {
        if (capacity < 0)
            doWorkForIllegalArgumentException("Capacity can not be negative");
    }

    private void checkIndex(int index)
    {
        if (index < 0 || index >= m_index)
            doWorkForIndexOutOfBoundsException("Index out of bounds");
    }

    private void changeCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        System.arraycopy(m_elems, 0, temp, 0, m_index);

        m_elems = (E[])temp;
    }

    public CSDArrayList()
    {
        m_elems = (E[])new Object[DEFAULT_CAPACITY];
    }

    public CSDArrayList(int capacity)
    {
        checkCapacityValue(capacity);
        m_elems = (E[])new Object[capacity];
    }

    public boolean add(E elem)
    {
        if (m_elems.length == m_index)
            changeCapacity(m_elems.length == 0 ? 1 : m_elems.length * 2);

        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, E elem)
    {
        //TODO:
    }

    public int capacity()
    {
        return m_elems.length;
    }

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public Object clone()
    {
        CSDArrayList<E> ca = new CSDArrayList<>(m_elems.length);

        System.arraycopy(m_elems, 0, ca.m_elems, 0, m_index);
        ca.m_index = m_index;

        return ca;
    }

    public void ensureCapacity(int capacity)
    {
        if (capacity < m_elems.length)
            return;

        changeCapacity(Math.max(m_elems.length * 2, capacity));
    }

    public E get(int index)
    {
        checkIndex(index);

        return m_elems[index];
    }

    public E set(int index, E elem)
    {
        checkIndex(index);
        E oldElem = m_elems[index];

        m_elems[index] = elem;

        return oldElem;
    }


    private E remove(int index)
    {
        //TODO:
        E oldVal = m_elems[index];

        //TODO:

        return oldVal;
    }

    public int size()
    {
        return m_index;
    }

    public void trimToSize()
    {
        if (m_index != m_elems.length)
            changeCapacity(m_index);
    }

    public String toString()
    {
        String str = "[";

        for (int i = 0; i < m_index; ++i) {
            if (str.length() != 1)
                str += ", ";

            str += m_elems[i];
        }

        return str + "]";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir programın komut satırı argümanı program çalıştırılırken ona geçilen yazılara denir. Komut satırı argümanları
	genellike boşlukla birbirinden ayrılır. Çoğu sistemde bir komut satırı argümanlarını boşluk olsa da birleştirilmek
	için iki tırnak kullanılır. Bir Java uygulamasına geçilen komut satırı argümanları çeşitli yollarla
	elde edilebilse de en kolay yöntem main metodunun parametre değişkeni olan String dizi referansını kullanmaktır.
	Programa geçilen komut satırı argümanları JVM tarafından bir dizi oluşturularak main metoduna argüman olarak geçilir.
	Hiçbir komut satırı argümanı verilmezse bu dizi sıfır elemanlı olur. Dizi yaratılır ancak length değeri sıfırdır.
	Java'da	komut satırı argümanı dizisine sadece komut satırı argümanları geçirilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki program çalıştırılırklen komut satırı argümanı verilmezse length sıfır olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        for (String arg : args)
            System.out.println(arg);
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Komut satırı argümanlarının kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.out.println("Wrong number of arguments");
            System.exit(-1);
        }

        String fullname = args[0] + " " + args[1].toUpperCase();

        System.out.println(fullname);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    21.05.2021
    Dosya İşlemleri

    İkincil belleklerde (Secondary memory) organize edilmiş alanlara dosya (file) denir. Dosyaların isimleri ve özellikleri vardır.
    Dosya işlemleri aslında işletim sistemi tarafından yapılır. İşletim sistemin dosya işlemleri ilgili faaliyetlerinden oluşan
    bölümüne dosya sistemi (file system) denir. Java'nın bu konudaki sınıfları dolaylı olarak işletim sisteminin sistem fonksiyonları
    veya API (Application Programming Interface) fonksiyonlarını çağırmaktadır.

    Bir dosyanın yerini belirten yazısal ifadeye "yol ifadesi (path)" denilmektedir. Windows'ta dizin geçişleri
    '\' karakteri ile UNIX/Linux ve Mac OS X sistemlerinde '/' ile belirtilir. Windows sistemlerinde ayrıca bir de
    sürücü (drive) kavramı vardır. UNIX/Linux sistemlerinde ve Mac OS X sisemlerinde sürücü kavramı yoktur. Windows
    sistemlerinde her sürücünün ayrı bir kökü ve dizin ağacı vardır. Sürücünün kök dizini onun en dış dizinidir.

    Yol ifadeleri mutlak (absolute) ve göreli (relative) olmak üzere ikiye ayrılmaktadır. Eğer sürücü ifadesinden
    sonraki (yol ifadesinde sürücü de belirtilmeyebilir) ilk karakter '\' ise böyle yol ifadelerine mutlak, değilse
    göreli yol ifadeleri denilmektedir. Örneğin:

    "c:\a\b\c.dat"	---> mutlak yol ifadesi
    "\x\y\z.txt"	---> mutlak yol ifadesi
    "x\y\z.txt" 	---> göreli
    "x.txt"			---> göreli

    Benzer şekilde / karakteri ile de aynı durum düşünülebilir. Yani bir yol ifadesinin başında / varsa mutlak yoksa
    göreli yol ifadesidir:

    "c:/a/b/c.dat"	---> mutlak yol ifadesi
    "/x/y/z.txt"	---> mutlak yol ifadesi
    "x/y/z.txt" 	---> göreli
    "x.txt"			---> göreli

    Çalışmakta olan her programın (yani process'in) bir çalışma dizini (current working directory) vardır. Programın
    çalışma dizini göreli yol ifadelerinin çözülmesi için orijin belirtir. Örneğin, programımızın çalışma dizini (cwd)
    "c:\temp" olsun. Biz bu programda "x\y\z.dat" biçiminde bir yol ifadesi kullanırsak toplamda "c:\temp\x\y\z.dat"
    dosyasını belirtmiş oluruz. Prosesin çalışma dizini istenildiği zaman değiştirilebilir. Ancak işin başında genel
    olarak programın çalıştırıldığı dizindir. Örnek Window sistemi için anlatılmıştır. Benzer şekilde örneğin cwd /tmp
    dizini ise "x/y/z.dat" biçimindeki göreli yol ifadesi toplamda "/tmp/x/y/z.dat" biçiminde olacaktır.

    Mutlak yol ifadeleri kök dizinden itibaren çözülür. Windows sistemlerine özgü olarak eğer yol ifadesinde sürücü
    belirtilmemişse prosesin çalışma dizininin bulunduğu sürücü o mutlak yol ifadesindeki sürücü olarak alınır. Örneğin
    prosesin çalışma dizini "d:\temp" olsun. "\a\b\c.dat" mutlak yol ifadesi d'nin kök dizininden itibaren yol belirtir yani
    örnekteki yol ifadesi "d:\a\b\c.dat" olacarak ele alınır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Java'da process'in çalışma dizini System sınıfının getProperty metoduna "user.dir" string sabiti argüman olarak
    geçilerek elde edilebilir. Bununla birlikte process'in çalışma dizinini değiştirmek için System sınıfının setProperty
    metodu yine "user.dir" string sabiti ile kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        if (args.length > 1) {
            System.out.println("Wrong number of arguments");
            System.exit(-1);
        }

        String cwd = System.getProperty("user.dir");

        System.out.printf("Current working directory:%s%n", cwd);

        if (args.length > 0)
            System.setProperty("user.dir", args[0]);

        cwd = System.getProperty("user.dir");

        System.out.printf("Current working directory:%s%n", cwd);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aslında Java'da sisteme yönelik çoğu bilgi de "user.dir" gibi çeşitli isimlerle alınabilir. Şüphesiz bunların hepsinin
    değiştirilmesinin anlamı yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        System.out.println(System.getProperty("java.version"));
        System.out.println(System.getProperty("os.version"));
        System.out.println(System.getProperty("os.name"));
        System.out.println(System.getProperty("os.arch"));
        System.out.println(System.getProperty("java.vendor"));
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Windows’ta dosya ve dizin isimlerinin büyük harf küçük harf duyarlılığı yoktur. Windows dosyanın ismini bizim
	belirttiğimiz gibi saklar. Ancak işleme sokarken büyük harf küçük harf farkını dikkate almaz. Ancak UNIX/Linux
	sistemlerinde (Mac OS X dahil) dosya ve dizin isimlerinin büyük harf küçük harf duyarlılığı vardır. Yol ifadelerinde
	kullanabileceğimiz iki özel dizin ismi vardır. Bunlar “.” ve “..” isimleridir. “.” o anda belirtilen dizinin aynısı,
	“..” ise o anda belirtilen dizinin üst dizini anlamına gelir. Örneğin “a\b\..\c.txt” yol ifadesi aslında “a\x.txt”
	ile eşdeğerdir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Dosya işlemleri sırasında bir çok durum oluşabilir. Örneğin, bir dosya verildiği dizinde
    bulunamayabilir, o anki processin o dosyaya yazma hakkı olmayabilir vs. Bu durumda genel olarak metotlar exception'lar
    fırlatabilmektedir. Programcı bu exceptionlara dikkat etmelidir. Bu exception sınıfları genel olarak IOException
    veya IOException sınıfından türetilmiş olan exception nesneleridir. IOException sınıfının checked bir exception
    sınıfı olduğuna dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Text ve Binary Dosyalar

    Bilgisayar dünyasında içeriklerine göre dosyalar kabaca “text” ve “binary” dosyalar biçiminde ikiye ayrılmaktadır.
    Aslında bu ayrım tamamen mantıksal düzeydedir. Dosyanın içerisinde ne olursa olsun dosyalar byte topluluklarından
    oluşurlar. Dosyaların uzantıları onların içerisinde ne olduğuna yönelik bir ipucu vermek için düşünülmüştür.
    İçerisinde yalnızca yazıların bulunduğu dosyalara “text” dosyalar, içerisinde yazıların dışında başka birtakım
    bilgilerin de bulunduğu dosyalara “binary” dosyalar denilmektedir. Örneğin notepad’te oluşturmuş olduğumuz dosyalar
    tipik text dosyalardır. Halbuki uzantısı “.exe” olan “.obj” olan dosyaların içerisinde yazı yoktur. Bunlar tipik
    binary dosyalardır. Uzantısı “.doc” olan veya “.docx” olan dosyalar da aslında “binary” dosyalardır. Her ne kadar bu
    dosyaların içerisinde yazılar varsa da yazıların dışında başka metadata bilgileri vardır.

    Text ve binary modda açılan dosyalar için Windows ve Unix/Linux (Mac OS X dahil) sistemlerinde farklılıklar
    bulunmaktadır. Bir dosya text modda açılmışsa ve çalışılan sistem windows ise yazma yapan herhangi bir fonksiyon
    Line feed (LF) ('\n') karakterini yazdığında aslında dosyaya Carriage Return (CR)('\r') ve LF karakterlerinin ikisi
    birden yazılır. Benzer şekilde dosyadan okuma yapan fonksiyonlar çalışılan sistem Windows ise ve dosya text modda
    açılmışsa CRLF karakterlerini yanyana gördüğünde yalnızca LF olarak okuma yaparlar. Bu konu ileride
    detaylandırılacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Java'da dosyalar üzerinde işlem yapan pek çok sınıf vardır. Bu sınıfları iki gruba ayırabiliriz:
    - Dosyanın bütünü üzerinde işlem yapan sınıflar. Örneğin, bir dosyayı silen, kopyalayan, yer değiştiren gibi
    - Dosyanın içerisindeki veriler üzerinde işlem yapan sınıflaar. Örneğin, dosyaya yazma yapan, dosyadan okuma yapan sınıflar.
    Java'da dosya işlemi yapan sınıflar genel olarak java.io ve java.nio paketlerinde bulunmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    File Sınıfı
    Bu sınıf bir dosya ya da dizine (directory) ilişkin bütünsel işlemleri yapan sınıftır. File sınıfının kullanılması
    için önce programcı dosya yolunu vererek bir File nesnesi oluşturur. Sınıfın dosyanın bütünü üzerinde işlem yapan
    birçok yararlı metodu bulunmaktadır. File sınıfının ayrıca başka parametreli ctor'ları da bulunmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    File sınıfı türünden nesne yaratıldığında yol ifadesinin geçerli olup olmadığı kontrol edilmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File file  = new File(args[0]);

        //...
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının exists metodu verilen yol ifadesine ilişkin dosya ya da dizinin varlığını test etmek amaçlı
    kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File file  = new File(args[0]);

        if (file.exists())
            System.out.println("Geçerli yol ifadesi");
        else
            System.out.println("Geçersiz yol ifadesi");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının isDirectory metodu belirtilen yol ifadesinin bir dizin olup olmadığını test eder
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File file  = new File(args[0]);

        if (file.isDirectory())
            System.out.println("Dizin");
        else
            System.out.println("Dizin değil");
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının isFile metodu belirtilen yol ifadesinin bir dosya olup olmadığını test eder.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File file  = new File(args[0]);

        if (file.isFile())
            System.out.println("Dosya");
        else
            System.out.println("Dosya değil");
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    isFile ve isDirectory metotları yol ifadesinin geçersiz olması ya da ne dosya ne de dizin belirten bir
    yol ifadesi olması durumunda false döndürür. Bu durumların ayrıca kontrol edilmesi gerekebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File file  = new File(args[0]);

        if (file.exists())
            if (file.isFile())
                System.out.println("Dosya");
            else if (file.isDirectory())
                System.out.println("Dizin");
            else
                System.out.println("Ne dosya ne de dizindir");
        else
            System.out.println("Geçersiz yol ifadesi");

    }
}


/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının getAbsolutePath isimli metodu ile File sınıfına verilen yol ifadesi mutlak olarak elde edilir.
    Zaten mutlak verilmişse aynısı, mutlak verilmemişse çalışma dizini ile birleştirilmiş hali elde edilir. File sınıfının
    getName isimli metodu ile yol ifadesine ilişkin dosyanın veya dizinin doğrudan ismi elde edilebilir. Benzer şekilde
    getParent isimli metodu ile de dosya ya da dizinin üst dizini (parent) elde edilebilir. geParentFile
    isimli metodu ile üst dizine ilişkin File referansı elde edilebilir. getParent ve getParentFile metotları göreli yol
    ifadesi ile yaratılmış olan bir File nesnesi için null döndürür. Bu durumda en iyi yöntem getAbsoluteFile metodu ile
    mutlak yol ifadesine ilişkin File referansı alınıp getParent veya getParentFile çağrılmadır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File file  = new File(args[0]);

        System.out.printf("Absolute Path:%s%n", file.getAbsolutePath());
        System.out.printf("Name Path:%s%n", file.getName());
        System.out.printf("Parent:%s%n", file.getParent()); //Eğer göreli yol ifadesi ise null döndürür
        System.out.printf("Parent:%s%n", file.getAbsoluteFile().getParent());
        System.out.printf("Parent:%s%n", new File(file.getAbsolutePath()).getParent());
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının delete metodu ilgili yol ifadesinde bulunan dosya ya da dizini silmektedir. Boş olmayan dizinler
    silinemez. Bunun için önce dizinin boşaltılması sonra silinmesi gerekir. File sınıfının delete metodunun geri dönüş
    değeri yol ifadesine ilişkin bilginin silinip silinmediğine ilişkin boolean türündendir. Bu geri dönüş değerinden
    dosyanın hangi sebepten silinemediği anlaşılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File file  = new File(args[0]);

        System.out.println(file.delete() ? "Silindi" : "Silinemedi");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    File nesnesi bir dizin gösteriyorsa bu durumda o dizin içerisindeki dosyalar ve dizinler elde edilebilir. Bir dizin
    içerisindeki dosyaları ve dizinlerin isimleri list metoduyla elde edilebilir. List metodu eğer File nesnesine
    ilişkin yol ifadesi bir dizin değilse veya geçersizse bu durumda null döndürür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File dir  = new File(args[0]);

        String [] files = dir.list();

        if (files != null)
            for (String file : files)
                System.out.println(file);
        else
            System.out.println("Geçersiz yol ifadesi");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki program aşağıdaki gibi de yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File dir  = new File(args[0]);

        if (dir.exists() && dir.isDirectory())
            for (String file : dir.list())
                System.out.println();
        else
            System.out.println("Geçersiz yol ifadesi");

    }
}
/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki program aşağıdaki gibi daha detaylı olarak da yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.fileio.FileListApp;

class App {
    public static void main(String[] args)
    {
        FileListApp.run(args);
    }
}


package org.csystem.app.fileio;

import java.io.File;

public final class FileListApp {
    private FileListApp()
    {
    }

    private static void listFiles(File path)
    {
        for (String file : path.list())
            System.out.println(file);
    }

    public static void run(String [] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File path = new File(args[0]);

        if (path.exists())
            if (path.isDirectory())
                listFiles(path);
            else
                System.out.println("Belirtilen yol ifadesi dizin değil");
        else
            System.out.println("Belirtilen yol ifadesi bulunamadı");
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının listFiles metodu ile o dizin içerisindeki dosya ve dizinler File türünden elde edilebilir. File
    sınıfının getName isimli metodu yol ifadesi içerisindeki dosya ya da dizin ismi elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.fileio.FileListApp;

class App {
    public static void main(String[] args)
    {
        FileListApp.run(args);
    }
}

package org.csystem.app.fileio;

import java.io.File;

public final class FileListApp {
    private FileListApp()
    {
    }

    private static void listFiles(File path)
    {
        for (File file : path.listFiles())
            System.out.println(file.getAbsolutePath());
    }

    public static void run(String [] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File path = new File(args[0]);

        if (path.exists())
            if (path.isDirectory())
                listFiles(path);
            else
                System.out.println("Belirtilen yol ifadesi dizin değil");
        else
            System.out.println("Belirtilen yol ifadesi bulunamadı");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.App <path>
    Program komut satırı argümanı verilmezse klavyeden yol ifadesini isteyecektir. Aldığı yol ifadesine ilişkin dizinin
    içerisindeki dosya ve dizinlerin isimlerini eğer directory ise yanına <DIR> yazarak ekrana basaktır. Eğer directory
    değilse ismini doğrudan ekrana basacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.filelist;

class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        FileListApp.run(args);
    }
}

package org.csystem.app.io.file.filelist;

import java.io.File;

public final class FileListApp {
    private FileListApp()
    {
    }

    private static void listFiles(File path)
    {
        for (File file : path.listFiles())
            System.out.println(file.getAbsolutePath());
    }

    public static void run(String [] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File path = new File(args[0]);

        if (path.exists())
            if (path.isDirectory())
                listFiles(path);
            else
                System.out.println("Belirtilen yol ifadesi dizin değil");
        else
            System.out.println("Belirtilen yol ifadesi bulunamadı");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.App <path>
    Program komut satırı argümanı verilmezse klavyeden yol ifadesini isteyecektir. Aldığı yol ifadesine ilişkin dizinin
    içerisindeki dosya ve dizinlerin isimlerini eğer directory ise yanına <DIR> yazarak ekrana basaktır. Eğer directory
    değilse ismini doğrudan ekrana basacaktır

    Uygulamayı dosyalar için byte cinsinden uzunlukları gösterecek şekilde yazınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.listdirectorycontents;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        ListDirectoryContentsApp.run(args);
    }
}

package org.csystem.app.io.file.listdirectorycontents;

import org.csystem.util.CommandLineUtil;

import java.io.File;
import java.util.Scanner;

public final class ListDirectoryContentsApp {
    private ListDirectoryContentsApp()
    {
    }

    private static void listFiles(File path)
    {
        String postfix = "";
        for (File file : path.listFiles()) {
            if (file.isDirectory())
                postfix = " <DIR>";
            else if (file.isFile())
                postfix = String.format(" %d bytes", file.length());

            System.out.printf("%s%s%n", file.getName(), postfix);
        }
    }

    public static void run(String [] args)
    {
        args = CommandLineUtil.getArguments(args, "Dizin yol ifadesini giriniz", new Scanner(System.in));

        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File path = new File(args[0]);

        if (path.exists())
            if (path.isDirectory())
                listFiles(path);
            else
                System.out.println("Belirtilen yol ifadesi dizin değil");
        else
            System.out.println("Belirtilen yol ifadesi bulunamadı");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının mkdir metodu eğer verilen yol ifadesine ilişkin bir dizin yaratır. Eğer yol ifadesine ilişkin dizin
    varsa bu durumda hiç birşey yapmaz. Metodun geri dönüş değeri dizinin yaratılıp yaratılmadığını gösteren boolean
    türden değerdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File dir = new File(args[0]);

        System.out.println(dir.mkdir() ? "Dizin yaratıldı" : "Dizin yaratılmadı");
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    mkdir metodu yaratılmak istenen dizine ilişkin yol ifadesi geçersizse dizini yaratamaz ve false değerine döner.
    Verilen yol ifadesine ilişkin tüm dizinlerin yaratılabilmesi için mkdirs metodu kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.File;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        File dir = new File(args[0]);

        System.out.println(dir.mkdirs() ? "Dizin yaratıldı" : "Dizin yaratılmadı");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Path Arayüzü, Paths ve Files Sınıfları
    Path arayüzü Java 7 ile eklenmiş dosya ve dizinler üzerinde daha kolay işlem yapılmasını sağlayan bir arayüzdür.
    Kullanımı karışık gibi gözükse de birçok işlemi kolaylaştırmaktadır. Tipik olarak bir Path referansı elde etmek için
    Java 11 ile birlikte of metodu kullanılabilir. Java 11 öncesinde Path referansı elde etmek için genel olarak Paths
    isimli sınıfın get metotları kullanılıyordu. Ancak bu sınıfın dökümanlara göre get metotlarının ileride "deprecated"
    olabileceği söylendiğinden Java 11 sonrası için bu sınıfın kullanımı tavsiye edilmez. Path arayüzü, Paths sınıfı
    ve File sınıfı java.nio.file paketi içerisinde bildirilmiştir.
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfı birçok yararlı static metot barındırır. Aslında File sınıfının da içerisinde bulunan birçok yararlı
    metodu barındırır. Ancak File sınıfında da Files'da olmayan bazı metotlar vardır. Yani programcı Files sınıfını
    File sınıfına yardımcı olarak düşünmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.IOException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        try {
            Path path = Paths.get(args[0]);

            if (Files.exists(path))
                System.out.println(Files.deleteIfExists(path) ? "Silindi" : "Silinemedi");
            else
                System.out.println("Belirtilen yol ifadesi geçersiz");

        }
        catch (DirectoryNotEmptyException ignore) {
            System.out.println("Dolu bir dizin silinemez");
        }
        catch (IOException ignore) {
            System.out.println("Dosya işlemlerine ilişkin bir sorun oluştu");
        }
        catch (Throwable ignore) {
            System.out.println("Belirlenemeyen bir durum oluştu");
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Java 11 ve sonrasında Paths referansı yerine Path sınıfının of isimli metotları kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.IOException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.Files;
import java.nio.file.Path;

class App {
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        try {
            Path path = Path.of(args[0]);

            if (Files.exists(path))
                System.out.println(Files.deleteIfExists(path) ? "Silindi" : "Silinemedi");
            else
                System.out.println("Belirtilen yol ifadesi geçersiz");

        }
        catch (DirectoryNotEmptyException ignore) {
            System.out.println("Dolu bir dizin silinemez");
        }
        catch (IOException ignore) {
            System.out.println("Dosya işlemlerine ilişkin bir sorun oluştu");
        }
        catch (Throwable ignore) {
            System.out.println("Belirlenemeyen bir durum oluştu");
        }
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının copy metotları belirli bir kaynaktan başka bir yere kopyalama yapmak amaçlı kullanılmaktadır. Bu
    metodun bir çok overload'u bulunmaktadır. Path türünden iki argümanla çağrılabilen versiyonu birinci parametrede
    elde edilen path'e ikinci parametredeki path'e doğrudan kopyalanmasını sağlar. Bu metot kaynak (source) path  ile
    belirtilen dosyayı bulamazsa NoSuchFileException fırlatır. Ayrıca hedef (destination-target) path ifadesine ilişkin
    bir dosya mevcutsa bu durumda FileAlreadyExistsException nesnesini fırlatır.
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının aşağıda kullanılan copy metodu CopyOption arayüzü türünden bir referans alır. Bu arayüzü destekleyen
    StandardCopyOption isimli bir enum ile bu argüman verilebilir. REPLACE_EXISTING isimli enum sabiti ile hedef dosya
    varsa bile yenisi ile değiştirilir. REPLACE_EXISTING değeri ile dizin kopyalaması yapıldığında hedef dizin varsa
    ve içi boş değilse DirectoryEmptyException nesnesi fırlatılır. StandardCopyOption enum'nun diğer sabitleri
    burada ele alınmayacaktır. CopyOption parametresi verilmezse bu durumda dosya varsa FileAlreadyExistsException
    nesnesi fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;

class App {
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        try {
            Files.copy(Path.of(args[0]), Path.of(args[1]));
            System.out.println("Kopyalama başarılı...");
        }
        catch (FileAlreadyExistsException ignore) {
            System.out.println("Hedef dosya var kopyalayamazsınız!....");
        }
        catch (IOException ignore) {
            System.out.println("Dosya işlemlerine ilişkin bir sorun oluştu");
        }
        catch (Throwable ignore) {
            System.out.println("Belirlenemeyen bir durum oluştu");
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının move metodu kaynak yol ifadesinden den hedef yol ifadesine taşıma işlemi yapar. copy metoduna
    benzer şekilde kullanılabilir. Bu durumda move metodu da aynı şekilde davranır. Ayrıca move metodu "rename" için de
    kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.IOException;
import java.nio.file.*;

class App {
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.out.println("Geçersiz argümanlar");
            System.exit(-1);
        }

        try {
            Files.move(Path.of(args[0]), Path.of(args[1]));
            System.out.println("Kopyalama başarılı...");
        }
        catch (DirectoryNotEmptyException ignore) {
            System.out.println("Dizin boş değil!...");
        }
        catch (FileAlreadyExistsException ignore) {
            System.out.println("Hedef dosya var kopyalayamazsınız!....");
        }
        catch (IOException ignore) {
            System.out.println("Dosya işlemlerine ilişkin bir sorun oluştu");
        }
        catch (Throwable ignore) {
            System.out.println("Belirlenemeyen bir durum oluştu");
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    04.06.2021
.   Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.App <src> <dest>
    Program komut satırı argümanı verilmezse klavyeden yol ifadesini isteyecektir. src ile aldığı dosyayı dest ile
    aldığı dosya olarak kopyalayacaktır. Hedef dosya varsa hedef dosya ismi ve uzantısının sonuna "-bak" ekelenerek
    yedeklenecektir. Daha önce yedeklenmişse üzerine yazılacaktır. Bu işlemden sonra kopyalama yapılacaktır

    Not: Checked exception mantığının anlaşışlması için IOException fırlatılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.copyandbackup;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        BackupAndCopyApp.run(args);
    }
}


package org.csystem.app.io.file.copyandbackup;

import java.io.IOException;

public final class BackupAndCopyApp {
    private BackupAndCopyApp()
    {
    }

    public static void run(String [] args)
    {
        try {
            BackupAndCopy backupAndCopy = new BackupAndCopy(args);

            backupAndCopy.run();
        }
        catch (IOException ex) {
            System.err.println("Dosya işlemi hatası");
        }
        catch (Throwable ex) {
            System.err.println("Beklenmeyen bir durum oluştu");
        }
    }
}

package org.csystem.app.io.file.copyandbackup;

import static org.csystem.util.CommandLineUtil.*;

import java.io.IOException;
import java.nio.file.*;
import java.util.Scanner;

public class BackupAndCopy {
    private Path m_sourcePath;
    private Path m_destinationPath;

    private void parseCommandLineArgs(String [] args) throws IOException
    {
        if (args.length != 2 && args.length != 0) {
            System.err.println("Kullanım: java CopyAndBackupAopp <kaynak dosya> <hedef dosya>");
            System.exit(-1);
        }

        args = getArguments(args, "Kaynak dosya ve hedef dosya yol ifadelerini giriniz:", new Scanner(System.in));

        if (args.length == 2) {
            m_sourcePath = Path.of(args[0]);
            m_destinationPath = Path.of(args[1]);
        }
        else {
            String [] cmdInfo = args[0].split("[ \t]+");

            m_sourcePath = Path.of(cmdInfo[0]);
            m_destinationPath = Path.of(cmdInfo[1]);
        }
    }

    private void copy(String message) throws IOException
    {
        Files.copy(m_sourcePath, m_destinationPath);
        System.out.println(message);
    }

    private void backupAndCopy() throws IOException
    {
        Files.move(m_destinationPath, Path.of(m_destinationPath.toString() + "-bak"), StandardCopyOption.REPLACE_EXISTING);
        this.copy("Kopyalama başarıyla yapıldı ve yedeklendi");
    }

    private void copy() throws IOException
    {
        try {
            copy("Kopyalama başarıyla yapıldı");
        }
        catch (FileAlreadyExistsException ignore) {
            this.backupAndCopy();
        }
    }

    public BackupAndCopy(String [] args) throws IOException
    {
        this.parseCommandLineArgs(args);
    }

    public void run() throws IOException
    {
        try {
            this.copy();
        }
        catch (NoSuchFileException ignore) {
            System.err.println("Kaynak dosya bulunamadı");
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dosya Verileri Üzerinde İşlem Yapan Sınıflar
    Dosyanın verileri üzerinde işlem yapan sınıflar genel olarak iki kategoriye ayrılmıştır. Dosyaya yazma yapan ve
    okuma yapan sınıflar. Aslında Java'da genel olarak tüm giriş çıkış (input/output) işlemleri iki parça halinde
    yapılmaktadır.

    InputStream ve OutputStream Sınıfları
    Temel giriş çıkış işlemleri için InputStream ve OutputStream isimli iki adet abstract sınıf bulunmaktadır. Bu sınıflar
    sadece dosyalar için değil network gibi diğer kavramlar için de kullanılabilmektedir. Yani Java'da "okuma ve yazma"
    ya da daha genel ismiyle "giriş ve çıkış" işlemleri bu sınıflar ile soyutlanmıştır.

    FileInputStream ve FileOutputStream Sınıfları

    Dosya işlemleri için temel iki sınıf FileInputStream ve FileOutputStream sınıflarıdır. FileOutputStream sınıfı
    OutputStream sınıfından, FileInputStream sınıfı da InputStream sınıfından türetilmiştir. Bu sınıflar Closeable ve
    dolayısıyla AutoCloseable arayüzünü desteklediklerinden “try with resources” deyimi ile kullanılabilirler. Bir
    dosyanın verileri üzerinde işlem yapılmadan önce o dosyanın açılması gerekir. Dosyanın açılması işlemi bu sınıfların
    başlangıç metotları tarafından yapılmaktadır. Kapatılması için de close metodu kullanılmalıdır. Bilindiği gibi
    Java 7 ile eklenen “try with resources” deyimi close işlemini otomatik olarak yapmaktadır. Bu sınıflar java.io paketi
    içerisinde bildirilmişlerdir.

    Dosya Gösterici (file pointer) Kavramı

    Dosyaların uzantılarının işletim sistemi için bir önemi yoktur. Uzantı ne olursa olsun dosyaların içerisinde byte
    yığınları vardır. Biz de temelde dosyalardan byte okuyup onlara byte yazarız. Dosya içerisindeki her bir byte'ın
    ilk byte 0(sıfır) olmak üzere artan sırada bir pozisyon numarası vardır. Buna dosya terminolojisinde ilgili byte’ın
    offset’i denilmektedir. Dosya göstericisi bir imleç gibi (kalemin ucu gibi) düşünülebilir. Dosya göstericisi o anda
    dosyanın neresinden itibaren okuma ya da yazma yapılacağını anlatan bir offset belirtir.
        x x x x x x x x
        0 1 2 3 4 5 6 7
    Bu örnekte dosya göstericisinin 2 numaralı offset'i gösterdiğini düşünelim. Biz artık 2 byte'lık bir okuma yaparsak
    2 ve 3 numaralı offset'teki byte'ları okuruz. Okuma ve yazma metotları okunan ya da yazılan miktar kadar dosya
    göstericisini otomatik ilerletmektedir. Dosya açıldığında dosya göstericisi özel durumlarda açılmamsışda başlangıçta
    0(sıfır)'ıncı offset'tedir. Yazma sırasında dosya göstericisinin gösterdiği yerden itibaren eski bilgiler ezilerek
    yeni bilgiler yazılır. Fakat özel bir durum olarak dosya göstericisi dosyanın sonundaysa dosyaya yazma yapıldığında
    dosya büyütülmektedir. Başka bir deyişle bu durumda dosyaya yazma işlemi ekleme anlamına gelir.

    Dosya Göstericisinin EOF Durumu

    Dosya göstericisinin dosyanın son byte'ından sonraki byte'ı göstermesi durumuna EOF (End Of File) durumu denir.
    EOF durumundan okuma yapılamaz. Fakat dosya göstericisi EOF durumundayken dosyaya yazma yapılabilir. Bu durum
    dosyaya ekleme anlamına gelir. Dosyaya ekleme yapmanın başka bir yolu yoktur. Dosya göstericisinin dosyanın son
    byte’ından sonraki byte’ı göstermesi söz konusu olabilir. Ancak daha ileride bir yeri göstermesi söz konusu değildir.

    Anahtar Notlar: Bazı işletim sistemleri dosyanın sonundan daha ileriye konumlanmaya ve veri yazmaya izin verebilmektedir.
    Bu duruma genel olarak dosya delikleri denir. Aşağı seviyede anlamlıdır. Her işletim sistemi desteklemeyebileceğinden,
    Java seviyesinde doğrudan yapılamaz.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    FileOutputStream sınıfının File türden ve String türden tek parametreli ctor'ları yeni bir dosya yaratıp dosyayı açar.
    Eğer dosya varsa dosyayı sıfırlayarak (yani bilgileri kaybederek) açar. Yazma işlemi için en temel metot bir byte'lık
    bilgiyi yazan write metodudur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileOutputStream;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileOutputStream fos = new FileOutputStream(args[0])) {
            int n = Integer.parseInt(args[1]);
            for (int i = 0; i < n; ++i)
                fos.write((byte)i);
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    FileInputStream sınıfının File türden ve String türden ctor'ları varolan bir dosyayı dosya göstericisi başta olacak
    şekilde açar. Eğer dosya yoksa FileNotFoundException nesnesi fırlatılır. Okuma işlemi en temel olarak read isimli
    bir metot ile yapılabilir. read metodu dosya sonuna gelindiğinde -1 değerine geri döner
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            int val;

            while ((val = fis.read()) != -1)
                System.out.printf("%d ", (byte)val);

            System.out.println();
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    FileOutputStream sınıfının boolean türden parametresi de olan ctor'ları ile bu parametre true ise dosyanın sonuna
    ekleme yapılabilir. Bu parametre false verilmesi tek parametreli ctor'ları ile aynı anlamdadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileOutputStream;
import java.util.Random;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Random r = new Random();

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            int n = Integer.parseInt(args[1]);
            byte [] data = new byte[n];

            r.nextBytes(data);

            for (byte val : data) {
                System.out.printf("%d ", val);
                fos.write(val);
            }

            System.out.println();
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    FileOutputStream sınıfının byte türden dizi parametreli write metotları ile yazma işlemi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileOutputStream;
import java.util.Random;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Random r = new Random();

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            int n = Integer.parseInt(args[1]);
            byte [] data = new byte[n];

            r.nextBytes(data);

            for (byte val : data)
                System.out.printf("%d ", val);

            fos.write(data);

            System.out.println();
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    FileOutputStream sınıfının byte türden dizi parametreli write metotları ile yazma işlemi yapılabilir. Aşağıdaki
    örnekte data dizisinin eleman sayısının yarısından sonraki elemanların değerleri dosyaya yazılmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileOutputStream;
import java.util.Random;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Random r = new Random();

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            int n = Integer.parseInt(args[1]);
            byte [] data = new byte[n];

            r.nextBytes(data);

            for (byte val : data)
                System.out.printf("%d ", val);

            fos.write(data, n / 2, data.length - n / 2);

            System.out.println();
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    FileInputStream sınıfının byte dizi parametreli read metotları byte türden dizinin içerisine dosyadaki bilgileri
    okur. Yani dosyaya yazar. Ne kadar okuduğu miktarı ile de geri döner. Bu durumda programcının ne kadar okunduğu
    miktarına göre dizinin elemanlarını kullanması gerekir. Yani aslında dizinin uzunluğu ya da okumak için verilen sayı
    en fazla ne kadar okunacağını belirtir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            byte [] data = new byte[Integer.parseInt(args[1])];
            int result;

            while ((result = fis.read(data)) > 0) {
                System.out.printf("Okunan byte sayısı:%d%n", result);
                for (int i = 0; i < result; ++i)
                    System.out.printf("%d%n", data[i]);
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz blok uzunluğu");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    FileInputStream sınıfının byte dizi parametreli read metotları byte türden dizinin içerisine dosyadaki bilgileri
    okur. Yani dosyaya yazar. Ne kadar okuduğu miktarı ile de geri döner. Bu durumda programcının ne kadar okunduğu
    miktarına göre dizinin elemanlarını kullanması gerekir. Yani aslında dizinin uzunluğu ya da okumak için verilen sayı
    en fazla ne kadar okunacağını belirtir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            byte [] data = new byte[Integer.parseInt(args[1])];
            int result;

            while ((result = fis.read(data, 0, data.length)) > 0) {
                System.out.printf("Okunan byte sayısı:%d%n", result);
                for (int i = 0; i < result; ++i)
                    System.out.printf("%d%n", data[i]);
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz blok uzunluğu");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması:Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.io.file.copyfile.App <src> <dest> <block size>
    - Programda Files sınıfı kullanılmayacaktır
    - Program src ile belirtilen yol ifadesi ilişkin dosyayı dest ile belirtilen yol ifadesine ilişkin dosyaya kopyalayacaktır
    - Dosya varsa "trucate" edilecektir
    - Dosya bloklar halinde kopayalanack blok uzunluğu da komut satırı argümanından alınacaktır

    Anahtar Notlar: Files kullanılarak yapılanın daha iyi olduğu söylenebilir. Çünkü işletim sistemine özgü bazı özel
    fonksiyolar da Files sınıfının metotları içerisinde kullanılabilir. Tabii ki bu uygulamada da blok miktarı
    ayarlanarak çok büyük dosyalar için de hızlı olması sağlanabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.copyfilewithblock;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        CopyFileApp.run(args);
    }
}

package org.csystem.app.io.file.copyfilewithblock;

import java.io.IOException;

public final class CopyFileApp {
    private CopyFileApp()
    {
    }

    public static void run(String [] args)
    {
        try {
            CopyFile copyFile = new CopyFile(args);

            copyFile.run();
        }
        catch (IOException ex) {
            System.err.println("Dosya işlemi hatası");
        }
        catch (Throwable ex) {
            System.err.println("Beklenmeyen bir durum oluştu");
        }
    }
}

package org.csystem.app.io.file.copyfilewithblock;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyFile {
    private static boolean isValidBlockSize(String str)
    {
        boolean result;

        try {
            result = Integer.parseInt(str) > 0;
        }
        catch (NumberFormatException ignore) {
            result = false;
        }

        return result;
    }

    private static void doCopy(FileInputStream fis, FileOutputStream fos, int blockSize) throws IOException
    {
        byte [] buffer = new byte[blockSize];
        int result;

        while ((result = fis.read(buffer)) > 0)
            fos.write(buffer, 0, result);

        System.out.println("Dosya başarıyla kopyalandı");
    }

    private String m_sourcePath;
    private String m_destinationPath;
    private int m_blockSize;

    private void parseCommandLineArgs(String [] args)
    {
        if (args.length != 3) {
            System.err.println("Geçersiz sayıda argüman");
            System.exit(-1);
        }

        m_sourcePath = args[0];
        m_destinationPath = args[1];
        if (!isValidBlockSize(args[2])) {
            System.err.println("Geçersiz blok sayısı");
            System.exit(-1);
        }
        m_blockSize = Integer.parseInt(args[2]);
    }

    private void copy() throws IOException
    {
        try (FileOutputStream fos = new FileOutputStream(m_destinationPath);
             FileInputStream fis = new FileInputStream(m_sourcePath)) {
            doCopy(fis, fos, m_blockSize);
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Kaynak dosya bulunamadı");
        }
    }

    public CopyFile(String [] args)
    {
        this.parseCommandLineArgs(args);
    }

    public void run() throws IOException
    {
        this.copy();
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması:Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.io.file.copyfile.App <src> <dest> <block size>
    Örnek aşağıdaki gibi Files sınıfının copy metodu ile yapılmıştır. Bu metot bir InputStream'den bir dosyaya
    kopyalama yapar. Benzer şekilde bir dosyadan da OutputStream'e kopyalama yapan bir copy metodu da vardır. Burada
    örnek olarak InputStream bir FileInputStream olarak alınmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.copyfile;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        CopyFileApp.run(args);
    }
}

package org.csystem.app.io.file.copyfile;

import java.io.IOException;

public final class CopyFileApp {
    private CopyFileApp()
    {
    }

    public static void run(String [] args)
    {
        try {
            CopyFile copyFile = new CopyFile(args);

            copyFile.run();
        }
        catch (IOException ex) {
            System.err.println("Dosya işlemi hatası");
        }
        catch (Throwable ex) {
            System.err.println("Beklenmeyen bir durum oluştu");
        }
    }
}

package org.csystem.app.io.file.copyfile;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

public class CopyFile {
    private String m_sourcePath;
    private Path m_destinationPath;

    private void parseCommandLineArgs(String [] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argüman");
            System.exit(-1);
        }

        m_sourcePath = args[0];
        m_destinationPath = Path.of(args[1]);
    }

    private void copy() throws IOException
    {
        try (FileInputStream fis = new FileInputStream(m_sourcePath)) {
            Files.copy(fis, m_destinationPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Dosya başarıyla kopyalandı");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Kaynak dosya bulunamadı");
        }
    }

    public CopyFile(String [] args)
    {
        this.parseCommandLineArgs(args);
    }

    public void run() throws IOException
    {
        this.copy();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   11.06.2021
   Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız
        java org.csystem.app.App file1 file2 ... fileN dest

    - Program file1, file2, file3, ..., fileN ile belirtilen dosyaları birleştirerek dest ile belirtilen dosyaya
    ekleyecektir
    - Files sınıfı ve Path arayüzünü kullanabilirsiniz
    - Program kaynak dosyalardan biri bile yoksa mesaj vererek programı sonlandırmalı ve kopyaladığı bilgi varsa bile
    hedef dosyayı silmelidir
    - TODO: Bir önceki maddeyi öncden dosyaların var olup olmadığına bakarak uygulayınız
    - Hedef dosya varsa üzerine yazılacaktır

    Not: Örnek özellike ArrayList kullanılarak yapılmıştır. İstenirse dizi ile de yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.concatfiles;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        ConcatFilesApp.run(args);
    }
}


package org.csystem.app.io.file.concatfiles;

import java.io.IOException;

public final class ConcatFilesApp {
    private ConcatFilesApp()
    {
    }

    public static void run(String [] args)
    {
        try {
            ConcatFiles concatFiles = new ConcatFiles(args);

            concatFiles.run();
        }
        catch (IOException ex) {
            System.err.println("Dosya işlemi hatası");
        }
        catch (Throwable ex) {
            System.err.println("Beklenmeyen bir durum oluştu");
        }
    }
}

package org.csystem.app.io.file.concatfiles;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.util.ArrayList;

public class ConcatFiles {
    private final ArrayList<Path> m_sourcePaths = new ArrayList<>();
    private File m_destinationFile;

    private void parseCommandLineArgs(String [] args)
    {
        if (args.length < 2) {
            System.err.println("Geçersiz sayıda argüman");
            System.exit(1);
        }

        for (int i = 0; i < args.length - 1; ++i)
            m_sourcePaths.add(Path.of(args[i]));

        m_destinationFile = new File(args[args.length - 1]);
        m_destinationFile.delete();
    }

    private void concat() throws IOException
    {
        try (FileOutputStream fos = new FileOutputStream(m_destinationFile, true)) {
            for (Path path : m_sourcePaths)
                Files.copy(path, fos);
        }
        catch (NoSuchFileException ignore) {
            System.err.println("Kaynak dosya bulunamadı");
            m_destinationFile.delete();
        }
    }

    public ConcatFiles(String [] args)
    {
        this.parseCommandLineArgs(args);
    }

    public void run() throws IOException
    {
        this.concat();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Değerleri Byte Dizisine Dönüştürüp Geri Almak

    Mademki stream tabanlı dosya işlemlerinde bir dosyaya biz write metoduyla bir byte dizisi yazabiliyoruz o halde bir
    bilgiyi dosyaya yazmadan önce onu byte dizisine dönüştürmemiz gerekir. Benzer biçimde dosyadan okuduklarımız da
    aslında bir byte dizisinin içerisine yerleştiriliyor. O halde byte dizisinin içerisine okunan bilgileri de yeniden
    ilgili türe dönüştürmemiz gerekir. Java'da temel bir türü byte türden diziye dönüştürmek ve byte türden diziyi
    ilgili temel türe dönüştürmek için ByteBuffer sınıfı kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    ByteBuffer sınıfı ile int türden bir bilginin byte dizisine çevrilmesi için bir yöntem
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.util.Random;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Random r = new Random();

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            int n = Integer.parseInt(args[1]);
            while (n-- > 0) {
                int val = r.nextInt(100);
                byte[] data = ByteBuffer.allocate(4).putInt(val).array();

                System.out.printf("%d ", val);
                fos.write(data);
            }
            System.out.println();

        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ByteBuffer sınıfının wrap isimli metodu kullanılarak byte türden dizi sarmalanıp ilgili türe dönüştürülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.nio.ByteBuffer;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            byte [] data = new byte[4];
            int result;

            while ((result = fis.read(data)) > 0) {
                int val = ByteBuffer.wrap(data, 0, result).getInt();

                System.out.printf("%d ", val);
            }

            System.out.println();
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz blok uzunluğu");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    String sınıfının getBytes isimli metodu ile bir yazı byte türden bir diziye çevrilebilir. Aşağıdaki örnekte
    yazılar dosyaya yazılırken yazılan yazının başına kaç byte ile tutuldukları da dosyaya eklenmiştir. Bu tasarımda yazılar
    değişken uzunlukla (variable length) tutulmuştur. Örneğin:
    CSD ve oğuz yazılarının dosya içerisinde tutuluşları aşağıdaki gibidir:
    CSD 3 byte'lık bir yazı:
    oğuz 5 byte'lık bir yazı:
    3xxx5yyyyy
    x'ler CSD yazısının her bir byte'ına karşılık gelmektedir
    y'ler oğuz yazısının her bir byte'ına karşılık gelmektedir

    Dikkat edililirse aşağıdaki örnekte programcı tüm bu işlemleri ayarlamak zorundadır. Yani bu işlem bazı durumlarda
    zahmetli olabilmektedir. Java'da aşağı seviyede yapılan bir işlemdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.util.Scanner;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Scanner kb = new Scanner(System.in);

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            for (;;) {
                System.out.print("Bir yazı giriniz:");
                String text = kb.nextLine();

                if ("elma".equals(text))
                    break;

                byte [] data = text.getBytes();
                byte [] dataLen = ByteBuffer.allocate(2).putShort((short)data.length).array();

                fos.write(dataLen);
                fos.write(data);
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    String sınıfının byte türden dizi parametreli ctor elemanı ile bir yazı elde edilebilir. Aşağıdaki işlemlerin
    de zahmetli ve aşağı seviyeli şekilde yapıldığına dikkat ediniz. WriterApp ve ReaderApp örnekleri özellikle
    sadece main içerisinde yazılmıştır. Detaylar gözardı edilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            byte []  dataLen = new byte[2];

            for (;;) {
                int result = fis.read(dataLen);

                if (result == -1)
                    break;

                if (result != 2)
                    throw new IOException("Dosya formatı bozuk");

                short len = ByteBuffer.wrap(dataLen).getShort();
                byte [] data = new byte[len];
                result = fis.read(data);

                if (result != len)
                    throw new IOException("Dosya formatı bozuk");

                String text = new String(data);

                System.out.println(text);
            }
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: UTF8 kodlaması UNICODE tablonun sıkıştırılmış biçimini oluşturmakta kullanılır. UTF8'de UNICODE
    bir yazıdaki İngilizce karakterler 1 byte ile, diğer karakterler birden çok byte ile kodlanırlar. Aslında standart
    ASCII karakterleri 1(bir) byte ile standart olmayanlar birden fazla byte ile tutulur. Bilindiği gibi ASCII tablosunun
    ilk 128 karakteri standarttır ve değişmez. Böylece UTF8 kodlaması ekonomik bir kodlama halini alır. Bu nedenle UTF8
    en çok kullanılan karakter kodlamalarından biridir. String sınıfının parametresiz getBytes metodu ve yalnızca byte []
    parametreli ctor'u plotformun default tablolamasına göre çalışırlar. Bu kavrama "charset veya encoding" denilmektedir.
    Yukarıdaki yazan uygulama örneğin UTF8 ile yazmışsa okuyan uygulamanın default platformu UNICODE ise doğru bilgi elde
    edilemeyebilir. Bu durumlar için Java'da Charset isimli bir arayüz bulunmaktadır. getBytes metodunun ve String'in
    ctor'unun Charset alan versiyonları da bulunmaktadır. Charset en kolay StandardCharsets sınıfının public static ve
    final elemanları ile kullanılabilir.
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
    Yukardaki örneğin platform ne olursa olsun UTF-8 kullanan versiyonu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Scanner kb = new Scanner(System.in);

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            for (;;) {
                System.out.print("Bir yazı giriniz:");
                String text = kb.nextLine();

                if ("elma".equals(text))
                    break;

                byte [] data = text.getBytes(StandardCharsets.UTF_8);
                byte [] dataLen = ByteBuffer.allocate(2).putShort((short)data.length).array();

                fos.write(dataLen);
                fos.write(data);
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukardaki örneğin platform ne olursa olsun UTF-8 kullanan versiyonu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            byte []  dataLen = new byte[2];

            for (;;) {
                int result = fis.read(dataLen);

                if (result == -1)
                    break;

                if (result != 2)
                    throw new IOException("Dosya formatı bozuk");

                short len = ByteBuffer.wrap(dataLen).getShort();
                byte [] data = new byte[len];
                result = fis.read(data);

                if (result != len)
                    throw new IOException("Dosya formatı bozuk");

                String text = new String(data, StandardCharsets.UTF_8);

                System.out.println(text);
            }
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    BitConverter gibi bir sınıf yazılarak byte dizisi ve temel türler (+ string sınıfı) arasındaki dönüşümler
    daha basitleştirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import org.csystem.util.converter.BitConverter;

import java.io.FileOutputStream;
import java.util.Scanner;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Scanner kb = new Scanner(System.in);

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            for (;;) {
                System.out.print("Bir yazı giriniz:");
                String text = kb.nextLine();

                if ("elma".equals(text))
                    break;

                byte [] data = BitConverter.getBytes(text);
                byte [] dataLen = BitConverter.getBytes((short)data.length);

                fos.write(dataLen);
                fos.write(data);
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    BitConverter gibi bir sınıf yazılarak byte dizisi ve temel türler (+ string sınıfı) arasındaki dönüşümler
    daha basitleştirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import org.csystem.util.converter.BitConverter;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            byte []  dataLen = new byte[2];

            for (;;) {
                int result = fis.read(dataLen);

                if (result == -1)
                    break;

                if (result != 2)
                    throw new IOException("Dosya formatı bozuk");

                short len = BitConverter.toShort(dataLen);
                byte [] data = new byte[len];
                result = fis.read(data);

                if (result != len)
                    throw new IOException("Dosya formatı bozuk");

                String text = BitConverter.toString(data);

                System.out.println(text);
            }
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yazma ve Okuma İşlemini Kolaylaştıran Adaptör Sınıflar

    Önceki konularda da gördüğümüz gibi bizim bir blgiyi dosyaya yazabilmemiz için önce onu byte dizisine dönüştürmemiz
    sonra da write metoduyla bu işi yapmamız gerekir. Benzer biçimde bir dosyadan okuma yaparken de biz read metoduyla
    önce istediğimiz bilgiyi byte dizisi olarak okuyup sonra da ilgili türe dönüştürmemiz gerekir. İşte bu işlem biraz
    yorucudur. Üstelik String türü de işin içine girdiğinda yazı değişken uzunlukta tutulacaksa uzunluk bilgisinin
    eklenmesi gibi durumlar da programcının sorumluluğunda olacaktır. Bu işlemleri kendi içerisinde yapan adaptör
    sınıflar vardır. Bu adaptör sınıflar aslında sadece dosya işlemlerinde kullanılmaz. Genel okuma ve yazma sınıflarıdır.
    Yani örneğin bir ağ üzerinde uzak bir makinaya veri gönderme ve alma durumlarında da kullanılabilir.

    Genel olarak yani normal olarak yazma işlemi adaptör sınıfla yapılmışsa okuma işlemi de ilgili adaptör sınıfla ve
    yazmanın okuma karşılığı olan metotla yapılmalıdır. Aksi durumda verinin istenilen kısmı elde edilemeyebilir.

    Anahtar Notlar: Dosyaya yazma yapan ve dosyadan okuma yapan uygulamaların her ikisi de okuma ve yazma işlemini
    adaptör sınıflar kullanarak yaparsa özellikle String yazma ve okuma için sorun oluşmaz. Ancak yazma işlemi farklı bir
    formatta yapılmışsa bu durumda okuma işleminin de yukarıdaki örneklerde olduğu gibi byte dizisi kullanılması
    gerekebilir. Bu durum genel olarak ikili (binary) dosyalar için geçerlidir. Yani örneğin bir dosyaya Java ile bir takım
    bilgiler binary olarak yazılmış ve başka platformlar ile okuma yapılacağı durumda adaptör sınıflar yerine yukarıda
    anlatılan aşağı seviyeli yazma ve okuma işlemleri kullanılır. Bu durum tersine binary formatta yazılmış bir dosyanın
    format bilgisine Java ile okuma yapılması durumunda da geçerlidir. Yani adaptör sınıflar genel olarak okuma ve yazma
    yapan programların her ikisinin de Java ile yazılması durumunda yararlı olur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    DataOutputStream sınıfı:
    DataOutputStream sınıfının writeXXX metotları temel türleri dosyaya yazılabilir. DataOutputStream
    sınıfının bir başlangıç metodu vardır. Bu metot OutputStream referansı alır. Bu sınıfın writeXXX metotları yazdığı
    türü byte dizisine çevirerek OutputStream referansının gösterdiği nesne için write metodunu çağırır. Böylelike
    programcı herhangi bir işlem yapmadan doğrudan istediği temel türü yazabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    DataOutputStream sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.util.Random;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Random r = new Random();

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            int n = Integer.parseInt(args[1]);
            DataOutputStream dos = new DataOutputStream(fos);

            while (n-- > 0) {
                int val = r.nextInt(100);

                System.out.printf("%d ", val);
                dos.writeInt(val);
            }
            System.out.println();

        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    DataInputStream sınıfı:
    DataInputStream sınıfı da DataOutputStream sınıfıyla çok benzer biçimde kullanılmaktadır. Bu sınıf da bizden bir
    InputStream parametresi alır. Sınıfın readXXX isminde metotları vardır. Bu metotlar önce bizim verdiğimiz stream’den
    okumayı yaparlar. Sonra da byte dizisini ilgili türe çevirerek geri döndürürler. readXXX metotları dosya (stream)
    sonuna gelindiğinde EOFException nesnesi fırlatırlar
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    DataInputStream sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.DataInputStream;
import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            DataInputStream dis = new DataInputStream(fis);

            for (;;) {
                int val = dis.readInt();

                System.out.printf("%d ", val);
            }
        }
        catch (EOFException ignore) {

            System.out.println("\nOkuma tamamlandı");
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz blok uzunluğu");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}




/*----------------------------------------------------------------------------------------------------------------------
    DataOutputStream sınıfının writeUTF metodu UTF-8 formatında yazıyı dosyaya (stream'e) yazar. Şüphesiz yazının
    uzunluğu gibi bilgileri kendi içerisinde ayarlar. Yani formatı ona göre oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.util.Scanner;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Scanner kb = new Scanner(System.in);

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            DataOutputStream dos = new DataOutputStream(fos);

            for (;;) {
                System.out.print("Bir yazı giriniz:");
                String text = kb.nextLine();

                if ("elma".equals(text))
                    break;

                dos.writeUTF(text);
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    DataInputStream sınıfının readUTF metodu UTF-8 formatında bilgiyi dosyadan (stream'den) okur. Bu metot da dosya
    sonuna gelindiğinde EOFException fırlatır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.DataInputStream;
import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            DataInputStream dis = new DataInputStream(fis);

            for (;;) {
                String text = dis.readUTF();

                System.out.println(text);
            }
        }
        catch (EOFException ignore) {
            System.out.println("Okuma tamalandığı");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    DataOutputStream sınıfında bir yazıyı dosyaya (stream'e yazan) writeBytes ve writeChar metotları da bulunmaktadır.
    writeBytes metodu her bir karakteri writeByte metoduyla yazar yani 1(bir) byte olarak yazar. Bu durumda birden fazla
    byte ile tutulan karakterler için okumada exception oluşabilir. Çünkü readByte metoduyla 1 byte okunur ve exception
    oluşabilir. Aşağıdaki WriterApp örneğinde dosyaya Türkçe karakterlerden oluşan yazılar ekleyiniz ve ReaderApp ile
    okuma sonucu gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    WriterApp
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.util.Scanner;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Scanner kb = new Scanner(System.in);

        try (FileOutputStream fos = new FileOutputStream(args[0], true)) {
            DataOutputStream dos = new DataOutputStream(fos);

            for (;;) {
                System.out.print("Bir yazı giriniz:");
                String text = kb.nextLine();

                if ("elma".equals(text))
                    break;

                dos.writeBytes(text);
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    ReaderApp
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.DataInputStream;
import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (FileInputStream fis = new FileInputStream(args[0])) {
            DataInputStream dis = new DataInputStream(fis);

            for (;;) {
                byte val = dis.readByte();

                System.out.printf("%c", (char)val);
            }
        }
        catch (EOFException ignore) {
            System.out.println("\nOkuma tamalandı");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    BufferedReader ve BufferedWriter Sınıfları

    BufferedReader ve BufferedWriter sınıfları yazıyla işlem yapan adaptör sınıflardır. Bu sınıfları DataOutputStream
    ve DataInputStream sınıflarının yazı ile işlem yapan biçimlerine benzetebiliriz. BufferedReader ve BufferedWriter
    sınıfları sırasıyla Reader ve Writer türden referansını parametre olarak bizden alırlar. BufferedWriter sınıfının
    write metotları yazdırma işlemini yapmaktadır. Bu durumda dosyayı bir editörle açtığımızda anlamlı şeyler görürürüz.
    Pekiyi DataOutputStream sınıfı ile BufferedWriter sınıfı arasındaki temel fark nedir? DataOutputStream sınıfı
    bilgiyi byte dizisine dönüştürüp dosyaya yazar. Halbuki BufferedWriter sınıfı bilgiyi bir yazı olarak dosyaya yazar.
    BufferedWriter ve BufferedReader sınıfları da yine sadece dosya için değil genel olarak kullanılabilen sınıflardır.

    Anahtar Notlar: Bu sınıflar "tamponlu (buffered)" olarak çalışırlar. Bilginin yazılması hemnen gerçekleşmeyebilir.
    Bu sebeple programcının yazmanın yapılması durumuna göre kod yazması veya basit olarak yazma işleminin tampondan
    dosyaya (stream'e) hemen yazılması için de flush isimli metodu çağırması gerekir. DataOutputStream sınıfının da
    flush isimli bir metodu vardır. Dosya işlemlerinde kullanılması gerekmez. Ancak BufferedWriter için dosya
    işlemlerinde de gerekir. Tamponlu çalışma konusu ayrıntılı bir konudur. Burada detaylar ele alınmayacaktır.

    Daha önce anlatıldığı gibi satır kavramı özellike Windows sistemleri için farklıdır. Yani bir sonraki satırın başına
    geçmek için Windows'da "CRLF" karakter çiftinin kullanıldığını hatırlayınız. Bu sebeple işletim sistemine göre uygun
    satır sonu karakter veya karakterlerinin yazılması için BufferedWriter sınıfının newLine isimli metodu kullanılır.
    BufferedReader ve BufferedWriter sınıfları Closable arayüzünü destekler
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    BufferedWriter sınıfının dosya işlemlerinde  kullanımında nesne yaratmak için FileWriter isimli yine
    adaptör bir sınıfın Writer parametreli ctor'u için kullanılabilir. Dosyalar için genel kalıp aşağıdaki
    gibidir. FileWriter'a charset verilmezse default charset kullanılır. Aşağıdaki örnekte flush işlemi yapılmamıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Scanner kb = new Scanner(System.in);

        try (BufferedWriter bw = new BufferedWriter(new FileWriter(args[0], StandardCharsets.UTF_8, true))) {
            for (;;) {
                System.out.print("Bir yazı giriniz:");
                String text = kb.nextLine();

                if ("elma".equals(text))
                    break;

                bw.write(text);
                bw.newLine();
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örneğin her adımda flush yaparak yazılmış hali
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Scanner kb = new Scanner(System.in);

        try (BufferedWriter bw = new BufferedWriter(new FileWriter(args[0], StandardCharsets.UTF_8, true))) {
            for (;;) {
                System.out.print("Bir yazı giriniz:");
                String text = kb.nextLine();

                if ("elma".equals(text))
                    break;

                bw.write(text);
                bw.newLine();
                bw.flush();
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    BufferedReader sınıfının dosya işlemlerinde kullanımında nesne yaratmak için FileReader isimli yine
    adaptör bir sınıf Reader parametreli ctor'u için kullanılabilir. Dosyalar için genel kalıp aşağıdaki
    gibidir. FileReader'a charset verilmezse default charset kullanılır. Satır satır okuma yapmak için readLine metodu
    kullanılır. readLine metodu dosya sonuna gelindiğinde null döndürür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.BufferedReader;
import java.io.EOFException;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.nio.charset.StandardCharsets;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (BufferedReader br = new BufferedReader(new FileReader(args[0], StandardCharsets.UTF_8))) {
           String line;

           while ((line = br.readLine()) != null)
               System.out.println(line);
        }
        catch (EOFException ignore) {
            System.out.println("\nOkuma tamalandı");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}




/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnek Files sınıfının newBufferedWriter metodu ile de yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Scanner;

final class WriterApp {
    private WriterApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        Scanner kb = new Scanner(System.in);

        try (BufferedWriter bw = Files.newBufferedWriter(Path.of(args[0]), StandardCharsets.UTF_8,
                StandardOpenOption.APPEND, StandardOpenOption.CREATE)) {
            for (;;) {
                System.out.print("Bir yazı giriniz:");
                String text = kb.nextLine();

                if ("elma".equals(text))
                    break;

                bw.write(text);
                bw.newLine();
                bw.flush();
            }
        }
        catch (NumberFormatException ignore) {
            System.err.println("Geçersiz sayı formatı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnek Files sınıfının newBufferedReader metodu ile de yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file;

import java.io.BufferedReader;
import java.io.EOFException;
import java.io.FileNotFoundException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

final class ReaderApp {
    private ReaderApp()
    {
    }
    public static void main(String[] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argümanlar");
            System.exit(-1);
        }

        try (BufferedReader br = Files.newBufferedReader(Path.of(args[0]), StandardCharsets.UTF_8)) {
           String line;

           while ((line = br.readLine()) != null)
               System.out.println(line);
        }
        catch (EOFException ignore) {
            System.out.println("\nOkuma tamalandı");
        }
        catch (FileNotFoundException ignore) {
            System.err.println("Dosya bulunamadı");
        }
        catch (Throwable ex) {
            System.err.printf("Exception:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Klavye işlemleri için BufferedReader sınıfı aşağıdaki gibi kullanılabilir. Sınıfın metotlarının IOException fırlattığına
    dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class App {
    public static void main(String[] args) throws IOException
    {
        BufferedReader kb = new BufferedReader(new InputStreamReader(System.in));

        for (;;) {
            System.out.print("Bir yazı giriniz:");
            String str = kb.readLine();

            if ("elma".equals(str))
                break;
            byte [] data = str.getBytes();

            System.out.printf("Length:%d%n", data.length);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    RandomAccessFile Sınıfı
    RandomAccessFile sınıfı ile dosya üzerinde istenilen offset’e konumlanma yapılarak yazma ya da okuma yapılabilir.
    RandomAccessFile sınıfı ile dosyanın açılış moduna göre okuma veya hem okuma hem yazma yapılabilir. RandomAccessFile
    Object sınıfından türetilmiştir. Closeable arayüzünü ve diğer bazı okuma ve yazmaya ilişkin arayüzleri
    desteklemektedir. Sınfın write ve writeXXX metotları ile yazma işlemi yapılabilir. read ve readXXX metotları ile de
    okuma yapılabilir. Sınıfın iki adet başlangıç metodu bulunmaktadır. Başlangıç metotlarının birinci parametreleri
    dosyaya ilişkin yol ifadesi ya da File referansıdır. Başlangıç metotlarının ikinci parametreleri ortaktır. Bu parametreler
    dosyanın açılış modunu belirlemek için kullanılır. Açılış modları “r”, “rw”, “rws”, “rwd” biçiminde olabilir.
    Bunlar dışındaki değerler exception oluşmasına yol açar:
    “r”     → Yalnızca okuma amaçlı açmak için kullanılır. Dosya yoksa exception oluşur.
    “rw”    → Hem okuma hem de yazma amaçlı kullanılan moddur. Dosya yoksa yaratılır.
    “rws” ve “rwd” açılış modları “New IO” mekanizmasına ilişkindir. Burada ele alınmayacaktır

    RandomAccessFile sınıfı dosyayı her zaman korur. RandomAccessFile sınıfı ile dosya açıldığında dosya göstericisi
    sıfır numaralı offet'i gösterir.

    Dosya Göstericisinin Konumlandırılması
    Sınfın seek metodu ile istenilen bir offsete konumlanılabilir. Sınıfın getFilePointer metodu ile o anki dosya
    göstericisinin nerede olduğu bilgisi alınabilir.
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
    RandomAccessFile sınıfı ile basit bir örnek. Örnekte hem dosyaya yazma hem de dosyadan okuma yapılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.randomaccess;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        RandomAccessFileStandardInputApp.run(args);
    }
}

package org.csystem.app.io.file.randomaccess;

import java.io.IOException;

public final class RandomAccessFileStandardInputApp {
    private RandomAccessFileStandardInputApp()
    {
    }

    public static void run(String  [] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argüman");
            System.exit(1);
        }

        try (RandomAccessFileStandardInput ra = new RandomAccessFileStandardInput(args[0], "elma", "Bir yazı giriniz:")) {
            ra.run();
        }
        catch (IOException ignore) {
            System.out.println("Bir problem oluştu");
        }
    }
}

package org.csystem.app.io.file.randomaccess;

import java.io.Closeable;
import java.io.EOFException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Scanner;

public final class RandomAccessFileStandardInput implements Closeable {
    private final RandomAccessFile m_randomAccessFile;
    private final Scanner m_kb;
    private final String m_quitText;
    private final String m_prompt;            ;

    private void runForWrite() throws IOException
    {
        for (;;) {
            System.out.println(m_prompt);
            String text = m_kb.nextLine();

            if (m_quitText.equals(text))
                break;

            m_randomAccessFile.writeUTF(text);
        }
    }

    private void runForRead() throws IOException
    {
        m_randomAccessFile.seek(0); // Dosya göstericisini başa çektik
        try {
            for (;;) {
                String text = m_randomAccessFile.readUTF();

                System.out.println(text);
            }
        }
        catch (EOFException ignore) {
        }
    }

    public RandomAccessFileStandardInput(String path, String quitText, String prompt) throws IOException
    {
        this(path, quitText, prompt, new Scanner(System.in));
    }

    public RandomAccessFileStandardInput(String path, String quitText, String prompt, Scanner kb) throws IOException
    {
        m_randomAccessFile = new RandomAccessFile(path, "rw");
        m_randomAccessFile.seek(m_randomAccessFile.length()); // Dosyanın sonuna konumlandırdık
        m_quitText = quitText;
        m_prompt = prompt;
        m_kb = kb;
    }

    public void run() throws IOException
    {
        runForWrite();
        runForRead();
    }

    public void close() throws IOException
    {
         m_randomAccessFile.close();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Endian kavramı: Birden fazla byte'dan oluşan değerlerin bellekte tutuluşları sistemden sisteme değişebilmektedir.
    Pratikte iki yerleşim biçimi kullanılmaktadır:
    1. Düşük anlamlı byte değerlerinin ona ayrılan belleğin düşük sayısal adresinde bulunacak biçimde yerleştirilmesine
    "little endian" denir.

    2. Düşük anlamlı byte değerlerinin ona ayrılan belleğin yüksek sayısal adresinde bulunacak biçimde yerleştirilmesine
    "big endian" denir.

    Endian kavramı tamsayılar için kullanılır. Gerçek sayı türleri için IEEE 754 standartlarında endian kavramı
    belirtilmemiştir. Teorik olarak gerçek sayılar için endian değişebilse de pratikte bu durum bir sorun oluşturmaz.

    Java'da tamsayı türleri için sistemden bağımsız olarak "big endian" kullanılır
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
    Çalışılan sistemin endian'ının anlaşılması
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.randomaccess;

import org.csystem.util.system.SystemUtil;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        System.out.printf("Your system is %s%n", SystemUtil.getEndianText());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ByteBuffer nesnesinin endian çalışma bilgisinin değiştirilmesi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.randomaccess;

import org.csystem.util.system.SystemUtil;

import java.nio.ByteBuffer;
import java.util.Scanner;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        short val = Short.parseShort(kb.nextLine());

        ByteBuffer byteBuffer = ByteBuffer.allocate(2).putShort(val);

        System.out.println(SystemUtil.getEndian(byteBuffer));

        SystemUtil.toLittleEndian(byteBuffer);

        System.out.println(SystemUtil.getEndian(byteBuffer));

        val = byteBuffer.getShort(0);

        System.out.printf("val = %d%n", val);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Standart cihaz bağımsız bitmap (Device Independent Bitmap) dosyasında resmin genişliği ve uzunluğu
    dosyanın başından itibaren 18'inci ve 22'inci offsetlerde int bir bilgi olarak tutulmaktadır. Formata göre bu bilgi
    "little endian" olarak yazılmıştır. Bu bilgiyi bir resim dosyasından alıp ekrana yazdıran programı yazınız. Program
    resmin geçerliliği gibi detaylı kontrolleri yapmayacaktır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.deviceindependentbitmap;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        DeviceIndependentBitmapApp.run(args);
    }
}

package org.csystem.app.io.file.deviceindependentbitmap;

import java.io.IOException;

public final class DeviceIndependentBitmapApp {
    private DeviceIndependentBitmapApp()
    {
    }

    public static void run(String  [] args)
    {
        if (args.length != 1) {
            System.err.println("Geçersiz sayıda argüman");
            System.exit(1);
        }

        try (DeviceIndependentBitmap dib = new DeviceIndependentBitmap(args[0])) {
            System.out.printf("%d x %d%n", dib.getWidth(), dib.getHeight());
            //...
        }
        catch (IOException ignore) {
            System.out.println("Bir problem oluştu");
        }
    }
}


package org.csystem.app.io.file.deviceindependentbitmap;

import java.io.Closeable;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public final class DeviceIndependentBitmap implements Closeable {
    private final RandomAccessFile m_bitmapFile;

    public DeviceIndependentBitmap(String path) throws IOException
    {
        m_bitmapFile = new RandomAccessFile(path, "r");
    }

    public int getWidth() throws IOException
    {
        m_bitmapFile.seek(18);
        byte [] data = new byte[4];
        m_bitmapFile.read(data);
        //...

        return ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN).getInt();
    }

    public int getHeight() throws IOException
    {
        m_bitmapFile.seek(22);
        byte [] data = new byte[4];
        m_bitmapFile.read(data);
        //...

        return ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN).getInt();
    }

    //...

    public void close() throws IOException
    {
         m_bitmapFile.close();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Aşağıdaki açıklanan programı yazınız:
    - Program içerisinde bir menü olacaktır
    - Menüler sırasıyla "Ekle", "Listele" ve "Çıkış" şeklindedir
    - Cihazlara ilişkin bilgiler (id, name, host) devices.dat isimli bir dosyada saklanacaktır
    - Dosya programın sonuna kadar açık kalacaktır
    - Örnek basit olması açısından dosya formatı kontrolü yapılmayacaktır
    - Fonksiyonel programlama kullanılarak daha iyi şekilde yazılabilir (Uygulama kursunda ele alınacaktır)
    - Bazı detaylar gözardı edilmiştir
    - TODO: Dosyanın sürekli açık kalmayan versiyonunu yazınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.io.file.devicespersistence;

final class App {
    private App()
    {
    }
    public static void main(String[] args)
    {
        DevicesPersistenceMenuRunner.run();
    }
}

package org.csystem.app.io.file.devicespersistence;

import org.csystem.app.io.file.devicespersistence.entity.DeviceInfo;
import org.csystem.util.Console;

import java.io.Closeable;
import java.io.EOFException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Scanner;

public final class DevicesPersistenceMenuApp implements Closeable {
    private final RandomAccessFile m_devicesFile;
    private final  Scanner m_kb = new Scanner(System.in);

    private void displayMenu()
    {
        System.out.println("1.Ekle");
        System.out.println("2.Listele");
        System.out.println("3.Çıkış");
        System.out.print("Seçenek:");
    }

    private DeviceInfo getDeviceByStandardInput()
    {
        int id = Console.readInt("Id değerini giriniz:", "Hatalı Giriş yaptınız:");

        String name = Console.read("Adını giriniz:");

        String host = Console.read("Host bilgisini giriniz:");
        //...

        return new DeviceInfo(id, name, host);
    }

    private DeviceInfo getDeviceByFile() throws IOException
    {
        int id = m_devicesFile.readInt();
        String name = m_devicesFile.readUTF();
        String host = m_devicesFile.readUTF();

        //Format kontrolü yapılmalı. Burada ele alınmayacak

        return new DeviceInfo(id, name, host);
    }

    private void insertProc() throws IOException
    {
        m_devicesFile.seek(m_devicesFile.length());
        DeviceInfo deviceInfo = this.getDeviceByStandardInput();

        m_devicesFile.seek(m_devicesFile.length());
        m_devicesFile.writeInt(deviceInfo.getId());
        m_devicesFile.writeUTF(deviceInfo.getName());
        m_devicesFile.writeUTF(deviceInfo.getHost());
    }

    private void listProc() throws IOException
    {
        try {
            m_devicesFile.seek(0);
            for (;;) {
                DeviceInfo deviceInfo = this.getDeviceByFile();
                System.out.println(deviceInfo);
            }
        }
        catch (EOFException ignore) {

        }
    }

    private void quitProc()
    {
        System.out.println("C ve Sistem Programcıları Derneği");
        System.out.println("Tekrar yapıyor musunuz?");
        System.exit(0);
    }

    private void doWorkForOption(int option) throws IOException
    {
        switch (option) {
            case 1:
                this.insertProc();
                break;
            case 2:
                this.listProc();
                break;
            case 3:
                this.quitProc();
                break;
            default:
                System.out.println("Geçersiz seçenek");
        }
    }

    public DevicesPersistenceMenuApp(String path) throws IOException
    {
        m_devicesFile = new RandomAccessFile(path, "rw");
    }

    public void run()
    {
        for (;;) {
            try {
                this.displayMenu();
                this.doWorkForOption(Integer.parseInt(m_kb.nextLine()));
            }
            catch (NumberFormatException ignore) {
                System.out.println("Seçenekler [1, 3] arasındaki tamsayılardan olmalıdır");
            }
            catch (Throwable ignore) {
                System.out.println("Beklenmedik bir durum oluştu");
            }
        }
    }

    public void close() throws IOException
    {
         m_devicesFile.close();
    }
}


package org.csystem.app.io.file.devicespersistence.entity;

public class DeviceInfo {
    private int m_id;
    private String m_name;
    private String m_host;

    public DeviceInfo(int id, String name, String host)
    {
        m_id = id;
        m_name = name;
        m_host = host;
    }

    public int getId()
    {
        return m_id;
    }

    public void setId(int id)
    {
        m_id = id;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        m_name = name;
    }

    public String getHost()
    {
        return m_host;
    }

    public void setHost(String host)
    {
        m_host = host;
    }

    public String toString()
    {
        return String.format("[%d]%s-%s", m_id, m_name, m_host);
    }
}


package org.csystem.app.io.file.devicespersistence;

import java.io.IOException;

public final class DevicesPersistenceMenuRunner {
    private DevicesPersistenceMenuRunner()
    {
    }

    public static void run()
    {
        try (DevicesPersistenceMenuApp devicesPersistenceMenuApp = new DevicesPersistenceMenuApp("devices.dat")) {
            devicesPersistenceMenuApp.run();
        }
        catch (IOException ignore) {
            System.out.println("Bir problem oluştu");
        }
    }
}




/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Dosyalar ve genel olarak giriş/çıkış işlemleri için Java'da daha başka sınıflar da vardır. Burada
    dosya işlemlerine yönelik temel olan sınıflar anlatılmıştır
----------------------------------------------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------------------------------------------
    Dosya işlemleri için yazılan yararlı sınıflar. Sınıflar detaylandırılmamıştır
---------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------
	FILE        : BitConverter.java
	AUTHOR      : Oğuz Karan
	LAST UPDATE : 11.06.2021

	BitConverter class for byte operations with built-in types and String

	This version is simplified

	Copyleft (c) 1993 by C and System Programmers Association (CSD)
	All Rights Free
-----------------------------------------------------------------------*/
package org.csystem.util.converter;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

public final class BitConverter {
	private static ByteBuffer allocate(int capacity)
	{
		return ByteBuffer.allocate(capacity);
	}

	private static ByteBuffer wrap(byte [] data, int offset, int length)
	{
		return ByteBuffer.wrap(data, offset, length);
	}

	private BitConverter()
	{
	}

	public static byte [] getBytes(String str)
	{
		return getBytes(str, StandardCharsets.UTF_8);
	}

	public static byte [] getBytes(String str, Charset charset)
	{
		return str.getBytes(charset);
	}

	public static byte [] getBytes(byte value)
	{
		return new byte [] {value};
	}

	public static byte[] getBytes(short value)
	{
		return allocate(2).putShort(value).array();
	}

	public static byte[] getBytes(int value)
	{
		return allocate(4).putInt(value).array();
	}

	public static byte[] getBytes(long value)
	{
		return allocate(8).putLong(value).array();
	}

	public static byte[] getBytes(char value)
	{
		return allocate(2).putChar(value).array();
	}

	public static byte[] getBytes(double value)
	{
		return allocate(8).putDouble(value).array();
	}

	public static byte[] getBytes(float value)
	{
		return allocate(4).putFloat(value).array();
	}

	public static byte[] getBytes(boolean value)
	{
		return new byte[] {(byte)(value ? 1 : 0)};
	}

	public static String toString(byte [] data)
	{
		return toString(data, StandardCharsets.UTF_8);
	}

	public static String toString(byte [] data, Charset charset)
	{
		return new String(data, charset);
	}

	public static short toShort(byte [] data)
	{
		return toShort(data, 0);
	}

	public static short toShort(byte [] data, int startIndex)
	{
		return wrap(data, startIndex, 2).getShort();
	}

	public static int toInt(byte [] data)
	{
		return toInt(data, 0);
	}

	public static int toInt(byte [] data, int startIndex)
	{
		return wrap(data, startIndex, 4).getInt();
	}

	public static long toLong(byte [] data)
	{
		return toLong(data, 0);
	}

	public static long toLong(byte [] data, int startIndex)
	{
		return wrap(data, startIndex, 8).getLong();
	}

	public static char toChar(byte [] data)
	{
		return toChar(data, 0);
	}

	public static char toChar(byte [] data, int startIndex)
	{
		return wrap(data, startIndex, 2).getChar();
	}

	public static double toDouble(byte [] data)
	{
		return toDouble(data, 0);
	}

	public static double toDouble(byte [] data, int startIndex)
	{
		return wrap(data, startIndex, 8).getDouble();
	}

	public static float toFloat(byte [] data)
	{
		return toFloat(data, 0);
	}

	public static float toFloat(byte [] data, int startIndex)
	{
		return wrap(data, startIndex, 4).getFloat();
	}

	public static boolean toBoolean(byte [] data)
	{
		return toBoolean(data, 0);
	}

	public static boolean toBoolean(byte [] data, int startIndex)
	{
		return data[startIndex] != 0;
	}
}

package org.csystem.util.system;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public final class SystemUtil {
    private SystemUtil()
    {
    }

    public static String getEndianText()
    {
        return isLittleEndian() ? "LITTLE ENDIAN" : "BIG ENDIAN";
    }

    public static ByteOrder getEndian(ByteBuffer byteBuffer)
    {
        return byteBuffer.order();
    }

    public static void toLittleEndian(ByteBuffer byteBuffer)
    {
        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
    }

    public static void toBigEndian(ByteBuffer byteBuffer)
    {
        byteBuffer.order(ByteOrder.BIG_ENDIAN);
    }

    public static boolean isLittleEndian()
    {
        return ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;
    }
}

package org.csystem.util;

import java.util.Scanner;

public final class CommandLineUtil {
    private CommandLineUtil()
    {
    }

    public static String [] getArguments(String [] args, String prompt, Scanner kb)
    {
        if (args.length != 0)
            return args;

        System.out.print(prompt);
        args = new String[1];
        args[0] = kb.nextLine();

        return args;
    }

    public static boolean checkForEquals(String [] args, int n)
    {
        return args.length == n;
    }

    public static boolean checkForGreater(String [] args, int n)
    {
        return args.length > n;
    }

    public static boolean checkForGreaterOrEqual(String [] args, int n)
    {
        return args.length >= n;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
                                            SON
----------------------------------------------------------------------------------------------------------------------*/
 ```
